{"meta":{"title":"孙祁的博客","subtitle":null,"description":null,"author":"孙祁","url":"https://sensitivemix.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-04-14T02:29:42.000Z","updated":"2019-04-14T02:29:42.000Z","comments":false,"path":"/404.html","permalink":"https://sensitivemix.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-04-14T02:29:42.000Z","updated":"2019-04-14T02:29:42.000Z","comments":false,"path":"about/index.html","permalink":"https://sensitivemix.github.io/about/index.html","excerpt":"","text":"后端工程师一枚，目前在做 Node.js 服务端开发。"},{"title":"书单","date":"2019-04-14T02:29:42.000Z","updated":"2019-04-14T02:29:42.000Z","comments":false,"path":"books/index.html","permalink":"https://sensitivemix.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-14T02:29:42.000Z","updated":"2019-04-14T02:29:42.000Z","comments":false,"path":"categories/index.html","permalink":"https://sensitivemix.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-04-14T02:29:42.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"links/index.html","permalink":"https://sensitivemix.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-04-14T02:29:42.000Z","updated":"2019-04-14T02:29:42.000Z","comments":false,"path":"repository/index.html","permalink":"https://sensitivemix.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-14T02:29:42.000Z","updated":"2019-04-14T02:29:42.000Z","comments":false,"path":"tags/index.html","permalink":"https://sensitivemix.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据库原理","slug":"数据库原理","date":"2019-01-07T14:08:33.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2019/01/07/数据库原理/","link":"","permalink":"https://sensitivemix.github.io/2019/01/07/数据库原理/","excerpt":"","text":"事务概念：事务指的是满足 ACID 特性到一组操作，可以通过 commit 提交事务，也可以使用 rollback 进行回滚。 1. 原子性（Atomicity）事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。 2. 一致性（Consistency）数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。 3. 隔离性（Isolation）一个事务所做的修改在最终提交以前，对其它事务是不可见的。 4. 持久性（Durability）一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。 使用重做日志来保证持久性。 AUTOCOMMIT Mysql 采用自动提交的方式，如果没有特殊设置事务级别，每个查询都会当做一个事务来提交。 并发一致性问题 丢失修改 T1 和 T2 两个事务都对数据进行了修改，T1 先修改，T2 再修复，这样 T2 就可能覆盖 T1 的数据 脏读 T1 通过事务对数据进行了更改，T2 读取了数据，这时候 T1 撤销了更改，这样 T2 读取的数据就是脏数据 不可重复读 T2 读取了数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不一样。 幻影读 T1 读取某个范围的数据，T2 往这个范围中插入数据，T1 再次读取的时候和第一次读取的结果不一样。产生并发不一致的主要原因是破坏了事务的隔离性，解决办法是通过对并发进行控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁实现需要用户自己控制，相当的负责。所以数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://sensitivemix.github.io/categories/数据库/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://sensitivemix.github.io/tags/Database/"}]},{"title":"如何设计关系型数据库","slug":"如何设计关系型数据库","date":"2019-01-06T07:33:07.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2019/01/06/如何设计关系型数据库/","link":"","permalink":"https://sensitivemix.github.io/2019/01/06/如何设计关系型数据库/","excerpt":"","text":"RDBMS从 0 到 1 设计关系型数据库，总共分为两个部分： 程序实例 存储管理模块 缓存模块（需要设计淘汰机制 SQL 解析 日志管理（记录所有操作） 权限划分（授权模块） 容灾机制（保证数据库高可用） 索引管理（保证数据查询执行效率） 锁管理（保证数据 ACID） 存储模块 文件系统（保证数据持久化） 索引模块为什么使用索引 快速查询数据，避免全表扫描，提升检索效率 什么样的信息可以成为索引 主键和唯一键可以作为索引 索引的数据结构 生成索引，建立二叉查找树进行二分查找 生成索引，建立 B-Tr ee 结构进行查找 根结点至少包含两个孩子、终端节点位于同一层、树中每个节点最多含有 m 个孩子（m &gt;+ 2）、除了根节点和叶节点外，其他每个节点至少有 ceil(m/2) 个孩子）通过合并、分裂来保持结构，层数不会变深 生成索引，建立 B+- Tree 进行查找 非叶子节点关键字和指针个数一样 非叶子节点的子数指针 P[i]，指向关键字值[K[i], K[i+1]] 的子树 非叶子节点仅用来索引，数据都保存在叶子节点中 所有叶子节点均有一个链指针指向下一个叶子节点（方便统计和查询） 优点 磁盘读写代价更低 查询效率更加稳定 logn 有利于对数据库的扫描 生成索引，建立 Hash 结构进行查找 无法避免全表扫描 只能做 ‘=’ ‘in’ 等操作，无法做范围查询（hash 之后无法保证值的大小） 无法用于排序操作 不能利用部分索引键做查询 hash 值重复率较高的情况下，效率没有 B Tree 效率高（不稳定） bitMap （位图） 只有几种值的时候（男，女），纯 CPU 叠加操作 缺点，锁的粒度大，不适用高并发的系统，适合统计较多的系统 密集索引和稀疏索引的区别 密集索引的文件中每个搜索码值都对应一个索引值 稀疏索引文件只为索引码的某些值建立索引项 InnoDB 若一个索引被定义，则这个索引被定义为密集索引 若没有索引被定义，该表的第一个唯一非空索引则作为密集索引 若不满足上述条件，内部会自己生成一个隐藏主键","categories":[{"name":"数据库","slug":"数据库","permalink":"https://sensitivemix.github.io/categories/数据库/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://sensitivemix.github.io/tags/Database/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://sensitivemix.github.io/tags/MongoDB/"}]},{"title":"Redis 的持久和取舍","slug":"Redis-的持久和取舍","date":"2019-01-01T13:32:37.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2019/01/01/Redis-的持久和取舍/","link":"","permalink":"https://sensitivemix.github.io/2019/01/01/Redis-的持久和取舍/","excerpt":"","text":"主要内容： 持久化的作用 什么是持久化 所有的数据都保存在内存中，重启会造成数据丢失，所以需要对数据的更新将异步保存在磁盘中 主流数据库的持久化方式 快照（mysql dump） 写日志（Mysql Binlog、MongoDB oplog、HBase Hlog） RDB 什么是 RDB Redis 存取快照，一般是 RDB 二进制文件，当重启的时候，Redis 重新载入这个快照，做到数据不丢失 缓存名称， dbfilename dump.rdb，常用命名 dbfilename dump-${port}.rdb 存储位置，dir ./，需要考虑到分盘 触发机制 - 主要三种方式 save，同步命令，排队执行，容易造成阻塞；文件策略，新文件替换老的文件，复杂度 O(n)，不消耗额外内存； bgsave，异步命令，后台执行；fork（阻塞发生在 fork） 子进程来执行操作；文件策略，新文件替换老的文件，复杂度 O(n)，缺点是消耗额外内存用于 fork auto，自动执行（save 60 10000）60 秒钟改变 10000 数据，自动生成 RDB 文件； 触发机制 - 不可忽略的方式 全量复制，适用于主从复制场景，主会自动生成 RDB 文件 debug reload，不需要清空重启，触发 RDB 文件生成 shutdown，shutdown save 生成 RDB 文件 AOF RDB 现存问题 耗时耗性能，O（n）数据，fork() 消耗内存；copy-on-write 策略；Disk I/O 性能损耗 不可控，易丢失数据，宕机丢失数据 什么是AOF 根据写入命令写入日志文件中，实时监控写入 三种策略 always，写在缓冲区中，每条命令 fsync 到磁盘，缺点 IO 开销大，优点不丢失数据 everysec，每秒写入磁盘中，容易丢失一秒的数据 no，操作系统来决定什么时候该 fsync 到磁盘，缺点不可控，优点就是不用管 重写 老的方式出现文件逐渐变大的问题，重写回 REDIS 会非常慢，针对这个问题提供了重写的功能，合并命令，几条命令合并成一条命令；过期的也不会写入新的文件；优点减少磁盘占用量，加速恢复速度 bgwriteof，fork 出子进程来重写，在内存进行重写 配置 auto-aof-rewrite-min-size（重写尺寸) auto-aof-rewrite-percentage （文件增长率） aof_current_size （当前尺寸） aof_base_size （上次启动和重写的尺寸） RDB 和 AOF 抉择 比较 命令 RDB AOF 启动优先级 低 高 体积 小 大 恢复速度 快 慢 数据安全性 丢数据 根据策略决定 轻重 重 轻 RDB 最佳策略 “关”，默认不开启（主从关闭掉），全量复制需要这个策略 集中管理，对数据备份有一定作用 主从，从开，保存历史文件（从节点不进行读写），不适合频繁读写，对磁盘存在影响 AOF 最佳策略 “开” 缓存和存储，对数据源没有很大 重写集中管理，单机多部署，60-70% 内存给 Redis everysec 最佳策略 小分片，maxMemory 缓存或者存储 监控（磁盘、内存、负载、网络） 足够内存（不需要全量给 Redis） 常见运维问题： fork 操作（内存页的拷贝） 同步操作 与内存量息息相关，内存越大，耗时越长（与机器类型相关） info: latest_fork_usec 上个执行 fork 微秒数 改善 fork 优先使用物理机或者高效支持 fork 操作的虚拟化技术 控制 Redis 实例最大的可用内存 合理配置 Linux 内存分配策略：vm.overcommit_memory=1 降低 fork 频率：放宽 AOF 重写触发时机，不必要的全量复制 进程外开销和优化 CPU 开销：RDB 和 AOF 文件生成，属于 CPU 密集型 优化：不做 CPU 绑定，不和 CPU 密集型项目一起部署 内存 开销：fork 内存开销，copy-on-write 优化：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled 硬盘 开销：AOF 和 RDB 文件写入 优化： 不要和高硬盘负载服务部署在一起：存储服务、消息队列等 no-apendfsync-on-rewrite = yes 根据写入量决定磁盘类型：例如 SSD 单机多部署持久化目录可以考虑分盘 AOF 追加阻塞 定位 Redis 日志 asynchronous AOF fsync is take too long Redis 命令，info Persistence（查看历史累计阻塞）； Linux 系统命令 Top 来查看资源占用 单机多实例部署","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://sensitivemix.github.io/tags/Redis/"}]},{"title":"跨域与安全","slug":"跨域与安全","date":"2018-12-02T14:03:24.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2018/12/02/跨域与安全/","link":"","permalink":"https://sensitivemix.github.io/2018/12/02/跨域与安全/","excerpt":"","text":"关于跨域，有两个误区： ✕ 动态请求就会有跨域的问题 ✔ 跨域只存在于浏览器端，不存在于安卓/ios/Node.js/python/ java等其它环境 ✕ 跨域就是请求发不出去了 ✔ 跨域请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了 之所以会跨域，是因为受到了同源策略的限制，同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 如下图所示： Screenshot-0.png 这三个源分别由于域名、协议和端口号不一致，导致会受到同源策略的限制。 同源策略具体限制些什么呢？ 不能向工作在不同源的的服务请求数据（client to server） 这里有个问题之前也困扰了我很久，就是为什么home.com加载的cdn.home.com/index.js可以向home.com发请求而不会跨域呢？其实home.com加载的JS是工作在home.com的，它的源不是提供JS的cdn，所以这个时候是没有跨域的问题的，并且script标签能够加载非同源的资源，不受同源策略的影响。 无法获取不同源的document/cookie等BOM和DOM，可以说任何有关另外一个源的信息都无法得到 （client to client） 为什么会有同源策略呢？ 为什么要限制不同源发请求？ 假设用户登陆了bank.com，同时打开了evil.com，如果没有任何限制，evil.com可以向bank.com请求到任何信息，进而就可以在evil.com向bank.com发转账请求等。 如果这样，为什么不直接限制写，只限制读？ 因为如果连请求都发不出去了，那就不能做跨域资源共享了，无法读取返回结果，evil.com就无法继续下一步的操作，如获取转账请求的一些必要的验证信息。 为什么限制跨域的DOM读取？ 如果不限制的话，那么很容易就可以伪装其它的网站，如套一个iframe或者通过window.open的方法，从而得到用户的操作和输入，如账户、密码。 另外，添加这个http头可以限制别人把你的网站套成它的iframe： X-Frame-Options: SAMEORIGIN 同源策略提供了安全的同时也造成了不方便，因为有时候我们需要跨域请求，如获取第三方提供的服务信息，由于第三方的源和本网站的源不一样，所以这个时候就受到跨域的限制。 跨域最常用的方法，应当属CORS，如下图所示： Screenshot-1.png 只要浏览器检测到响应头带上了CORS，并且允许的源包括了本网站，那么就不会拦截请求响应。 CORS把请求分为两种，一种是简单请求，另一种是需要触发预检请求，这两者是相对的，怎样才算“不简单”？只要属于下面的其中一种就不是简单请求： （1）使用了除GET/POST/HEAD之外的请求方式，如PUT/DELETE （2）使用了除Content-Type/Accept等几个常用的http头 这个时候就认为需要先发个预检请求，预检请求使用OPTIONS方式去检查当前请求是否安全，如下图所示： Screenshot-3.png 代码里面只发了一个请求，但在控制台看到了两个请求，第一个是OPTIONS，服务端返回： Screenshot-4.png 返回头里面包含了允许的请求头、请求方式、源，以及预检请求的有效期，上图是设置了20天，在这个有效期内就不用再发一个options的请求，实际上浏览器有一个最长时间，如Chrome是5分钟。如果在预检请求检测到当前请求不符合服务端设定的要求，则不会发出去了直接抛异常，这个时候就不用去发“复杂”的请求了。 如本源不在允许的源范围内，则会抛异常，无法获取返回结果： Screenshot-5.png location / { if ($request_method = ‘OPTIONS’) { add_header ‘Access-Control-Allow-Origin’ ‘‘; add_header ‘Access-Control-Allow-Methods’ ‘GET, POST, OPTIONS’; add_header ‘Access-Control-Max-Age’ 1728000; add_header ‘Content-Type’ ‘text/plain; charset=utf-8’; add_header ‘Content-Length’ 0; return 204; } add_header ‘Access-Control-Allow-Origin’ ‘‘; add_header ‘Access-Control-Allow-Methods’ ‘GET, POST, OPTIONS, PUT, DELETE’; add_header ‘Access-Control-Allow-Headers’ ‘DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range’; add_header ‘Access-Control-Expose-Headers’ ‘DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range’;}第二种常用的跨域的方法是JSONP，JSONP是利用了script标签能够跨域，如下代码所示： function updateList (data) { console.log(data);} $body.append(‘&lt;script src=“http://otherdomain.com/request?callback=updateList&quot;&gt;‘);代码先定义一个全局函数，然后把这个函数名通过callback参数添加到script标签的src，script的src就是需要跨域的请求，然后这个请求返回可执行的JS文本： // script响应返回的js内容为updateList([{ name: ‘hello’}]);由于它是一个js，并且已经定义了upldateList函数，所以能正常执行，并且跨域的数据通过传参得到。这就是JSONP的原理。 所以由于script/iframe/img等标签的请求默认是能带上cookie（cookie里面带上了登陆验证的票token），用这些标签发请求是能够绕过同源策略的，因此就可以利用这些标签做跨站请求伪造（CSRF），如下面代码所示： // 转账请求 // 配置路由器添加代理如果相应的网站支持GET请求，或者没有做进一步的防护措施，那么如果用户在另外一个页面登陆过了，再打开一个“有毒”的网站就中招了。 而动态ajax请求默认是不带cookie的，如果你要带cookie，可以设置ajax的一个属性withCredentials，如下代码所示： // 原生请求let xhr = new XMLHttpRequest();xhr.withCredentials = true;xhr.open(“GET”, “http://otherdomain.com/list&quot;);xhr.send(); // jquery请求$.ajax({ url: “http://otherdomain.com/list&quot;, xhrFields: { withCredentials: true }});这个时候就和img/script标签一样，能带上cookie，并且还支持除GET之外的其它方式。所以这种方式也是能实现CSRF的，如下图所示： Screenshot-6.png 所以如果转账请求只是不支持GET，没做其它的防护措施，仍然有CSRF攻击的风险。那怎么办呢？ 方法一是每次请求都要在参数里面显示地带上token即登陆的票，虽然跨域请求能带上cookie，但是通过document.cookie仍然是获取不到其它源的cookie的，所以攻击者无法在代码里面拿到cookie里面的token，所以就没办法了。方法一的缺点是会暴露token，所以需要带token的最好不能是GET，因为GET会把参数拼在url里面，用户可能会无意把链接发给别人，但不知道这个链接带上了自己的登陆信息。 方法二是每次转账请求前都先请求一个随机串，这个串只能用一次转账或者支付请求，用完就废弃，只有这个串对得上才能请求成功，攻击者是无法拿到这个串的，因为如果跨域请求带cookie，浏览器要求Access-Control-Allow-Origin不能为通配符，只能为指定的源，如： Access-Control-Allow-Origin: http://renren.com 由于攻击者所在的域名不在这个源里面，所以它是无法得到请求结果，所以请求不到随机串。因此这种方式也是可以避免CSRF攻击。 假设Allow-Origin为*，ajax设置withCredentials为true时，浏览器会抛异常，无法得到返回结果： Screenshot-7.png 另外服务还需要指定Allow-Credentials的头部，如下代码所示： add_header “Access-Control-Allow-Origin” “http://fedren.com&quot;;add_header “Access-Control-Allow-Credentials” “true”; 关于cookie还有两个地方值得注意，如下图所示： Screenshot-8.png 讨论完了client to server，我们再讨论client to client，即如何和一个frame通信，包括iframe或者使用window.open打开的页面。 iframe访问父页面可通过window.parent得到父窗口的window对象，通过open打开的可以用window.opener，进而得到父窗口的任何东西；父窗口如果和iframe同源的，那么可通过iframe.contentWindow得到iframe的window对象，如果和iframe不同源，则存在跨域的问题，这个时候可通过postMessage进行通讯。 使用postMessage的基本原理如下图所示： // main framelet iframeWin = document.querySelector(“#my-iframe”) .contentWindow;iframeWin.postMessage({age: 18}, “http://parent.com&quot;);iframeWin.onmessage = function(event) { console.log(“recv from iframe “, event.data);}; // iframewindow.onmessage = function(event) { // test event.origin if (event.origin !== expectOrigin) { return; } console.log(“recv from main frame “, event.data);}; window.parent.postMessage(“hello, this is from iframe “, “http://child.com&quot;); 以页面嵌入youtobe视频为例，通过以下代码可以在页面嵌入一个youtobe视频，嵌入的是一个跨域的iframe，所以就涉及到如何和iframe进行通信的问题。如怎么知道iframe的状态，触发父页面定义的事件onPlayerReady，这个是iframe通知父页面，而父页面可以调player.stopVideo控制iframe的行为，这个是父页面通知iframe。 Screenshot-9.png iframe通知父页面是通过window.parent.postMessage，同时监听message事件： Screenshot-10.png 经检查上面代码4304行的c就是window.parent，这个embed-player.js是iframe的js，iframe的js通过postMessage发送了一个消息，如上图右边的窗口所示，然后在父窗口的widgetapi.js就收到了这个消息 同样地，父窗口的JS也是使用postMessage向iframe发送消息，如下图所示： Screenshot-11.png 当然postMessage不限于跨域，同域的也可以使用，只是同域的话可以通过window对象互相操作，你可能需要额外定义一些全局变量或者函数供其它frame使用，或者是定义一套事件机制（可以借助原生事件/jQuery/Vue事件等）。 这里有一个特例，就是子域如mail.hello.com要跨hello.com的时候，可以显式地设置子域的document.domain值为父域的domain： document.domain = “hello.com”;就不会有跨域的问题了。 补充一点，如果需要和同源的不同标签页进行通信可以使用localStorage，即一个页面设置localStorage，其它页面就会触发storage事件： window.addEventListener(‘storage’, function(e) { e.key; e.oldValue; e.newValue; e.url; e.storageArea;}); 再补充一点，websocket是不受同源策略限制的，没有跨域的问题。CSS的字体文件是会有跨域问题，指定CORS就能加载其它源的字体文件（通常是放在cdn上的）。而canvas动态加载的外部image，也是需要指定CORS头才能进行图片处理，否则只能画不能读取。 最后，跨域分为两种，一种是跨域请求，另一种访问跨域的页面，跨域请求可以通过CORS/JSONP等方法进行访问，跨域的页面主要通过postMesssage的方式。由于跨域请求不但能发出去还能带上cookie，所以要规避跨站请求伪造攻击的风险，特别是涉及到钱的那种请求。","categories":[{"name":"开发","slug":"开发","permalink":"https://sensitivemix.github.io/categories/开发/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://sensitivemix.github.io/tags/Database/"},{"name":"InfluxDB","slug":"InfluxDB","permalink":"https://sensitivemix.github.io/tags/InfluxDB/"}]},{"title":"如何构建易于运维的后端应用","slug":"如何构建易于运维的后端应用","date":"2018-12-01T06:42:27.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2018/12/01/如何构建易于运维的后端应用/","link":"","permalink":"https://sensitivemix.github.io/2018/12/01/如何构建易于运维的后端应用/","excerpt":"","text":"六点要点 保持简单并消除不一致 无状态的、事务的（stateless、scalable） 单一代码库 （Codebase -&gt; Deploys） 简单地观察和干预内部行为 日志级别 （trace、debug、info、warn、error、fatal） 结构化日志 （bunyan、winston） 时序数据和图表（Grafana） 时序数据（InfluxDB） 通过环境变量管理配置 exports.LISTEN = process.env.LISTEN || 3000 出了问题要有办法发现 self-check yield [] Promise.all [] 错误收集（Sentry、raven） 操作自动化 Why 保证一致 节省时间 可重复 可复用 How 依赖（package.json） 数据库变更（db-migrate） 系统环境（Dockerfile） 构建、测试和发布（CI） 其他自动化脚本 尝试从错误中自动恢复 数据一致性修复任务（MySQL MongoDB Redis Cache） 划清组件之间的界限 守护进程（重启） 负载均衡（Https、IP限流） 日志（写入文件、轮转he ）","categories":[{"name":"学习资料","slug":"学习资料","permalink":"https://sensitivemix.github.io/categories/学习资料/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://sensitivemix.github.io/tags/Tutorial/"}]},{"title":"JavaScript 代码整洁之道中文版","slug":"JavaScript-代码整洁之道中文版","date":"2018-12-01T06:33:40.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2018/12/01/JavaScript-代码整洁之道中文版/","link":"","permalink":"https://sensitivemix.github.io/2018/12/01/JavaScript-代码整洁之道中文版/","excerpt":"","text":"# 目录 概述 变量 函数 对象和数据结构 类 测试 并发 错误处理 格式 注释 概述 Robert C. Martin 在 《代码整洁之道》 中提到的软件工程原则，同样适用于 JavaScript。这不是一个风格参考。它指导如何用 JavaScript 编写可读、可复用、可重构的软件。 并不是每一个原则都必须严格遵循，甚至很少得到大家的认同。它们仅用于参考，不过要知道这些原则都是《代码整洁之道》的作者们累积多年的集体经验。 我们在软件工程方面的技术发展刚刚超过 50 年，我们仍然在学习很多东西。当软件架构和架构本身一样古老的时候，我们应该遵循更为严格规则。现在，对于你和你的团队编写的 JavaScript 代码，不妨依据这些准则来进行质量评估。 还有一件事：知道这些不会马上让你成为更好的软件开发者，在工作中常年使用这些准则不能让你避免错误。每一段代码都从最初的草图开始到最终成型，就像为湿粘土塑形一样。最后，当我们与同行一起审查的时候，再把不完美的地方消除掉。不要因为初稿需要改善而否定自己，需要要否定的只是那些代码！ 变量使用有准确意义的变量名不好: var yyyymmdstr = moment().format(‘YYYY/MM/DD’); 好: var yearMonthDay = moment().format(‘YYYY/MM/DD’); 在变量的值不会改变时使用 ES6 的常量在不好的示例中，变量可以被改变。如果你申明一个常量，它会在整个程序中始终保持不变。 不好: var FIRST_US_PRESIDENT = “George Washington”; 好: const FIRST_US_PRESIDENT = “George Washington”; 对同一类型的变量使用相同的词汇不好: getUserInfo();getClientData();getCustomerRecord(); 好: getUser(); 使用可检索的名称我们阅读的代码永远比写的折。写可读性强、易于检索的的代码非常重要。在程序中使用无明确意义的变量名会难以理解，对读者造成伤害。所以，把名称定义成可检索的。 不好: // 见鬼，525600 是个啥？for (var i = 0; i &lt; 525600; i++) { runCronJob();} 好: // 用 `var` 申明为大写的全局变量var MINUTES_IN_A_YEAR = 525600;for (var i = 0; i &lt; MINUTES_IN_A_YEAR; i++) { runCronJob();} 使用解释性的变量不好: const cityStateRegex = /^(.+)[,\\\\s]+(.+?)\\s*(\\d{5})?$/;saveCityState(cityStateRegex.match(cityStateRegex)[1], cityStateRegex.match(cityStateRegex)[2]); 好: const cityStateRegex = /^(.+)[,\\\\s]+(.+?)\\s*(\\d{5})?$/;const match = cityStateRegex.match(cityStateRegex)const city = match[1];const state = match[2];saveCityState(city, state); 避免暗示显式优于隐式。 不好: var locations = [‘Austin’, ‘New York’, ‘San Francisco’];locations.forEach((l) =&gt; { doStuff(); doSomeOtherStuff(); … … … // 等等，`l` 又是什么？ dispatch(l);}); 好: var locations = [‘Austin’, ‘New York’, ‘San Francisco’];locations.forEach((location) =&gt; { doStuff(); doSomeOtherStuff(); … … … dispatch(location);}); 不要添加没必要的上下文如果你的类名称/对象名称已经说明了它们是什么，不要在(属性)变量名里重复。 不好: var Car = { carMake: ‘Honda’, carModel: ‘Accord’, carColor: ‘Blue’}; function paintCar(car) { car.carColor = ‘Red’;} 好: var Car = { make: ‘Honda’, model: ‘Accord’, color: ‘Blue’}; function paintCar(car) { car.color = ‘Red’;} 短路语法比条件语句更清晰不好: function createMicrobrewery(name) { var breweryName; if (name) { breweryName = name; } else { breweryName = ‘Hipster Brew Co.’; }} 好: function createMicrobrewery(name) { var breweryName = name || ‘Hipster Brew Co.’} 函数函数参数 (理论上少于等于2个)限制函数参数的数量极为重要，它会让你更容易测试函数。超过3个参数会导致组合膨胀，以致于你必须根据不同的参数对大量不同的情况进行测试。 理想情况下是没有参数。有一个或者两个参数也还好，三个就应该避免了。多于那个数量就应该考虑合并。通常情况下，如果你有多于2个参数，你的函数会尝试做太多事情。如果不是这样，大多数时候可以使用一个高阶对象作为参数使用。 既然 JavaScript 允许我们在运行时随意创建对象，而不需要预先定义样板，那么你在需要很多参数的时候就可以使用一个对象来处理。 不好: function createMenu(title, body, buttonText, cancellable) { …} 好: var menuConfig = { title: ‘Foo’, body: ‘Bar’, buttonText: ‘Baz’, cancellable: true} function createMenu(menuConfig) { …} 一个函数只做一件事目前这是软件工程中最重要的原则。如果函数做了较多的事情，它就难以组合、测试和推测。当你让函数只做一件事情的时候，它们就很容易重构，而且代码读起来也会清晰得多。你只需要遵循本指南的这一条，就能领先于其他很多开发者。 不好: function emailClients(clients) { clients.forEach(client =&gt; { let clientRecord = database.lookup(client); if (clientRecord.isActive()) { email(client); } });} 好: function emailClients(clients) { clients.forEach(client =&gt; { emailClientIfNeeded(client); });} function emailClientIfNeeded(client) { if (isClientActive(client)) { email(client); }} function isClientActive(client) { let clientRecord = database.lookup(client); return clientRecord.isActive();} 函数名称要说明它做的事不好: function dateAdd(date, month) { // …} let date = new Date(); // 很难从函数名了解到加了什么dateAdd(date, 1); 好: function dateAddMonth(date, month) { // …} let date = new Date();dateAddMonth(date, 1); 函数应该只抽象一个层次如果你有多个层次的抽象，那么你的函数通常做了太多事情，此时应该拆分函数使其易于复用和易于测试。 不好: function parseBetterJSAlternative(code) { let REGEXES = [ // … ]; let statements = code.split(‘ ‘); let tokens; REGEXES.forEach((REGEX) =&gt; { statements.forEach((statement) =&gt; { // … }) }); let ast; tokens.forEach((token) =&gt; { // lex… }); ast.forEach((node) =&gt; { // parse… })} 好: function tokenize(code) { let REGEXES = [ // … ]; let statements = code.split(‘ ‘); let tokens; REGEXES.forEach((REGEX) =&gt; { statements.forEach((statement) =&gt; { // … }) }); return tokens;} function lexer(tokens) { let ast; tokens.forEach((token) =&gt; { // lex… }); return ast;} function parseBetterJSAlternative(code) { let tokens = tokenize(code); let ast = lexer(tokens); ast.forEach((node) =&gt; { // parse… })} 删除重复代码任何情况下，都不要有重复的代码。没有任何原因，它很可能是阻碍你成为专业开发者的最糟糕的一件事。重复代码意味着你要修改某些逻辑的时候要修改不止一个地方的代码。JavaScript 是弱类型语句，所以它很容易写通用性强的函数。记得利用这一点！ 不好: function showDeveloperList(developers) { developers.forEach(developers =&gt; { var expectedSalary = developer.calculateExpectedSalary(); var experience = developer.getExperience(); var githubLink = developer.getGithubLink(); var data = { expectedSalary: expectedSalary, experience: experience, githubLink: githubLink }; render(data); });} function showManagerList(managers) { managers.forEach(manager =&gt; { var expectedSalary = manager.calculateExpectedSalary(); var experience = manager.getExperience(); var portfolio = manager.getMBAProjects(); var data = { expectedSalary: expectedSalary, experience: experience, portfolio: portfolio }; render(data); });} 好: function showList(employees) { employees.forEach(employee =&gt; { var expectedSalary = employee.calculateExpectedSalary(); var experience = employee.getExperience(); var portfolio; if (employee.type === &apos;manager&apos;) { portfolio = employee.getMBAProjects(); } else { portfolio = employee.getGithubLink(); } var data = { expectedSalary: expectedSalary, experience: experience, portfolio: portfolio }; render(data); });} 使用默认参数代替短路表达式不好: function writeForumComment(subject, body) { subject = subject || ‘No Subject’; body = body || ‘No text’;} 好: function writeForumComment(subject = ‘No subject’, body = ‘No text’) { …} 用 Object.assign 设置默认对象不好: var menuConfig = { title: null, body: ‘Bar’, buttonText: null, cancellable: true} function createMenu(config) { config.title = config.title || ‘Foo’ config.body = config.body || ‘Bar’ config.buttonText = config.buttonText || ‘Baz’ config.cancellable = config.cancellable === undefined ? config.cancellable : true; } createMenu(menuConfig); 好: var menuConfig = { title: ‘Order’, // User did not include ‘body’ key buttonText: ‘Send’, cancellable: true} function createMenu(config) { config = Object.assign({ title: ‘Foo’, body: ‘Bar’, buttonText: ‘Baz’, cancellable: true }, config); // 现在 config 等于: {title: “Foo”, body: “Bar”, buttonText: “Baz”, cancellable: true} // …} createMenu(menuConfig); 不要把标记用作函数参数标记告诉你的用户这个函数做的事情不止一件。但是函数应该只做一件事。如果你的函数中会根据某个布尔参数产生不同的分支，那就拆分这个函数。 不好: function createFile(name, temp) { if (temp) { fs.create(‘./temp/‘ + name); } else { fs.create(name); }} 好: function createTempFile(name) { fs.create(‘./temp/‘ + name);} function createFile(name) { fs.create(name);} 避免副作用如果一个函数不是获取一个输入的值并返回其它值，它就有可能产生副作用。这些副作用可能是写入文件、修改一些全局变量，或者意外地把你所有钱转给一个陌生人。 现在你确实需要在程序中有副作用。像前面提到的那样，你可能需要写入文件。现在你需要做的事情是搞清楚在哪里集中完成这件事情。不要使用几个函数或类来完成写入某个特定文件的工作。采用一个，就一个服务来完成。 关键点是避免觉的陷阱，比如在没有结构的对象间共享状态，使用可以被任意修改的易变的数据类型，没有集中处理发生的副作用等。如果你能做到，你就能比其他大多数程序员更愉快。 不好: // 下面的函数使用了全局变量。// 如果有另一个函数在使用 name，现在可能会因为 name 变成了数组而不能正常运行。var name = ‘Ryan McDermott’; function splitIntoFirstAndLastName() { name = name.split(‘ ‘);} splitIntoFirstAndLastName(); console.log(name); // [‘Ryan’, ‘McDermott’]; 好: function splitIntoFirstAndLastName(name) { return name.split(‘ ‘);} var name = ‘Ryan McDermott’var newName = splitIntoFirstAndLastName(name); console.log(name); // ‘Ryan McDermott’;console.log(newName); // [‘Ryan’, ‘McDermott’]; 不要写入全局函数JavaScript 中全局污染是一件糟糕的事情，因为它可能和另外库发生冲突，然而使用你 API 的用户却不会知道——直到他们在生产中遇到一个异常。来思考一个例子：你想扩展 JavaScript 的原生 Array，使之拥有一个 diff 方法，用来展示两数据之前的区别，这时你会怎么做？你可以给 Array.prototype 添加一个新的函数，但它可能会与其它想做同样事情的库发生冲突。如果那个库实现的 diff 只是比如数组中第一个元素和最后一个元素的异同会发生什么事情呢？这就是为什么最好是使用 ES6 的类语法从全局的 Array 派生一个类来做这件事。 不好: Array.prototype.diff = function(comparisonArray) { var values = []; var hash = {}; for (var i of comparisonArray) { hash[i] = true; } for (var i of this) { if (!hash[i]) { values.push(i); } } return values;} 好: class SuperArray extends Array { constructor(…args) { super(…args); } diff(comparisonArray) { var values = []; var hash = {}; for (var i of comparisonArray) { hash\\[i\\] = true; } for (var i of this) { if (!hash\\[i\\]) { values.push(i); } } return values; }} 喜欢上命令式编程之上的函数式编程如果 Haskell 是 IPA 那么 JavaScript 就是 O’Douls。就是说，与 Haskell 不同，JavaScript 不是函数式编程语言，不过它仍然有一点函数式的意味。函数式语言更整洁也更容易测试，所以你最好能喜欢上这种编程风格。 不好: const programmerOutput = [ { name: ‘Uncle Bobby’, linesOfCode: 500 }, { name: ‘Suzie Q’, linesOfCode: 1500 }, { name: ‘Jimmy Gosling’, linesOfCode: 150 }, { name: ‘Gracie Hopper’, linesOfCode: 1000 }]; var totalOutput = 0; for (var i = 0; i &lt; programmerOutput.length; i++) { totalOutput += programmerOutput[i].linesOfCode;} 好: const programmerOutput = [ { name: ‘Uncle Bobby’, linesOfCode: 500 }, { name: ‘Suzie Q’, linesOfCode: 1500 }, { name: ‘Jimmy Gosling’, linesOfCode: 150 }, { name: ‘Gracie Hopper’, linesOfCode: 1000 }]; var totalOutput = programmerOutput .map((programmer) =&gt; programmer.linesOfCode) .reduce((acc, linesOfCode) =&gt; acc + linesOfCode, 0); 封装条件不好: if (fsm.state === ‘fetching’ &amp;&amp; isEmpty(listNode)) { /// …} 好: function shouldShowSpinner(fsm, listNode) { return fsm.state === ‘fetching’ &amp;&amp; isEmpty(listNode);} if (shouldShowSpinner(fsmInstance, listNodeInstance)) { // …} 避免否定条件不好: function isDOMNodeNotPresent(node) { // …} if (!isDOMNodeNotPresent(node)) { // …} 好: function isDOMNodePresent(node) { // …} if (isDOMNodePresent(node)) { // …} 避免条件这似乎是个不可能完成的任务。大多数人第一次听到这个的时候会说，“没有 if 语句我该怎么办？”回答是在多数情况下都可以使用多态来实现相同的任务。第二个问题通常是，“那太好了，不过我为什么要这么做呢？”答案在于我们之前了解过整洁的概念：一个函数应该只做一件事情。如果你的类和函数有 if 语句，就意味着你的函数做了更多的事。记住，只做一件事。 不好: class Airplane { //… getCruisingAltitude() { switch (this.type) { case ‘777’: return getMaxAltitude() - getPassengerCount(); case ‘Air Force One’: return getMaxAltitude(); case ‘Cessna’: return getMaxAltitude() - getFuelExpenditure(); } }} 好: class Airplane { //…} class Boeing777 extends Airplane { //… getCruisingAltitude() { return getMaxAltitude() - getPassengerCount(); }} class AirForceOne extends Airplane { //… getCruisingAltitude() { return getMaxAltitude(); }} class Cessna extends Airplane { //… getCruisingAltitude() { return getMaxAltitude() - getFuelExpenditure(); }} 避免类型检查(第1部分)JavaScript 是无类型的，也就是说函数可以获取任意类型的参数。有时候你会觉得这种自由是种折磨，因而会不由自主地在函数中使用类型检查。有很多种方法可以避免类型检查。首先要考虑的就是 API 的一致性。 不好: function travelToTexas(vehicle) { if (vehicle instanceof Bicycle) { vehicle.peddle(this.currentLocation, new Location(‘texas’)); } else if (vehicle instanceof Car) { vehicle.drive(this.currentLocation, new Location(‘texas’)); }} 好: function travelToTexas(vehicle) { vehicle.move(this.currentLocation, new Location(‘texas’));} 避免类型检查(第2部分)如果你在处理基本类型的数据，比如字符串，整数和数组，又不能使用多态，这时你会觉得需要使用类型检查，那么可以考虑 TypeScript。这是普通 JavaScript 的完美替代品，它在标准的 JavaScript 语法之上提供了静态类型。普通 JavaScript 手工检查类型的问题在于这样会写很多废话，而人为的“类型安全”并不能弥补损失的可读性。让你的 JavaScript 保持整洁，写很好的测试，并保持良好的代码审查。否则让 TypeScript (我说过，这是很好的替代品)来做所有事情。 不好: function combine(val1, val2) { if (typeof val1 == “number” &amp;&amp; typeof val2 == “number” || typeof val1 == “string” &amp;&amp; typeof val2 == “string”) { return val1 + val2; } else { throw new Error(‘Must be of type String or Number’); }} 好: function combine(val1, val2) { return val1 + val2;} 不要过度优化现在浏览器在运行时悄悄地做了很多优化工作。很多时候你的优化都是在浪费时间。这里有很好的资源 可以看看哪些优化比较缺乏。把它们作为目标，直到他们能固定下来的时候。 不好: // 在旧浏览器中，每次循环的成本都比较高，因为每次都会重算 `len`。// 现在浏览器中，这已经被优化了。for (var i = 0, len = list.length; i &lt; len; i++) { // …} 好: for (var i = 0; i &lt; list.length; i++) { // …} 删除不用的代码不用的代码和重复的代码一样糟糕。在代码库中保留无用的代码是毫无道理的事情。如果某段代码用不到，那就删掉它！如果你以后需要它，仍然可以从代码库的历史版本中找出来。 不好: function oldRequestModule(url) { // …} function newRequestModule(url) { // …} var req = newRequestModule;inventoryTracker(‘apples’, req, ‘www.inventory-awesome.io&#39;); 好: function newRequestModule(url) { // …} var req = newRequestModule;inventoryTracker(‘apples’, req, ‘www.inventory-awesome.io&#39;); 对象和数据结构使用 getter 和 setterJavaScript 没有接口或者类型，也没有像 public 和 private 这样的关键字，所以很难应用设计模式。实事上，在对象上使用 getter 和 setter 访问数据远好于直接查找对象属性。“为什么？”你可能会这样问。那好，下面列出了原因： 你想在获取对象属性的时候做更多的事，不必在代码中寻找所有访问的代码来逐个修改。 在进行 set 的时候可以进行额外的数据检验。 封装内部表现。 在获取或设置的时候易于添加日志和错误处理。 继承当前类，可以重写默认功能。 可以对对象属性进行懒加载，比如说从服务器获取属性的数据。 不好: class BankAccount { constructor() { this.balance = 1000; }} let bankAccount = new BankAccount(); // 买鞋…bankAccount.balance = bankAccount.balance - 100; 好: class BankAccount { constructor() { this.balance = 1000; } // It doesn’t have to be prefixed with `get` or `set` to be a getter/setter withdraw(amount) { if (verifyAmountCanBeDeducted(amount)) { this.balance -= amount; } }} let bankAccount = new BankAccount(); // 买鞋…bankAccount.withdraw(100); 让对象拥有私有成员这可以通过闭包实现(ES5以之前的版本)。 不好: var Employee = function(name) { this.name = name;} Employee.prototype.getName = function() { return this.name;} var employee = new Employee(‘John Doe’);console.log(‘Employee name: ‘ + employee.getName()); // Employee name: John Doedelete employee.name;console.log(‘Employee name: ‘ + employee.getName()); // Employee name: undefined 好: var Employee = (function() { function Employee(name) { this.getName = function() { return name; }; } return Employee;}()); var employee = new Employee(‘John Doe’);console.log(‘Employee name: ‘ + employee.getName()); // Employee name: John Doedelete employee.name;console.log(‘Employee name: ‘ + employee.getName()); // Employee name: John Doe 类单一职责原则 (SRP)正如《代码整洁之道》所说，“不应该有超过一个原因来改变类”。往一个类里塞进许多功能是件诱人的事情，就像在坐飞机的时候只带一个手提箱一样。这带来的问题是，你的类不会在概念上有凝聚力，会有很多因素造成对它的改变。让你的类需要改变的次数最少是件非常重要的事情。这是因为如果一个类里塞入了太多功能，你只修改它的一部分，可能会让人难以理解它为何会影响代码库中其它相关模块。 不好: class UserSettings { constructor(user) { this.user = user; } changeSettings(settings) { if (this.verifyCredentials(user)) { // … } } verifyCredentials(user) { // … }} 好: class UserAuth { constructor(user) { this.user = user; } verifyCredentials() { // … }} class UserSettings { constructor(user) { this.user = user; this.auth = new UserAuth(user) } changeSettings(settings) { if (this.auth.verifyCredentials()) { // … } }} 开放封装原则(OCP)正如 Bertrand Meyer 所说，“软件实体(类、模块、函数等)应该对扩展开放，对修改封闭。”这是什么意思呢？这个原则基本上规定了你应该允许用户扩展你的模块，但不需要打开 .js 源代码文件来进行编辑。 不好: class AjaxRequester { constructor() { // 如果我们需要另一个 HTTP 方法，比如 DELETE，该怎么办？ // 我们必须打开这个文件然后手工把它加进去 this.HTTP_METHODS = [‘POST’, ‘PUT’, ‘GET’]; } get(url) { // … } } 好: class AjaxRequester { constructor() { this.HTTP_METHODS = [‘POST’, ‘PUT’, ‘GET’]; } get(url) { // … } addHTTPMethod(method) { this.HTTP_METHODS.push(method); }} 里氏替换原则(LSP)这是一个吓人的术语，但描述的却是个简单的概念。它的正式定义为“如果 S 是 T 的子类，那所有 T 类型的对象都可以替换为 S 类型的对象(即 S 类型的对象可以替代 T 类型的对象)，这个替换不会改变程序的任何性质(正确性、任务执行等)。”这确实是个吓人的定义。 对此最好的解释是，如果你有父类和子类，那么父类和子类可以交替使用而不会造成不正确的结果。这可能仍然让人感到疑惑，那么让我们看看经典的正方形和矩形的例子。在数学上，正方形也是矩形，但是如果你在模型中通过继承使用 “is-a” 关系，你很快就会陷入困境。 不好: class Rectangle { constructor() { this.width = 0; this.height = 0; } setColor(color) { // … } render(area) { // … } setWidth(width) { this.width = width; } setHeight(height) { this.height = height; } getArea() { return this.width * this.height; }} class Square extends Rectangle { constructor() { super(); } setWidth(width) { this.width = width; this.height = width; } setHeight(height) { this.width = height; this.height = height; }} function renderLargeRectangles(rectangles) { rectangles.forEach((rectangle) =&gt; { rectangle.setWidth(4); rectangle.setHeight(5); let area = rectangle.getArea(); // 不好：这里对正方形会返回 25，但应该是 20. rectangle.render(area); })} let rectangles = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles(rectangles); 好: class Shape { constructor() {} setColor(color) { // … } render(area) { // … }} class Rectangle extends Shape { constructor() { super(); this.width = 0; this.height = 0; } setWidth(width) { this.width = width; } setHeight(height) { this.height = height; } getArea() { return this.width * this.height; }} class Square extends Shape { constructor() { super(); this.length = 0; } setLength(length) { this.length = length; } getArea() { return this.length * this.length; }} function renderLargeShapes(shapes) { shapes.forEach((shape) =&gt; { switch (shape.constructor.name) { case ‘Square’: shape.setLength(5); case ‘Rectangle’: shape.setWidth(4); shape.setHeight(5); } let area = shape.getArea(); shape.render(area); })} let shapes = [new Rectangle(), new Rectangle(), new Square()];renderLargeShapes(shapes); 接口隔离原则(ISP)JavaScript 中没有接口，所以实行这个原则不能像其它语言那样严格。然而即使对 JavaScript 的弱类型系统来说，它仍然是重要的相关。 ISP 指出，“客户不应该依赖于那些他们不使用的接口。” 由于 Duck Typing 理论，接口在 JavaScript 中是个隐性契约。 在 JavaScript 中有一个很好的例子来演示这个原则，即一个拥有巨大设置对象的类。比较好的做法是不要求客户设置大量的选项，因为多数时候他们不需要所有设置。让这些选项成为可选的有助于防止“胖接口”。 不好: class DOMTraverser { constructor(settings) { this.settings = settings; this.setup(); } setup() { this.rootNode = this.settings.rootNode; this.animationModule.setup(); } traverse() { // … }} let $ = new DOMTraverser({ rootNode: document.getElementsByTagName(‘body’), animationModule: function() {} // 多数时候我们不需要动画 // …}); 好: class DOMTraverser { constructor(settings) { this.settings = settings; this.options = settings.options; this.setup(); } setup() { this.rootNode = this.settings.rootNode; this.setupOptions(); } setupOptions() { if (this.options.animationModule) { // … } } traverse() { // … }} let $ = new DOMTraverser({ rootNode: document.getElementsByTagName(‘body’), options: { animationModule: function() {} }}); 依赖倒置原则(DIP)这个原则说明了两个基本问题： 1. 上层模块不应该依赖下层模块，两者都应该依赖抽象。 2. 抽象不应该依赖于具体实现，具体实现应该依赖于抽象。 这一开始可能很难理解，但是如果你使用 Angular.js，你已经看到了对这个原则的一种实现形式：依赖注入(DI)。虽然它们不是完全相同的概念，DIP 阻止上层模块去了解下层模块的细节并设置它们。它可以通过 DI 来实现。这带来的巨大好处降低了模块间的耦合。耦合是种非常不好的开发模式，因为它让代码难以重构。 前提已经提到，JavaScript 没有接口，因此抽象依赖于隐性契约。也就是说，一个对象/类会把方法和属性暴露给另一个对象/类。在下面的例子中，隐性契约是任何用于 InventoryTracker 的 Request 模块都应该拥有 requestItems 方法。 不好: class InventoryTracker { constructor(items) { this.items = items; // 不好：我们创建了一个依赖于特定请求的实现。 // 我们应该只依赖请求方法：\\`request\\` 的 requestItems this.requester = new InventoryRequester(); } requestItems() { this.items.forEach((item) =&gt; { this.requester.requestItem(item); }); }} class InventoryRequester { constructor() { this.REQ_METHODS = [‘HTTP’]; } requestItem(item) { // … }} let inventoryTracker = new InventoryTracker([‘apples’, ‘bananas’]);inventoryTracker.requestItems(); 好: class InventoryTracker { constructor(items, requester) { this.items = items; this.requester = requester; } requestItems() { this.items.forEach((item) =&gt; { this.requester.requestItem(item); }); }} class InventoryRequesterV1 { constructor() { this.REQ_METHODS = [‘HTTP’]; } requestItem(item) { // … }} class InventoryRequesterV2 { constructor() { this.REQ_METHODS = [‘WS’]; } requestItem(item) { // … }} // 通过构建外部依赖并注入它们，我们很容易把请求模块替换成// 一个使用 WebSocket 的新模块。let inventoryTracker = new InventoryTracker([‘apples’, ‘bananas’], new InventoryRequesterV2());inventoryTracker.requestItems(); 多用 ES6 类语法，少用 ES5 构造函数语法在经典的 ES5 的类定义中，很难找到易读的继承、构造、方法定义等。如果你需要继承(你会发现做不到)，那就应该使用类语法。不过，应该尽可能使用小函数而不是类，直到你需要更大更复杂的对象。 不好: var Animal = function(age) { if (!(this instanceof Animal)) { throw new Error(“Instantiate Animal with `new`“); } this.age = age; }; Animal.prototype.move = function() {}; var Mammal = function(age, furColor) { if (!(this instanceof Mammal)) { throw new Error(“Instantiate Mammal with `new`“); } Animal.call(this, age); this.furColor = furColor; }; Mammal.prototype = Object.create(Animal.prototype);Mammal.prototype.constructor = Mammal;Mammal.prototype.liveBirth = function() {}; var Human = function(age, furColor, languageSpoken) { if (!(this instanceof Human)) { throw new Error(“Instantiate Human with `new`“); } Mammal.call(this, age, furColor); this.languageSpoken = languageSpoken; }; Human.prototype = Object.create(Mammal.prototype);Human.prototype.constructor = Human;Human.prototype.speak = function() {}; 好: class Animal { constructor(age) { this.age = age; } move() {} } class Mammal extends Animal { constructor(age, furColor) { super(age); this.furColor = furColor; } liveBirth() {} } class Human extends Mammal { constructor(age, furColor, languageSpoken) { super(age, furColor); this.languageSpoken = languageSpoken; } speak() {} } 使用方法链在这里我的意见与《代码整洁之道》的观点不同。有人认为方法链不整洁，而且违反了得墨忒耳定律。也许他们是对的，但这个模式在 JavaScript 中非常有用，你可以很多库中看到，比如 jQuery 和 Lodash。它让代码变得既简洁又有表现力。在类中，只需要在每个函数结束前返回 this，就实现了链式调用的类方法。 不好: class Car { constructor() { this.make = ‘Honda’; this.model = ‘Accord’; this.color = ‘white’; } setMake(make) { this.name = name; } setModel(model) { this.model = model; } setColor(color) { this.color = color; } save() { console.log(this.make, this.model, this.color); }} let car = new Car();car.setColor(‘pink’);car.setMake(‘Ford’);car.setModel(‘F-150’)car.save(); 好: class Car { constructor() { this.make = ‘Honda’; this.model = ‘Accord’; this.color = ‘white’; } setMake(make) { this.name = name; // NOTE: 返回 this 以实现链式调用 return this; } setModel(model) { this.model = model; // NOTE: 返回 this 以实现链式调用 return this; } setColor(color) { this.color = color; // NOTE: 返回 this 以实现链式调用 return this; } save() { console.log(this.make, this.model, this.color); }} let car = new Car() .setColor(‘pink’) .setMake(‘Ford’) .setModel(‘F-150’) .save(); 多用组合，少用继承大家都知道 GoF 的设计模式，其中提到应该多用组合而不是继承。对于继承和组合，都有大量的理由在支撑，但这个准则的要点在于，你的想法本能地会想到继承，但这时候不防多思考一下用组合是否能更好的处理问题——某些时候，的确能。 你可能会考虑：“我什么时候该用继承？”这取决于你遇到的问题。这里有一个不错的清单说明了什么时候用继承比用组合更合适： 你的继承是一个“is-a”关系，而不是“has-a”关系(Animal-&gt;Human 对比 User-&gt;UserDetails)。 可以从基础复用代码 (人可以像所有动物一样移动)。 你想通过修改基础来实现对所有子类的全局性更改。(改变动物移动时的热量消耗)。 不好: class Employee { constructor(name, email) { this.name = name; this.email = email; } // …} // 这样不好，因为 Employees “拥有” 税务数据。EmployeeTaxData 不是属于 Employee 的一个类型class EmployeeTaxData extends Employee { constructor(ssn, salary) { super(); this.ssn = ssn; this.salary = salary; } // …} 好: class Employee { constructor(name, email) { this.name = name; this.email = email; } setTaxData(ssn, salary) { this.taxData = new EmployeeTaxData(ssn, salary); } // …} class EmployeeTaxData { constructor(ssn, salary) { this.ssn = ssn; this.salary = salary; } // …} 测试测试比生产更重要。如果你不进行测试，或者测试的量不够，那你就不能肯定你写的代码不会造成破坏。测试数量依靠你的开发团队来决定，但 100% 覆盖率(所有语句和分支)能让你拥有巨大的信心，也能使程序员们安心。也就是说，你需要一个不错的测试框架，还需要一个好的覆盖检查工具. 没有什么理由可以让你不写测试。这里有 大量不错的 JS 测试框架，可以去找个你们团队喜欢的来用。如果你找一个适合在你的团队中使用的工作，就把为每个新产生的特性/方法添加测试作为目标。如果你喜欢测试驱动开发(TDD)的方法，非常好，但要注意在让你的测试覆盖所有特性，或者重构过的代码。 每次测试一个概念不好: const assert = require(‘assert’); describe(‘MakeMomentJSGreatAgain’, function() { it(‘handles date boundaries’, function() { let date; date = new MakeMomentJSGreatAgain(&apos;1/1/2015&apos;); date.addDays(30); date.shouldEqual(&apos;1/31/2015&apos;); date = new MakeMomentJSGreatAgain(&apos;2/1/2016&apos;); date.addDays(28); assert.equal(&apos;02/29/2016&apos;, date); date = new MakeMomentJSGreatAgain(&apos;2/1/2015&apos;); date.addDays(28); assert.equal(&apos;03/01/2015&apos;, date); });}); 好: const assert = require(‘assert’); describe(‘MakeMomentJSGreatAgain’, function() { it(‘handles 30-day months’, function() { let date = new MakeMomentJSGreatAgain(‘1/1/2015’); date.addDays(30); date.shouldEqual(‘1/31/2015’); }); it(‘handles leap year’, function() { let date = new MakeMomentJSGreatAgain(‘2/1/2016’); date.addDays(28); assert.equal(‘02/29/2016’, date); }); it(‘handles non-leap year’, function() { let date = new MakeMomentJSGreatAgain(‘2/1/2015’); date.addDays(28); assert.equal(‘03/01/2015’, date); });}); 并发使用 Promise 而不是回调回调并不整洁，它会导致过多的嵌套。ES6 的 Promise 是个内置的全局类型。使用它！ 不好: require(‘request’).get(‘https://en.wikipedia.org/wiki/Robert\\_Cecil\\_Martin&#39;, function(err, response) { if (err) { console.error(err); } else { require(‘fs’).writeFile(‘article.html’, response.body, function(err) { if (err) { console.error(err); } else { console.log(‘File written’); } }) }}) 好: require(‘request-promise’).get(‘https://en.wikipedia.org/wiki/Robert\\_Cecil\\_Martin&#39;) .then(function(response) { return require(‘fs-promise’).writeFile(‘article.html’, response); }) .then(function() { console.log(‘File written’); }) .catch(function(err) { console.error(err); }) async/await 比 Promise 还整洁与回调相当，Promise 已经相当整洁了，但 ES7 带来了更整洁的解决方案 —— async 和 await。你要做的事情就是在一个函数前加上 async 关键字，然后写下命令形式的逻辑，而不再需要 then 链。现在可以使用这个 ES7 特性带来的便利！ 不好: require(‘request-promise’).get(‘https://en.wikipedia.org/wiki/Robert\\_Cecil\\_Martin&#39;) .then(function(response) { return require(‘fs-promise’).writeFile(‘article.html’, response); }) .then(function() { console.log(‘File written’); }) .catch(function(err) { console.error(err); }) 好: async function getCleanCodeArticle() { try { var request = await require(‘request-promise’) var response = await request.get(‘https://en.wikipedia.org/wiki/Robert\\_Cecil\\_Martin&#39;); var fileHandle = await require(‘fs-promise’); await fileHandle.writeFile(&apos;article.html&apos;, response); console.log(&apos;File written&apos;); } catch(err) { console.log(err); } } 错误处理抛出错误是件好事！这表示运行时已经成功检测到程序出错了，它停止当前调用框上的函数执行，并中止进程(在 Node 中)，最后在控制台通知你，并输出栈跟踪信息。 不要忽略捕捉到的错误捕捉到错误却什么也不错，你就失去了纠正错误的机会。多数情况下把错误记录到控制台(console.log)也不比忽略它好多少，因为在少量的控制台信息中很难发现这一条。如果尝试在 try/catch 中封装代码，就意味着你知道这里可能发生错，你应该在错误发生的时候有应对的计划、或者处理办法。 不好: try { functionThatMightThrow();} catch (error) { console.log(error);} 好: try { functionThatMightThrow();} catch (error) { // 选择之一(比 console.log 更闹心)： console.error(error); // 另一个选择： notifyUserOfError(error); // 另一个选择： reportErrorToService(error); // 或者所有上述三种选择！} 不要忽视被拒绝的Promise这一条与不要忽略从 try/catch 捕捉到的错误有相同的原因。 不好: getdata().then(data =&gt; { functionThatMightThrow(data);}).catch(error =&gt; { console.log(error);}); 好: getdata().then(data =&gt; { functionThatMightThrow(data);}).catch(error =&gt; { // 选择之一(比 console.log 更闹心)： console.error(error); // 另一个选择： notifyUserOfError(error); // 另一个选择： reportErrorToService(error); // 或者所有上述三种选择！}); 格式格式是个很主观的东西，像这里提到的许多规则一，你不必完全遵循。要点不在于争论格式。大量工具 可以自动处理优化格式。用一个！让工程师争论格式问题简直就是在浪费时间和金钱。 对于那些不能自动处理的格式(可以自动处理的包括缩进、Tab或空格、双引号或单引用等)，就看看这里的指导。 使用一致的大小写JavaScript 是无类型的，所以大小写可以帮助你了解变量、函数等。这些规则具有较强的主观性，所以你的团队应该选择需要的。重点不在于你选择了什么，而在于要始终保持一致。 不好: var DAYS_IN_WEEK = 7;var daysInMonth = 30; var songs = [‘Back In Black’, ‘Stairway to Heaven’, ‘Hey Jude’];var Artists = [‘ACDC’, ‘Led Zeppelin’, ‘The Beatles’]; function eraseDatabase() {}function restore_database() {} class animal {}class Alpaca {} 好: var DAYS_IN_WEEK = 7;var DAYS_IN_MONTH = 30; var songs = [‘Back In Black’, ‘Stairway to Heaven’, ‘Hey Jude’];var artists = [‘ACDC’, ‘Led Zeppelin’, ‘The Beatles’]; function eraseDatabase() {}function restoreDatabase() {} class Animal {}class Alpaca {} 函数调用者和被调用者应该尽可能放在一起如果一个函数调用另一个函数，那应该让他们在源文件中的位置非常接近。理想情况下应该把调用者放在被调用者的正上方，这会让你的代码更易读，因为我们都习惯从上往下读代码，就像读报纸那样。 不好: class PerformanceReview { constructor(employee) { this.employee = employee; } lookupPeers() { return db.lookup(this.employee, ‘peers’); } lookupMananger() { return db.lookup(this.employee, ‘manager’); } getPeerReviews() { let peers = this.lookupPeers(); // … } perfReview() { getPeerReviews(); getManagerReview(); getSelfReview(); } getManagerReview() { let manager = this.lookupManager(); } getSelfReview() { // … }} let review = new PerformanceReview(user);review.perfReview(); 好: class PerformanceReview { constructor(employee) { this.employee = employee; } perfReview() { getPeerReviews(); getManagerReview(); getSelfReview(); } getPeerReviews() { let peers = this.lookupPeers(); // … } lookupPeers() { return db.lookup(this.employee, ‘peers’); } getManagerReview() { let manager = this.lookupManager(); } lookupMananger() { return db.lookup(this.employee, ‘manager’); } getSelfReview() { // … }} let review = new PerformanceReview(employee);review.perfReview(); 注释只注释业务逻辑复杂的内容注释是用来解释代码的，而不是必须的。好的代码应该 自注释。 不好: function hashIt(data) { // Hash 码 var hash = 0; // 字符串长度 var length = data.length; // 遍历数据中所有字符 for (var i = 0; i &lt; length; i++) { // 获取字符编码 var char = data.charCodeAt(i); // 生成 Hash hash = ((hash &lt;&lt; 5) - hash) + char; // 转换为32位整数 hash = hash &amp; hash; }} 好: function hashIt(data) { var hash = 0; var length = data.length; for (var i = 0; i &lt; length; i++) { var char = data.charCodeAt(i); hash = ((hash &lt;&lt; 5) - hash) + char; // 转换为32位整数 hash = hash &amp; hash; }} 不要把注释掉的代码留在代码库中版本控制存在的原因就是保存你的历史代码。 不好: doStuff();// doOtherStuff();// doSomeMoreStuff();// doSoMuchStuff(); 好: doStuff(); 不需要日志式的注释记住，使用版本控制！没用的代码、注释掉的代码，尤其是日志式的注释。用 git log 来获取历史信息！ 不好: /** * 2016-12-20: Removed monads, didn’t understand them (RM) * 2016-10-01: Improved using special monads (JP) * 2016-02-03: Removed type-checking (LI) * 2015-03-14: Added combine with type-checking (JR) */function combine(a, b) { return a + b;} 好: function combine(a, b) { return a + b;} 避免位置标记位置标记通常只会添加垃圾信息。通过对函数或变量名以及适当的缩进就能为代码带来良好的可视化结构。 不好: ////////////////////////////////////////////////////////////////////////////////// Scope Model Instantiation////////////////////////////////////////////////////////////////////////////////let $scope.model = { menu: ‘foo’, nav: ‘bar’}; ////////////////////////////////////////////////////////////////////////////////// Action setup////////////////////////////////////////////////////////////////////////////////let actions = function() { // …} 好: let $scope.model = { menu: ‘foo’, nav: ‘bar’}; let actions = function() { // …} 避免在源文件中添加版权注释这是代码文件树顶层的 LICENSE 文件应该干的事情。 不好: /*The MIT License (MIT) Copyright (c) 2016 Ryan McDermott Permission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the “Software”), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE*/ function calculateBill() { // …} 好: function calculateBill() { // …}","categories":[{"name":"学习资料","slug":"学习资料","permalink":"https://sensitivemix.github.io/categories/学习资料/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://sensitivemix.github.io/tags/Tutorial/"}]},{"title":"HTTP 状态码整理","slug":"HTTP-状态码整理","date":"2018-12-01T06:30:51.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2018/12/01/HTTP-状态码整理/","link":"","permalink":"https://sensitivemix.github.io/2018/12/01/HTTP-状态码整理/","excerpt":"","text":"当我们在浏览网页或是在查看服务器日志时，常会遇到3位数字的状态码，这3位数字是什么意思呢?其实，这3位数字是HTTP状态码，用来表示网页服务器HTTP响应状态，简言之就是Web服务器用来告诉客户端发生了什么事。 1xx：信息 1XX类型的状态码是临时响应，代表着请求已经被接受，但需要继续处理，值得注意的是，由于HTTP/1.0 协议中并没有定义1XX状态码，除非在试验条件下，服务器是禁止向客户端发送1XX响应的。 100 Continue — 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 101 Switching Protocols — 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。 102 Processing — 由WebDAV(RFC 2518)扩展的状态码，代表处理将被继续执行。 2xx：成功 2XX类型的状态码代表着请求已经被服务器接收、理解、并接受 200 OK：请求成功(其后是对GET和POST请求的应答文档。) 201 Created — 请求被创建完成，同时新的资源被创建。 202 Accepted — 供处理的请求已被接受，但是处理未完成。 203 Non-authoritative Information — 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。 204 No Content — 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 205 Reset Content — 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。 206 Partial Content — 客户发送了一个带有Range头的GET请求，服务器完成了它。 207 Multi-Status — 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 3xx: 重定向 3XX这类状态码代表着客户端需要采取进一步的操作才能完成请求，通常，这些状态码是用来重定向的，按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。 300 Multiple Choices — 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。 301 Moved Permanently — 所请求的页面已经转移至新的url。 302 Found — 所请求的页面已经临时转移至新的url。 303 See Other — 所请求的页面可在别的url下被找到。 304 Not Modified — 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求(一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档)。服务器告诉客户，原来缓冲的文档还可以继续使用。 305 Use Proxy — 客户请求的文档应该通过Location头所指明的代理服务器提取。 306 Unused — 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。 307 Temporary Redirect — 被请求的页面已经临时移至新的url。 4xx：客户端错误 4XX类型的状态码代表着客户端可能发生了错误，阻碍了服务器的处理， 400 Bad Request — 服务器未能理解请求或是请求参数有误。 401 Unauthorized — 被请求的页面需要用户名和密码。 402 Payment Required — 此代码尚无法使用(为了将来可能的需求而预留的。) 403 Forbidden — 对被请求页面的访问被禁止。 404 Not Found — 服务器无法找到被请求的页面。 405 Method Not Allowed — 请求中指定的方法不被允许。 406 Not Acceptable — 服务器生成的响应无法被客户端所接受。 407 Proxy Authentication Required — 用户必须首先使用代理服务器进行验证，这样请求才会被处理。 408 Request Timeout — 请求超出了服务器的等待时间。 409 Conflict — 由于冲突，请求无法被完成。 410 Gone — 被请求的页面不可用。 411 Length Required”Content-Length — “ 未被定义。如果无此内容，服务器不会接受请求。 412 Precondition Failed — 请求中的前提条件被服务器评估为失败。 413 Request Entity Too Large — 由于所请求的实体的太大，服务器不会接受请求。 414 Request-url Too Long — 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。 415 Unsupported Media Type — 由于媒介类型不被支持，服务器不会接受请求。 416 — 服务器不能满足客户在请求中指定的Range头。 417 Expectation Failed 5xx： 服务器错误 这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。 500 Internal Server Error — 请求未完成。服务器遇到不可预知的情况。 501 Not Implemented — 请求未完成。服务器不支持所请求的功能。 502 Bad Gateway — 请求未完成。服务器从上游服务器收到一个无效的响应。 503 Service Unavailable — 请求未完成。服务器临时过载或当机。 504 Gateway Timeout — 网关超时。 505 HTTP Version Not Supported — 服务器不支持请求中指明的HTTP协议版本。 http协议响应状态码看起来很多，但若不是需要做AJAX，REST,网络爬虫，机器人等程序，我们只需要了解常见的200、302.304.404、503这几个状态码就好了。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://sensitivemix.github.io/categories/计算机网络/"}],"tags":[{"name":"http","slug":"http","permalink":"https://sensitivemix.github.io/tags/http/"}]},{"title":"彻底搞懂 Javascript 执行机制","slug":"彻底搞懂-Javascript-执行机制","date":"2018-12-01T06:28:09.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2018/12/01/彻底搞懂-Javascript-执行机制/","link":"","permalink":"https://sensitivemix.github.io/2018/12/01/彻底搞懂-Javascript-执行机制/","excerpt":"","text":"这一次，彻底弄懂 JavaScript 执行机制本文的目的就是要保证你彻底弄懂javascript的执行机制，如果读完本文还不懂，可以揍我。 不论你是javascript新手还是老鸟，不论是面试求职，还是日常开发工作，我们经常会遇到这样的情况：给定的几行代码，我们需要知道其输出内容和顺序。因为javascript是一门单线程语言，所以我们可以得出结论： javascript是按照语句出现的顺序执行的 看到这里读者要打人了：我难道不知道js是一行一行执行的？还用你说？稍安勿躁，正因为js是一行一行执行的，所以我们以为js都是这样的： let a = ‘1’;console.log(a); 然而实际上js是这样的： setTimeout(function(){ console.log(‘定时器开始啦’)});new Promise(function(resolve){ console.log(‘马上执行for循环啦’); for(var i = 0; i &lt; 10000; i++){ i == 99 &amp;&amp; resolve(); }}).then(function(){ console.log(‘执行then函数啦’)}); 依照js是按照语句出现的顺序执行这个理念，我自信的写下输出结果： //“定时器开始啦”//“马上执行for循环啦”//“执行then函数啦”//“代码执行结束” 去chrome上验证下，结果完全不对，瞬间懵了，说好的一行一行执行的呢？ 我们真的要彻底弄明白javascript的执行机制了。 1.关于javascriptjavascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！ 2.javascript事件循环既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类： 同步任务 异步任务 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明： 导图要表达的内容用文字来表述的话： 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 说了这么多文字，不如直接一段代码更直白： let data = [];$.ajax({ url:www.javascript.com, data:data, success:() =&gt; { console.log(‘发送成功!’); }})console.log(‘代码执行结束’); 上面是一段简易的ajax请求代码： ajax进入Event Table，注册回调函数success。 执行console.log(&#39;代码执行结束&#39;)。 ajax事件完成，回调函数success进入Event Queue。 主线程从Event Queue读取回调函数success并执行。 相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。 3.又爱又恨的setTimeout大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行： setTimeout(() =&gt; { console.log(‘延时3秒’);},3000) 渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？ 先看一个例子： setTimeout(() =&gt; { task();},3000)console.log(‘执行console’); 根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是： //执行console//task() 去验证一下，结果正确！然后我们修改一下前面的代码： setTimeout(() =&gt; { task()},3000) sleep(10000000) 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。 我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明： //代码1console.log(‘先执行这里’);setTimeout(() =&gt; { console.log(‘执行啦’)},0); //代码2console.log(‘先执行这里’);setTimeout(() =&gt; { console.log(‘执行啦’)},3000); 代码1的输出结果是： //先执行这里//执行啦 代码2的输出结果是： //先执行这里// … 3s later// 执行啦 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。 4.又恨又爱的setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。 唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。 5.Promise与process.nextTick(callback)传统的定时器我们已经研究过了，接着我们探究Promise与process.nextTick(callback)的表现。 Promise的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的Promise。而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。 我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义： macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。 事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明： setTimeout(function() { console.log(‘setTimeout’);}) new Promise(function(resolve) { console.log(‘promise’);}).then(function() { console.log(‘then’);}) console.log(‘console’); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束。 事件循环，宏任务，微任务的关系如图所示： 我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制： console.log(‘1’); setTimeout(function() { console.log(‘2’); process.nextTick(function() { console.log(‘3’); }) new Promise(function(resolve) { console.log(‘4’); resolve(); }).then(function() { console.log(‘5’) })})process.nextTick(function() { console.log(‘6’);})new Promise(function(resolve) { console.log(‘7’); resolve();}).then(function() { console.log(‘8’)}) setTimeout(function() { console.log(‘9’); process.nextTick(function() { console.log(‘10’); }) new Promise(function(resolve) { console.log(‘11’); resolve(); }).then(function() { console.log(‘12’) })}) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 宏任务Event Queue 微任务Event Queue setTimeout1 process1 setTimeout2 then1 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 宏任务Event Queue 微任务Event Queue setTimeout2 process2 then2 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。 输出5。 第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3。 宏任务Event Queue 微任务Event Queue process3 then3 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 6.写在最后(1)js的异步我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。 (2)事件循环Event Loop事件循环是js实现异步的一种方法，也是js的执行机制。 (3)javascript的执行和运行执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。 (4)setImmediate微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。 (5)最后的最后 javascript是一门单线程语言 Event Loop是javascript的执行机制","categories":[{"name":"开发","slug":"开发","permalink":"https://sensitivemix.github.io/categories/开发/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://sensitivemix.github.io/tags/Node-js/"}]},{"title":"浅析 Node.js Event Loop","slug":"浅析-Node-js-Event-Loop","date":"2018-12-01T06:25:29.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2018/12/01/浅析-Node-js-Event-Loop/","link":"","permalink":"https://sensitivemix.github.io/2018/12/01/浅析-Node-js-Event-Loop/","excerpt":"","text":"介绍要了解浏览器的事件循环，我们首先要掌握 javascript 是单线程，所有的任务都是在一条线程上面去执行，只有等上一个任务执行好了才会继续执行下一个任务。然后我们需要了解任务的概念，javaScript 可以分为两种任务，同步任务和异步任务，同步任务会在主线程上面执行，形成一条执行栈。异步任务会在主线程之外的任务队列中执行，每当异步任务支持完成之后，就会在任务队列里面插入一个事件。上面我们说到了任务栈和任务队列，我们需要掌握栈和队列的基本区别，栈是由系统分配内存，栈的特点是先进后出，而队列的特点是先进先出。了解了栈和队列之后，我们需要了解宏任务和微任务，什么是宏任务呢？比如 setTimeout, setInterval,setImmediate 这些都属于宏任务；什么是微任务呢？微任务是指进行系统 I/O 操作的一些事件，比如说 Process.nextTick, Promise.then 这些属于微任务。浏览器是如何运行的呢，首先会执行栈里面的同步代码，比如说正常的变成复制，循环，方法或者类的实例化，然后会优先执行微任务，最后才会执行宏任务。 1234567891011121314setTimeout(function()&#123; console.log(4)&#125;,0);new Promise(function(resolve)&#123; console.log(1) for( var i=0 ; i&lt;10000 ; i++ ) &#123; i==9999 &amp;&amp; resolve() &#125; console.log(2)&#125;).then(function()&#123; console.log(5)&#125;);console.log(3); 1,2,3,5,4 Node.js 中的 Event loop我们写的 Javascript 代码首先交给 V8 引擎去处理代码中调用 Node APINode 会交给 Libuv 去处理，通过阻塞 I/O和多线程实现了异步 I/O通过事件驱动的形式放置在事件队列中去，最终交付给我们的应用执行顺序如下：首先会执行主线程中的同步任务，然后寻找是否存在微任务，如果存在则执行微任务，不存在则寻找 timers 中的宏任务放入至事件队列，如果后面存在微任务不执行，继续寻找是否存在宏任务，一次全部执行完宏任务之后，然后再执行微任务。","categories":[{"name":"开发","slug":"开发","permalink":"https://sensitivemix.github.io/categories/开发/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://sensitivemix.github.io/tags/Node-js/"}]},{"title":"InfluxDB 学习指南","slug":"InfluxDB-学习指南","date":"2018-12-01T06:23:15.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2018/12/01/InfluxDB-学习指南/","link":"","permalink":"https://sensitivemix.github.io/2018/12/01/InfluxDB-学习指南/","excerpt":"","text":"前言 influxdb是目前比较流行的时间序列数据库。 何谓时间序列数据库？什么是时间序列数据库，最简单的定义就是数据格式里包含Timestamp字段的数据，比如某一时间环境的温度，CPU的使用率等。但是，有什么数据不包含Timestamp呢？几乎所有的数据其实都可以打上一个Timestamp字段。时间序列数据的更重要的一个属性是如何去查询它，包括数据的过滤，计算等等。 InfluxdbInfluxdb是一个开源的分布式时序、时间和指标数据库，使用go语言编写，无需外部依赖。它有三大特性： 时序性（Time Series）：与时间相关的函数的灵活使用（诸如最大、最小、求和等）； 度量（Metrics）：对实时大量数据进行计算； 事件（Event）：支持任意的事件数据，换句话说，任意事件的数据我们都可以做操作。 同时，它有以下几大特点： schemaless(无结构)，可以是任意数量的列； min, max, sum, count, mean, median 一系列函数，方便统计； Native HTTP API, 内置http支持，使用http读写； Powerful Query Language 类似sql； Built-in Explorer 自带管理工具。 Influxdb安装 注：本文使用的influxdb version是1.0.2 在讲解具体的安装步骤之前，先说说influxdb的两个http端口：8083和8086 port 8083：管理页面端口，访问localhost:8083可以进入你本机的influxdb管理页面； port 8086：http连接influxdb client端口，一般使用该端口往本机的influxdb读写数据。 OS X 12brew updatebrew install influxdb Docker Image 1docker pull influxdb Ubuntu &amp; Debian 12wget https://dl.influxdata.com/influxdb/releases/influxdb_1.0.2_amd64.debsudo dpkg -i influxdb_1.0.2_amd64.deb RedHat &amp; CentOS 12wget https://dl.influxdata.com/influxdb/releases/influxdb-1.0.2.x86_64.rpmsudo yum localinstall influxdb-1.0.2.x86_64.rpm Standalone Linux Binaries (64-bit) 12wget https://dl.influxdata.com/influxdb/releases/influxdb-1.0.2_linux_amd64.tar.gz tar xvfz influxdb-1.0.2_linux_amd64.tar.gz Standalone Linux Binaries (32-bit) 12wget https://dl.influxdata.com/influxdb/releases/influxdb-1.0.2_linux_i386.tar.gztar xvfz influxdb-1.0.2_linux_i386.tar.gz Standalone Linux Binaries (ARM) 12wget https://dl.influxdata.com/influxdb/releases/influxdb-1.0.2_linux_armhf.tar.gztar xvfz influxdb-1.0.2_linux_armhf.tar.gz How to start？安装完之后，如何启动呢？ 1sudo service influxdb start 1brew services start influxdb (OSX 启动 influxdb) 1brew services stop influxdb (OSX 关闭 influxdb) 到这里influxdb安装启动完成，可以访问influxdb管理页面：本地管理页面，该版本没有登录用户及密码，可以自行设置读写的用户名和密码。 如何在命令行使用安装完毕之后，如何在命令行使用呢？ influxdb在命令行中使用 influxdb基本操作 名词解释在具体的讲解influxdb的相关操作之前先说说influxdb的一些专有名词，这些名词代表什么。 influxdb相关名词 database：数据库； measurement：数据库中的表； points：表里面的一行数据。 influxDB中独有的一些概念Point由时间戳（time）、数据（field）和标签（tags）组成。 time：每条数据记录的时间，也是数据库自动生成的主索引； fields：各种记录的值； tags：各种有索引的属性。 还有一个重要的名词：series所有在数据库中的数据，都需要通过图表来表示，series表示这个表里面的所有的数据可以在图标上画成几条线（注：线条的个数由tags排列组合计算出来）举个简单的小栗子：有如下数据： error_time 它的series为： error_time_series influxdb基本操作 数据库与表的操作可以直接在web管理页面做操作，当然也可以命令行。 1234567891011121314#创建数据库create database &quot;db_name&quot;#显示所有的数据库show databases#删除数据库drop database &quot;db_name&quot;#使用数据库use db_name#显示该数据库中所有的表show measurements#创建表，直接在插入数据的时候指定表名insert test,host=127.0.0.1,monitor_name=test count=1#删除表drop measurement &quot;measurement_name&quot; 增向数据库中插入数据。 通过命令行 12use testDbinsert test,host=127.0.0.1,monitor_name=test count=1 通过http接口 1curl -i -XPOST &apos;http://127.0.0.1:8086/write?db=testDb&apos; --data-binary &apos;test,host=127.0.0.1,monitor_name=test count=1&apos; 读者看到这里可能会观察到插入的数据的格式貌似比较奇怪，这是因为influxDB存储数据采用的是Line Protocol格式。那么何谓Line Protoco格式？ Line Protocol格式：写入数据库的Point的固定格式。在上面的两种插入数据的方法中都有这样的一部分： 1test,host=127.0.0.1,monitor_name=test count=1 其中： test：表名； host=127.0.0.1,monitor_name=test：tag； count=1：field 想对此格式有详细的了解参见官方文档 查查询数据库中的数据。 通过命令行 1select * from test order by time desc 通过http接口 1curl -G &apos;http://localhost:8086/query?pretty=true&apos; --data-urlencode &quot;db=testDb&quot; --data-urlencode &quot;q=select * from test order by time desc&quot; influxDB是支持类sql语句的，具体的查询语法都差不多，这里就不再做详细的赘述了。 数据保存策略（Retention Policies）influxDB是没有提供直接删除数据记录的方法，但是提供数据保存策略，主要用于指定数据保留时间，超过指定时间，就删除这部分数据。 查看当前数据库Retention Policies 1show retention policies on &quot;db_name&quot; ![](http://upload-images.jianshu.io/upload_images/3994601-4dbf9942cc0f671a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) retention_policies * 创建新的Retention Policies 1create retention policy &quot;rp_name&quot; on &quot;db_name&quot; duration 3w replication 1 default * rp_name：策略名； * db_name：具体的数据库名； * 3w：保存3周，3周之前的数据将被删除，influxdb具有各种事件参数，比如：h（小时），d（天），w（星期）； * replication 1：副本个数，一般为1就可以了； * default：设置为默认策略 * 修改Retention Policies 1alter retention policy &quot;rp_name&quot; on &quot;db_name&quot; duration 30d default * 删除Retention Policies 1drop retention policy &quot;rp_name&quot; 连续查询（Continous Queries）当数据超过保存策略里指定的时间之后就会被删除，但是这时候可能并不想数据被完全删掉，怎么办？influxdb提供了联系查询，可以做数据统计采样。 查看数据库的Continous Queries 1show continuous queries ![](http://upload-images.jianshu.io/upload_images/3994601-d0d2b55ee261869d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) continuous_queries. * 创建新的Continous Queries 1create continous query cq_name on db_name begin select sum(count) into new_table_name from table_name group by time(30m) end * cq_name：连续查询名字； * db_name：数据库名字； * sum(count)：计算总和； * table_name：当前表名； * new_table_name：存新的数据的表名； * 30m：时间间隔为30分钟 * 删除Continous Queries 1drop continous query cp_name on db_name 用户管理可以直接在web管理页面做操作，也可以命令行。 1234567#显示用户 show users#创建用户create user &quot;username&quot; with password &apos;password&apos;#创建管理员权限用户create user &quot;username&quot; with password &apos;password&apos; with all privileges#删除用户drop user &quot;username&quot;","categories":[{"name":"开发","slug":"开发","permalink":"https://sensitivemix.github.io/categories/开发/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://sensitivemix.github.io/tags/Database/"},{"name":"InfluxDB","slug":"InfluxDB","permalink":"https://sensitivemix.github.io/tags/InfluxDB/"}]},{"title":"mongoDB 执行计划分析","slug":"mongoDB-执行计划分析","date":"2018-11-27T15:31:32.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2018/11/27/mongoDB-执行计划分析/","link":"","permalink":"https://sensitivemix.github.io/2018/11/27/mongoDB-执行计划分析/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"客户端如何快捷过滤 API 响应","slug":"客户端如何快捷过滤-API-响应","date":"2018-11-09T07:10:57.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2018/11/09/客户端如何快捷过滤-API-响应/","link":"","permalink":"https://sensitivemix.github.io/2018/11/09/客户端如何快捷过滤-API-响应/","excerpt":"","text":"为什么要过滤 需求变更频繁，API 无法每次都根据需求更新 适应多端，各端需要的响应返回都不一样，不可能为每个端定制 API 返回 优化 API 响应时间，避免不必要的 Format 查询操作 复杂冗余的 API 响应 获取客户列表：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&#123; &quot;extra&quot;:&#123; &quot;orgCounts&quot;:1, &quot;showHidden&quot;:true &#125;, &quot;organizations&quot;:[ &#123; &quot;_id&quot;:&quot;5be51350f93a32ade0e2e257&quot;, &quot;updateTime&quot;:&quot;2018-11-09T04:55:45.203Z&quot;, &quot;name&quot;:&quot;蜀国&quot;, &quot;_workspaceId&quot;:&quot;5bd87ecba00f2b0001921b27&quot;, &quot;fields&quot;:[ ], &quot;undoneActivities&quot;:0, &quot;doneActivities&quot;:0, &quot;totalActivities&quot;:0, &quot;nextActivityDate&quot;:null, &quot;lastActivityDate&quot;:null, &quot;isPublic&quot;:false, &quot;isArchive&quot;:false, &quot;lostDeals&quot;:0, &quot;wonDeals&quot;:0, &quot;closedDeals&quot;:0, &quot;openDeals&quot;:0, &quot;numberOfEmployees&quot;:&quot;&quot;, &quot;quality&quot;:null, &quot;status&quot;:&#123; &quot;_fixedFieldId&quot;:&quot;5bd87ed761c2bf77fde85a2c&quot;, &quot;value&quot;:&quot;5bd87ed7d2e7854a5278b24a&quot;, &quot;choices&quot;:[ &#123; &quot;pos&quot;:65536, &quot;value&quot;:&quot;试用&quot;, &quot;_id&quot;:&quot;5bd87ed7d2e7854a5278b24a&quot; &#125;, &#123; &quot;pos&quot;:131072, &quot;value&quot;:&quot;Onboarding&quot;, &quot;_id&quot;:&quot;5bd87ed7d2e7854a5278b249&quot; &#125;, &#123; &quot;pos&quot;:196608, &quot;value&quot;:&quot;Retention&quot;, &quot;_id&quot;:&quot;5bd87ed7d2e7854a5278b248&quot; &#125;, &#123; &quot;pos&quot;:262144, &quot;value&quot;:&quot;Renew&quot;, &quot;_id&quot;:&quot;5bd87ed7d2e7854a5278b247&quot; &#125;, &#123; &quot;pos&quot;:327680, &quot;value&quot;:&quot;流失&quot;, &quot;_id&quot;:&quot;5bd87ed7d2e7854a5278b246&quot; &#125; ] &#125;, &quot;area&quot;:&quot;&quot;, &quot;city&quot;:&quot;&quot;, &quot;avatarUrl&quot;:&quot;http://tcs.project.ci/thumbnail/010x5741bc1bce56f84c34f4b9855ce079b3/w/200/h/200&quot;, &quot;province&quot;:&quot;&quot;, &quot;industry&quot;:&quot;&quot;, &quot;country&quot;:&quot;&quot;, &quot;address&quot;:&quot;&quot;, &quot;allocateTime&quot;:&quot;2018-11-09T04:55:44.674Z&quot;, &quot;updateNoteTime&quot;:null, &quot;createdTime&quot;:&quot;2018-11-09T04:55:44.674Z&quot;, &quot;people&quot;:0, &quot;note&quot;:&quot;&quot;, &quot;products&quot;:[ ], &quot;creator&quot;:&#123; &quot;_id&quot;:&quot;599e33ce7c814524278308c2&quot;, &quot;name&quot;:&quot;jack&quot; &#125;, &quot;owner&quot;:&#123; &quot;_id&quot;:&quot;599e33ce7c814524278308c2&quot;, &quot;name&quot;:&quot;jack&quot; &#125;, &quot;__v&quot;:0 &#125; ]&#125; 如何自定义 API 响应Field-Masks (字段掩码) 使用字段掩码进行读取| 例子 | 影响 ||:—-|| items | 返回items数组中的所有元素，包括每个元素中的所有字段，但不包含其他字段。 || etag,items | 返回etagitems数组中的字段和所有元素。 || items/title | 仅返回titleitems数组中所有元素的字段。每当返回嵌套字段时，响应都包含封闭的父对象。除非明确选择父字段，否则父字段不包括任何其他子字段。 || context/facets/label | 仅返回数组的label所有成员的字段，该facets数组本身嵌套在context对象下。 || items/pagemap/*/title | 对于items数组中的每个元素，仅返回作为子项title的所有对象的字段（如果存在）pagemap。 | 使用字段掩码进行更新1POST https://slides.googleapis.com/v1/presentations/presentationId:batchUpdate 12345678910111213141516171819&#123; &quot;requests&quot;: [ &#123; &quot;updateShapeProperties&quot;: &#123; &quot;objectId&quot;: elementId, &quot;shapeProperties&quot;: &#123; &quot;shapeBackgroundFill&quot;: &#123; &quot;solidFill&quot;: &#123; &quot;color&quot;: &#123; &quot;themeColor&quot;: &quot;DARK1&quot; &#125; &#125; &#125; &#125;, &quot;fields&quot;: &quot;shapeBackgroundFill.solidFill.color,outline&quot; &#125; &#125; ]&#125; 如何应用中至项目 基础轮子：JSON-MASK KOA2.X: koa-json-mask KOA1.X: koa1-json-mask","categories":[{"name":"开发","slug":"开发","permalink":"https://sensitivemix.github.io/categories/开发/"}],"tags":[{"name":"Frontend","slug":"Frontend","permalink":"https://sensitivemix.github.io/tags/Frontend/"}]},{"title":"Node.js 应用最佳实践","slug":"Node-js-应用最佳实践","date":"2018-09-03T07:01:29.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2018/09/03/Node-js-应用最佳实践/","link":"","permalink":"https://sensitivemix.github.io/2018/09/03/Node-js-应用最佳实践/","excerpt":"","text":"基于 Express 实践，Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。 项目结构实践1.1 组件式构建你的解决方案 (The Future)定义：大型项目的最坏的隐患就是维护一个庞大的，含有几百个依赖的代码库 - 当开发人员准备整合新的需求的时候，这样一个庞然大物势必减缓了开发效率。反之，把您的代码拆分成组件，每一个组件有它自己的文件夹和代码库，并且确保每一个组件小而简单。 否则: 当编写新需求的开发人员逐步意识到他所做改变的影响，并担心会破坏其他的依赖模块 - 部署会变得更慢，风险更大。当所有业务逻辑没有被分开，这也会被认为很难扩展 1.1.1 Bad: Group your files by technical role 1.1.2 Good: Structure your solution by self-contained components 1.2 分层设计组件，保持项目结构在特定的区域定义: 每一个组件都应该包含「层级」 - 一个专注的用于接入网络，逻辑，数据的概念。这样不仅获得一个清晰的分离考量，而且使仿真（mock-server）和测试系统变得异常容易。尽管这是一个普通的模式，但接口开发者易于混淆层级关系，比如把网络层的对象（req, res）传给业务逻辑和数据层 - 这会令您的应用彼此依赖，并且只能通过Express使用。 否则: 对于混淆了网络层和其它层的应用，将不易于测试，执行 CRON 的任务，其它非-Express 的调用者无法使用 对比逻辑分层重要性 1.3 封装公共模块成为NPM的包定义: 由大量代码构成的一个大型应用中，贯彻全局的，比如日志，加密和其它类似的公共组件，应该进行封装，并暴露成一个私有的NPM包。这将使其在更多的代码库和项目中被使用变成了可能。 否则: 您将不得不重造部署和依赖的轮子 在环境和组件中共享你自己的公用实用工具 1.4 分离 Express ‘app’ and ‘server’定义: 避免定义整个 Express 应用在一个单独的大文件里， 这是一个不好的习惯 - 分离您的 「Express」 定义至少在两个文件中： API声明(app.js) 和 网络相关(WWW)。对于更好的结构，是把你的API声明放在组件中。 否则: 您的 API 将只能通过 HTTP 的调用进行测试（慢，并且很难产生测试覆盖报告）。维护一个有着上百行代码的文件也不是一个令人开心的事情。 一段解释最新的 Express 生成器有一个值得保留的伟大实践–API声明与网络相关配置（端口、协议等）是分开的。这样就可以在不执行网络调用的情况下对API进行在线测试，它所带来的好处是：快速执行测试操作和获取代码覆盖率。它还允许在灵活多样的网络条件下部署相同的API。额外好处：更好的关注点分离和更清晰的代码结构。 代码示例：API声明应该在 app.js 文件里面1234var app = express();app.use(bodyParser.json());app.use(&quot;/api/events&quot;, events.API);app.use(&quot;/api/forms&quot;, forms); ### 代码示例: 服务器网络声明，应该在 /bin/www 文件里面123456789101112131415var app = require(&apos;../app&apos;);var http = require(&apos;http&apos;);/** * Get port from environment and store in Express. */var port = normalizePort(process.env.PORT || &apos;3000&apos;);app.set(&apos;port&apos;, port);/** * Create HTTP server. */var server = http.createServer(app); ### 示例代码: 使用超快的流行的测试包在线测试你的代码1234567891011121314const app = express();app.get(&apos;/user&apos;, function(req, res) &#123; res.status(200).json(&#123; name: &apos;tobi&apos; &#125;);&#125;);request(app) .get(&apos;/user&apos;) .expect(&apos;Content-Type&apos;, /json/) .expect(&apos;Content-Length&apos;, &apos;15&apos;) .expect(200) .end(function(err, res) &#123; if (err) throw err; &#125;); 1.5 使用易于设置环境变量，安全和分级的配置定义: 一个完美无瑕的配置安装应该确保 (a) 元素可以从文件中，也可以从环境变量中读取 (b) 密码排除在提交的代码之外 (c) 为了易于检索，配置是分级的。仅有几个包可以满足这样的条件，比如rc, nconf 和 config。 否则: 不能满足任意的配置要求将会使开发，运维团队，或者两者，易于陷入泥潭。 一段解释当我们处理配置参数时，常常会很慢并且很烦躁：（1）当需要注入100个keys(而不是只在配置文件中提交它们)时，使用进程环境变量设置所有的keys变得非常繁琐，但是当处理只有devops管理权限的文件时，不改变代码行为就不不会变。一个可靠的配置解决方案必须结合配置文件和进程变量覆盖。 （2）枚举一个普通JSON的所有keys时，当目录变得非常庞杂的时候，查找修改条目困难。几乎没有配置库允许将配置存储在多个文件中，运行时将所有文件联合起来。分成几个部分的分层JSON文件能够克服这个问题。请参照下面示例。 （3）不推荐存储像密码数据这样的敏感信息，但是又没有快速便捷的方法解决这个难题。一些配置库允许文件加密，其他库在Git提交时加密目录，或者不存储这些目录的真实值，在通过环境变量部署期间枚举真实值。 （4）一些高级配置场景需要通过命令行（vargs）注入配置值，或者像Redis一样通过集中缓存同步配置信息，所以不同的服务器不会保存不同的数据。一些配置库可以免费提供这些功能的大部分功能，请查看NPM库（nconf 和 config）这些库可以满足这些要求中的许多要求。 代码示例 – 分层配置有助于查找条目和维护庞大的配置文件123456789101112131415&#123; // Customer module configs &quot;Customer&quot;: &#123; &quot;dbConfig&quot;: &#123; &quot;host&quot;: &quot;localhost&quot;, &quot;port&quot;: 5984, &quot;dbName&quot;: &quot;customers&quot; &#125;, &quot;credit&quot;: &#123; &quot;initialLimit&quot;: 100, // Set low for development &quot;initialDays&quot;: 1 &#125; &#125;&#125; 异常处理实践2.1 使用 Async-Await 和 promises 用于异步错误处理定义: 使用回调的方式处理异步错误可能是导致灾难的最快的方式(a.k.a the pyramid of doom)。对您的代码来说，最好的礼物就是使用规范的 promise 库、 async-await 来替代，这会使其像 try-catch 一样更加简洁，具有熟悉的代码结构。 否则: Node.js回调特性, function(err, response), 是导致不可维护代码的一个必然的方式。究其原因，是由于混合了随意的错误处理代码，臃肿的内嵌，蹩脚的代码模式。 代码示例 – 使用promise捕获错误123456doWork() .then(doWork) .then(doOtherWork) .then((result) =&gt; doWork) .catch((error) =&gt; &#123;throw error;&#125;) .then(verify); ### 代码示例 反模式 – 回调方式的错误处理123456789101112getData(someParameter, function(err, result)&#123; if(err != null) //做一些事情类似于调用给定的回调函数并传递错误 getMoreData(a, function(err, result)&#123; if(err != null) //做一些事情类似于调用给定的回调函数并传递错误 getMoreData(b, function(c)&#123; getMoreData(d, function(e)&#123; if(err != null) //你有什么想法?  &#125;);&#125;); 2.2 仅使用内建的错误对象定义: 很多人抛出异常使用字符串类型或一些自定义类型 - 这会导致错误处理逻辑和模块间的调用复杂化。是否您reject一个promise，抛出异常或发出(emit)错误 - 使用内建的错误对象将会增加设计一致性，并防止信息的丢失。 否则: 调用某些模块，将不确定哪种错误类型会返回 - 这将会使恰当的错误处理更加困难。更坏的情况是，使用特定的类型描述错误，会导致重要的错误信息缺失，比如 stack trace！ 代码示例 – 正确处理它12345678910111213//从典型函数抛出错误, 无论是同步还是异步 if(!productToAdd) throw new Error(&quot;How can I add new product when no value provided?&quot;); //从EventEmitter抛出错误const myEmitter = new MyEmitter();myEmitter.emit(&apos;error&apos;, new Error(&apos;whoops!&apos;)); //从promise抛出错误 return new promise(function (resolve, reject) &#123; Return DAL.getProduct(productToAdd.id).then((existingProduct) =&gt; &#123; if(existingProduct != null) reject(new Error(&quot;Why fooling us and trying to add an existing product?&quot;)); ### 代码示例 – 反模式123//抛出字符串错误缺少任何stack trace信息和其他重要属性if(!productToAdd) throw (&quot;How can I add new product when no value provided?&quot;); ### 代码示例 – 更好处理它123456789101112131415//从node错误派生的集中错误对象function appError(name, httpCode, description, isOperational) &#123; Error.call(this); Error.captureStackTrace(this); this.name = name; //...在这赋值其它属性&#125;;appError.prototype.__proto__ = Error.prototype;module.exports.appError = appError; //客户端抛出一个错误if(user == null) throw new appError(commonErrors.resourceNotFound, commonHTTPErrors.notFound, &quot;further explanation&quot;, true) 2.3 区分运行错误和程序设计错误定义: 运行错误（例如, API接受到一个无效的输入）指的是一些已知场景下的错误，这类错误的影响已经完全被理解，并能被考虑周全的处理掉。同时，程序设计错误（例如，尝试读取未定义的变量）指的是未知的编码问题，影响到应用得当的重启。 否则: 当一个错误产生的时候，您总是得重启应用，但为什么要让 ~5000 个在线用户不能访问，仅仅是因为一个细微的，可以预测的，运行时错误？相反的方案，也不完美 – 当未知的问题（程序问题）产生的时候，使应用依旧可以访问，可能导致不可预测行为。区分两者会使处理更有技巧，并在给定的上下文下给出一个平衡的对策。 一段解释区分以下两种错误类型将最大限度地减少应用程序停机时间并帮助避免出现荒唐的错误: 操作型错误指的是您了解发生了什么情况及其影响的情形 – 例如, 由于连接问题而导致对某些 HTTP 服务的查询失败问题。另一方面, 程序型错误指的是您不知道原因, 有时是错误不知道来自何处的情况 – 可能是一些代码试图读取未定义的值或 DB 连接池内存泄漏。操作型错误相对容易处理 – 通常记录错误就足够了。当程序型错误出现，事情变得难以应付, 应用程序可能处于不一致状态, 你可以做的，没有什么比优雅的重新启动更好了。 代码示例 – 将错误标记为可操作 (受信任)1234567891011121314//将错误标记为可操作 var myError = new Error(&quot;How can I add new product when no value provided?&quot;);myError.isOperational = true; //或者, 如果您使用的是一些集中式错误工厂 (请参见项目符号中的示例&quot;仅使用内置错误对象&quot;)function appError(commonType, description, isOperational) &#123; Error.call(this); Error.captureStackTrace(this); this.commonType = commonType; this.description = description; this.isOperational = isOperational;&#125;; throw new appError(errorManagement.commonErrors.InvalidInput, &quot;Describe here what happened&quot;, true); ## 2.4 集中处理错误，不要在 Express 中间件中处理错误定义: 错误处理逻辑，比如给管理员发送邮件，日志应该封装在一个特定的，集中的对象当中，这样当错误产生的时候，所有的终端（例如 Express中间件，cron 任务，单元测试）都可以调用。 否则: 错误处理的逻辑不放在一起将会导致代码重复和非常可能不恰当的错误处理。 一段解释如果没有一个专用的错误处理对象，那么由于操作不当，在雷达下重要错误被隐藏的可能性就会更大。错误处理对象负责使错误可见，例如通过写入一个格式化良好的logger，通过电子邮件将事件发送到某个监控产品或管理员。一个典型的错误处理流程可能是：一些模块抛出一个错误 -&gt; API路由器捕获错误 -&gt; 它传播错误给负责捕获错误的中间件（如Express，KOA）-&gt; 集中式错误处理程序被调用 -&gt; 中间件正在被告之这个错误是否是一个不可信的错误（不是操作型错误），这样可以优雅的重新启动应用程序。注意，在Express中间件中处理错误是一种常见但又错误的做法，这样做不会覆盖在非Web接口中抛出的错误。 代码示例 – 一个典型错误流12345678910111213141516171819202122232425//DAL层, 在这里我们不处理错误DB.addDocument(newCustomer, (error, result) =&gt; &#123; if (error) throw new Error(&quot;Great error explanation comes here&quot;, other useful parameters)&#125;); //API路由代码, 我们同时捕获异步和同步错误，并转到中间件try &#123; customerService.addNew(req.body).then(function (result) &#123; res.status(200).json(result); &#125;).catch((error) =&gt; &#123; next(error) &#125;);&#125;catch (error) &#123; next(error);&#125; //错误处理中间件，我们委托集中式错误处理程序处理错误app.use(function (err, req, res, next) &#123; errorHandler.handleError(err).then((isOperationalError) =&gt; &#123; if (!isOperationalError) next(err); &#125;);&#125;); ### 代码示例 – 在一个专门的对象里面处理错误123456module.exports.handler = new errorHandler(); function errorHandler()&#123; this.handleError = function (error) &#123; return logger.logError(err).then(sendMailToAdminIfCritical).then(saveInOpsQueueIfCritical).then(determineIfOperationalError); &#125; 2.5 对API错误使用Swagger文档化定义: 让你的API调用者知道哪种错误会返回，这样他们就能完全的处理这些错误，而不至于系统崩溃。Swagger，REST API的文档框架，通常处理这类问题。 否则: 任何API的客户端可能决定崩溃并重启，仅仅因为它收到一个不能处理的错误。注意：API的调用者可能是你（在微服务环境中非常典型）。 2.6 当一个特殊的情况产生，停掉服务是得体的定义: 当一个不确定错误产生（一个开发错误，最佳实践条款#3) - 这就意味着对应用运转健全的不确定。一个普通的实践将是建议仔细地重启进程，并使用一些‘启动器’工具，比如Forever和PM2。 否则: 当一个未知的异常被抛出，意味着某些对象包含错误的状态（例如某个全局事件发生器由于某些内在的错误，不在产生事件），未来的请求可能失败或者行为异常。 代码实例: 决定是否退出1234567891011121314151617181920//收到未捕获的异常时，决定是否要崩溃//如果开发人员标记已知的操作型错误使用：error.isOperational=trueprocess.on(&apos;uncaughtException&apos;, function(error) &#123; errorManagement.handler.handleError(error); if(!errorManagement.handler.isTrustedError(error)) process.exit(1)&#125;); //封装错误处理相关逻辑在集中的错误处理中function errorHandler()&#123; this.handleError = function (error) &#123; return logger.logError(err).then(sendMailToAdminIfCritical).then(saveInOpsQueueIfCritical).then(determineIfOperationalError); &#125; this.isTrustedError = function(error) &#123; return error.isOperational; &#125; 2.7 使用一个成熟的日志工具提高错误的可见性定义: 一系列成熟的日志工具，比如Winston，Bunyan和Log4J，会加速错误的发现和理解。忘记console.log吧。 否则: 浏览console的log，和不通过查询工具或者一个好的日志查看器，手动浏览繁琐的文本文件，会使你忙于工作到很晚。 代码示例 – 使用Winston Logger1234567891011//您的集中式logger对象var logger = new winston.Logger(&#123; level: &apos;info&apos;, transports: [ new (winston.transports.Console)(), new (winston.transports.File)(&#123; filename: &apos;somefile.log&apos; &#125;) ]&#125;);//在某个地方使用logger的自定义代码logger.log(&apos;info&apos;, &apos;Test Log Message with some parameter %s&apos;, &apos;some parameter&apos;, &#123; anything: &apos;This is metadata&apos; &#125;); ### 代码示例 – 查询日志文件夹 (搜索条目)1234567891011121314var options = &#123; from: new Date - 24 * 60 * 60 * 1000, until: new Date, limit: 10, start: 0, order: &apos;desc&apos;, fields: [&apos;message&apos;] &#125;; // 查找在今天和昨天之间记录的项目 winston.query(options, function (err, results) &#123; //对于结果的回调处理 &#125;); 2.8 使用你最喜欢的测试框架测试错误流定义: 无论专业的自动化测试或者简单的手动开发测试 - 确保您的代码不仅满足正常的场景，而且处理并且返回正确的错误。测试框架，比如Mocha &amp; Chai可以非常容易的处理这些问题（在”Gist popup”中查看代码实例）。 否则: 没有测试，不管自动还是手动，您不可能依赖代码去返回正确的错误。而没有可以理解的错误，那将毫无错误处理可言。 代码示例: 使用 Mocha &amp; Chai 确保正确的异常被抛出1234567describe(&quot;Facebook chat&quot;, () =&gt; &#123; it(&quot;Notifies on new chat message&quot;, () =&gt; &#123; var chatService = new chatService(); chatService.participants = getDisconnectedParticipants(); expect(chatService.sendMessage.bind(&#123;message: &quot;Hi&quot;&#125;)).to.throw(ConnectionError); &#125;);&#125;); ### 代码示例: 确保 API 返回正确的 HTTP 错误码12345678910it(&quot;Creates new Facebook group&quot;, function (done) &#123; var invalidGroupInfo = &#123;&#125;; httpRequest(&#123;method: &apos;POST&apos;, uri: &quot;facebook.com/api/groups&quot;, resolveWithFullResponse: true, body: invalidGroupInfo, json: true &#125;).then((response) =&gt; &#123; //oh no if we reached here than no exception was thrown &#125;).catch(function (response) &#123; expect(400).to.equal(response.statusCode); done(); &#125;); &#125;); 2.9 捕获未处理的promise rejections定义: 任何在promise中被抛出的异常将被收回和遗弃，除非开发者没有忘记去明确的处理。即使您的代码调用的是process.uncaughtException！解决这个问题可以注册到事件process.unhandledRejection。 否则: 您的错误将被回收，无踪迹可循。没有什么可以需要考虑。 代码示例: 这些错误将不会得到任何错误处理程序捕获（除unhandledrejection）123456DAL.getUserById(1).then((johnSnow) =&gt;&#123; //this error will just vanish if(johnSnow.isAlive == false) throw new Error(&apos;ahhhh&apos;);&#125;); 代码示例: 捕获 unresolved 和 rejected 的 promise12345678910process.on(&apos;unhandledRejection&apos;, (reason, p) =&gt; &#123; //我刚刚捕获了一个未处理的promise rejection, 因为我们已经有了对于未处理错误的后备的处理机制（见下面）, 直接抛出，让它来处理 throw reason;&#125;);process.on(&apos;uncaughtException&apos;, (error) =&gt; &#123; //我刚收到一个从未被处理的错误，现在处理它，并决定是否需要重启应用 errorManagement.handler.handleError(error); if (!errorManagement.handler.isTrustedError(error)) process.exit(1);&#125;); 2.10 快速查错，验证参数使用一个专门的库Fail fast, validate arguments using a dedicated library定义: 这应该是您的Express最佳实践中的一部分 – assert API输入避免难以理解的漏洞，这类漏洞以后会非常难以追踪。而验证代码通常是一件乏味的事情，除非使用一些非常炫酷的帮助库比如Joi。 否则: 考虑这种情况 – 您的功能期望一个数字参数 “Discount” ，然而调用者忘记传值，之后在您的代码中检查是否 Discount!=0 （允许的折扣值大于零），这样它将允许用户使用一个折扣。OMG，多么不爽的一个漏洞。你能明白吗？ 代码示例: 使用‘Joi’验证复杂的JSON输入123456789101112var memberSchema = Joi.object().keys(&#123; password: Joi.string().regex(/^[a-zA-Z0-9]&#123;3,30&#125;$/), birthyear: Joi.number().integer().min(1900).max(2013), email: Joi.string().email()&#125;); function addNewMember(newMember)&#123; //assertions come first Joi.assert(newMember, memberSchema); //throws if validation fails //other logic here&#125; ### 反模式: 没有验证会产生令人讨厌的错误123456789//假如折扣为正，重定向用户去打印他的折扣优惠劵function redirectToPrintDiscount(httpResponse, member, discount)&#123; if(discount != 0) httpResponse.redirect(`/discountPrintView/$&#123;member.id&#125;`);&#125; redirectToPrintDiscount(httpResponse, someMember);//忘记传递参数discount, 为什么用户被重定向到折扣页面？ 编码规范实践3.1 使用一款风格管理工具定义: ESLint，Standard 是检查可能的代码错误和修复代码样式的事实上的标准，不仅可以识别实际的间距问题, 而且还可以检测严重的反模式代码, 如开发人员在不分类的情况下抛出错误。尽管ESlint可以自动修复代码样式，但其他的工具比如 prettier 和 beautify在格式化修复上功能强大，可以和Eslint结合起来使用。 否则: 开发人员将必须关注单调乏味的间距和线宽问题, 并且时间可能会浪费在过多考虑项目的代码样式。 3.2 变量、常量、函数和类的命名约定定义: 当命名变量和方法的时候，使用 lowerCamelCase ，当命名类的时候，使用 UpperCamelCase （首字母大写），对于常量，则 UPPERCASE 。这将帮助您轻松地区分普通变量/函数和需要实例化的类。使用描述性名称，但使它们尽量简短。 否则: JavaScript是世界上唯一一门不需要实例化，就可以直接调用构造函数（”Class”）的编码语言。因此，类和函数的构造函数由采用UpperCamelCase开始区分。 代码示例1234567891011121314// 使用UpperCamelCase命名类名class SomeClassExample () &#123; // 常量使用const关键字，并使用lowerCamelCase命名 const config = &#123; key: &apos;value&apos; &#125;; // 变量和方法使用lowerCamelCase命名 let someVariableExample = &apos;value&apos;; function doSomething() &#123; &#125;&#125; 3.3 先 require, 而不是在方法内部定义: 在每个文件的起始位置，在任何函数的前面和外部require模块。这种简单的最佳实践，不仅能帮助您轻松快速地在文件顶部辨别出依赖关系，而且避免了一些潜在的问题。 否则: 在Node.js中，require 是同步运行的。如果从函数中调用它们，它可能会阻塞其他请求，在更关键的时间得到处理。另外，如果所require的模块或它自己的任何依赖项抛出错误并使服务器崩溃，最好尽快查明它，如果该模块在函数中require的，则可能不是这样的情况。 错误代码示例12345function myClassFunction () &#123; const _ = require(&apos;lodash&apos;) return _.merge(&#123;name: &apos;class&apos;&#125;)&#125; 正确代码示例12345const _ = require(&apos;lodash&apos;)function myClassFunction () &#123; return _.merge(&#123;name: &apos;class&apos;&#125;)&#125; ## 3.4 在文件夹上 require ，而不是直接在文件上定义: 当在一个文件夹中开发库/模块，放置一个文件index.js暴露模块的 内部，这样每个消费者都会通过它。这将作为您模块的一个接口，并使未来的变化简单而不违反规则。 否则: 更改文件内部结构或签名可能会破坏与客户端的接口。 代码示例1234567// 建议module.exports.SMSProvider = require(&apos;./SMSProvider&apos;);module.exports.SMSNumberResolver = require(&apos;./SMSNumberResolver&apos;);// 避免module.exports.SMSProvider = require(&apos;./SMSProvider/SMSProvider.js&apos;);module.exports.SMSNumberResolver = require(&apos;./SMSNumberResolver/SMSNumberResolver.js&apos;); 测试和总体质量实践4.1 至少，编写API（组件）测试定义: 大多数项目只是因为时间表太短而没有进行任何自动化测试，或者测试项目失控而正被遗弃。因此，优先从API测试开始，这是最简单的编写和提供比单元测试更多覆盖率的事情（你甚至可能不需要编码而进行API测试，像Postman。之后，如果您有更多的资源和时间，继续使用高级测试类型，如单元测试、DB测试、性能测试等。 否则: 您可能需要花很长时间编写单元测试，才发现只有20%的系统覆盖率。 4.2 使用一个linter检测代码问题定义: 使用代码linter检查基本质量并及早检测反模式。在任何测试之前运行它, 并将其添加为预提交的git钩子, 以最小化审查和更正任何问题所需的时间。也可在Section 3中查阅编码样式实践 否则: 您可能让一些反模式和易受攻击的代码传递到您的生产环境中。 代码示例（husky） 123456&#123; &quot;husky&quot;: &#123; &quot;hooks&quot;: &#123; &quot;pre-commit&quot;: &quot;standard &amp;&amp; yarn test&quot; &#125; &#125; 4.3 经常检查易受攻击的依赖定义: 即使是那些最有名的依赖模块，比如Express，也有已知的漏洞。使用社区和商业工具，比如 🔗 nsp ，集成在您的CI平台上，在每一次构建的时候都会被调用，这样可以很容易地解决漏洞问题。 否则: 在没有专用工具的情况下，使代码清除漏洞，需要不断地跟踪有关新威胁的在线出版物，相当繁琐。 4.4 检查过期的依赖包定义: 使用您的首选工具 (例如 “npm outdated” or npm-check-updates 来检测已安装的过期依赖包, 将此检查注入您的 CI 管道, 甚至在严重的情况下使构建失败。例如, 当一个已安装的依赖包滞后5个补丁时 (例如:本地版本是1.3.1 的, 存储库版本是1.3.8 的), 或者它被其作者标记为已弃用, 可能会出现严重的情况 - 停掉这次构建并防止部署此版本。 否则: 您的生产环境将运行已被其作者明确标记为有风险的依赖包 进入生产实践5.1. 监控!定义: 监控是一种在顾客之前发现问题的游戏 – 显然这应该被赋予前所未有的重要性。考虑从定义你必须遵循的基本度量标准开始（我的建议在里面），到检查附加的花哨特性并选择解决所有问题的解决方案。市场已经淹没其中。点击下面的 ‘The Gist’ ，了解解决方案的概述。 否则: 错误 === 失望的客户. 非常简单. 监控示例：StackDriver默认仪表板。很难提取应用内指标null ### 监控示例：Grafana作为可视化原始数据的UI层null 5.2. 使用智能日志增加透明度定义: 日志可以是调试语句的一个不能说话的仓库，或者表述应用运行过程的一个漂亮仪表板的驱动。从第1天计划您的日志平台：如何收集、存储和分析日志，以确保所需信息（例如，错误率、通过服务和服务器等完成整个事务）都能被提取出来。 否则: 您最终像是面对一个黑盒，不知道发生了什么事情，然后你开始重新写日志语句添加额外的信息。 一段解释无论如何，您要打印日志，显然需要一些可以在其中跟踪错误和核心指标的接口来包装生产环境信息（例如，每小时发生了多少错误，最慢的API节点是哪一个）为什么不在健壮的日志框架中进行一些适度的尝试呢? 要实现这一目标，需要在三个步骤上做出深思熟虑的决定: 智能日志 – 在最基本的情况下，您需要使用像Winston, Bunyan这样有信誉的日志库，在每个事务开始和结束时输出有意义的信息。还可以考虑将日志语句格式化为JSON，并提供所有上下文属性（如用户id、操作类型等）。这样运维团队就可以在这些字段上操作。在每个日志行中包含一个唯一的transaction ID，更多的信息查阅条款 “Write transaction-id to log”。最后要考虑的一点还包括一个代理，它记录系统资源，如内存和CPU，比如Elastic Beat。 智能聚合 – 一旦您在服务器文件系统中有了全面的信息，就应该定期将这些信息推送到一个可以聚合、处理和可视化数据的系统中。例如，Elastic stack是一种流行的、自由的选择，它提供所有组件去聚合和产生可视化数据。许多商业产品提供了类似的功能，只是它们大大减少了安装时间，不需要主机托管。 智能可视化 – 现在的信息是聚合和可搜索的, 一个可以满足仅仅方便地搜索日志的能力, 可以走得更远, 没有编码或花费太多的努力。我们现在可以显示一些重要的操作指标, 如错误率、平均一天CPU使用, 在过去一小时内有多少新用户选择, 以及任何其他有助于管理和改进我们应用程序的指标。 可视化示例: Kibana(Elastic stack的一部分)促进了对日志内容的高级搜索null### 可视化示例: Kibana(Elastic stack的一部分)基于日志来可视化数据null 5.3 锁住依赖定义: 您的代码必须在所有的环境中是相同的，但是令人惊讶的是，NPM默认情况下会让依赖在不同环境下发生偏移 – 当在不同的环境中安装包的时候，它试图拿包的最新版本。克服这种问题可以利用NPM配置文件， .npmrc，告诉每个环境保存准确的（不是最新的）包的版本。另外，对于更精细的控制，使用NPM “shrinkwrap”。*更新：作为NPM5，依赖默认锁定。新的包管理工具，Yarn，也默认锁定。 否则: QA测试通过的代码和批准的版本，在生产中表现不一致。更糟糕的是，同一生产集群中的不同服务器可能运行不同的代码。 一段解释您的代码依赖于许多外部包，假设它“需要”和使用momentjs-2.1.4，默认情况下，当布署到生产中时，npm可能会获得momentjs 2.1.5，但不幸的是，这将带来一些新的bug。使用npm配置文件和设置 –save-exact=true 指示npm去完成安装，以便下次运行 npm install（在生产或在Docker容器中，您计划将其用于测试）时，将获取相同的依赖版本。另一种可选择受欢迎的方法是使用一个shrinkwrap文件（很容易使用npm生成）指出应该安装哪些包和版本，这样就不需要环境来获取新版本了。 更新: 在npm5中，使用.shrinkwrap依赖项会被自动锁定。Yarn，一个新兴的包管理器，默认情况下也会锁定依赖项。代码示例: .npmrc文件指示npm使用精确的版本12// 在项目目录上保存这个为.npmrc 文件save-exact:true ### 代码示例: shirnkwrap.json文件获取准确的依赖关系树12345678910111213&#123; &quot;name&quot;: &quot;A&quot;, &quot;dependencies&quot;: &#123; &quot;B&quot;: &#123; &quot;version&quot;: &quot;0.0.1&quot;, &quot;dependencies&quot;: &#123; &quot;C&quot;: &#123; &quot;version&quot;: &quot;0.1.0&quot; &#125; &#125; &#125; &#125;&#125; ### 代码示例: npm5依赖锁文件 - package.json123456789101112131415161718192021222324&#123; &quot;name&quot;: &quot;package-name&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;lockfileVersion&quot;: 1, &quot;dependencies&quot;: &#123; &quot;cacache&quot;: &#123; &quot;version&quot;: &quot;9.2.6&quot;, &quot;resolved&quot;: &quot;https://registry.npmjs.org/cacache/-/cacache-9.2.6.tgz&quot;, &quot;integrity&quot;: &quot;sha512-YK0Z5Np5t755edPL6gfdCeGxtU0rcW/DBhYhYVDckT+7AFkCCtedf2zru5NRbBLFk6e7Agi/RaqTOAfiaipUfg==&quot; &#125;, &quot;duplexify&quot;: &#123; &quot;version&quot;: &quot;3.5.0&quot;, &quot;resolved&quot;: &quot;https://registry.npmjs.org/duplexify/-/duplexify-3.5.0.tgz&quot;, &quot;integrity&quot;: &quot;sha1-GqdzAC4VeEV+nZ1KULDMquvL1gQ=&quot;, &quot;dependencies&quot;: &#123; &quot;end-of-stream&quot;: &#123; &quot;version&quot;: &quot;1.0.0&quot;, &quot;resolved&quot;: &quot;https://registry.npmjs.org/end-of-stream/-/end-of-stream-1.0.0.tgz&quot;, &quot;integrity&quot;: &quot;sha1-1FlucCc0qT5A6a+GQxnqvZn/Lw4=&quot; &#125; &#125; &#125; &#125;&#125; #","categories":[{"name":"总结","slug":"总结","permalink":"https://sensitivemix.github.io/categories/总结/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://sensitivemix.github.io/tags/Node-js/"},{"name":"BestPractice","slug":"BestPractice","permalink":"https://sensitivemix.github.io/tags/BestPractice/"}]},{"title":"MongoDB Aggregation 业务场景实战","slug":"MongoDB-Aggregation-业务场景实战","date":"2018-08-13T07:12:35.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2018/08/13/MongoDB-Aggregation-业务场景实战/","link":"","permalink":"https://sensitivemix.github.io/2018/08/13/MongoDB-Aggregation-业务场景实战/","excerpt":"","text":"对于技术人员来说，“管道” 相信大家都不会感到陌生，在很多技术领域都有管道的概念，例如Linux 管道，CI/CD 管道。同样的，MongoDB 2.2 版本也新增了聚合管道功能，虽然功能发布已久，但是社区的复杂场景的实践并不多，给大家造成了聚合管道“不好用”的错觉 。实际在业务场景中，适当的运用聚合往往会带来事半功倍的效果。 定义要想了解聚合管道在业务场景中的使用，首先需要了解聚合管道的定义： 聚合管道用于数据处理，每个文档通过一个或者是多个阶段组成，可以对每个分组进行分组和过滤等功能，然后经过一系列处理，输出相应的结果。 通过这张图，可以清晰的了解到聚合管道的处理过程，我们常用的管道操作符一般有以下这些： $match 主要用于对文档集合的筛选 $project 主要用于从子文档中提取字段，可以重命名字段，也可以移除字段 $group 主要用于根据文档的特定字段进行分组 $unwind 主要用于分割数组嵌入到自己的顶层文件 $lookup 主要用于两个集合之间的左连接操作 $skip 接受一个数字 n，丢弃结果集中的前 n 个文档 $limit 接受一个数字 n，返回结果集中的前 n 个文档 $sort 主要用于结果集的排序应用看完了各种各样的管道操作符，或许有的人在想怎么把它利用在实际业务场景中呢？下面我就通过客户管理系统介绍一下聚合管道的最佳实践，大家听到客户管理系统可能有些陌生，它还有一个“别名” CRM。CRM 系统中存在机会、客户、联系人这三个大的对象，对象之间都是存在关联关系的，机会可以关联多个联系人，可以关联一个客户，而联系人和客户是一一对应的。通过三个基本对象我们可以衍生出很多聚合业务场景，基础架构图如下所示：图一：基础架构图 如上图所示，我们业务场景中经常会出现筛选数据的需求，如条件筛选和自定义字段查询等需求，根据特定的条件筛选出我们想要的数据。针对不同的业务需求，我们一般会涉及到以下场景： 基础对象查询 表 join 查询 分类统计 嵌套对象排序 … 说到了常见的应用场景，下面也介绍一下我们的系统业务数据模型： 机会数据模型 1234567891011db.deals&#123; &apos;_id&apos;: ObjectId, &apos;title&apos;: String, // 机会标题 &apos;status&apos;: String, // 机会状态 &apos;peoples&apos;: Array, // 关联联系人 &apos;_organizationId&apos;: ObjectId， // 关联客户 &apos;createdTime&apos;: Date, // 创建时间 &apos;updatedTime&apos;: Date, // 创建时间 &apos;owner&apos;: Object // 拥有者&#125; 联系人数据模型 1234567891011db.peoples&#123; &apos;_id&apos;: ObjectId, &apos;name&apos;: String, // 联系人名称 &apos;phone&apos;: Array, // 电话 &apos;email&apos;: Array, // 邮箱 &apos;isArchive&apos;: Boolean， // 归档状态 &apos;createdTime&apos;: Date, // 创建时间 &apos;updatedTime&apos;: Date, // 创建时间 &apos;owner&apos;: Object // 拥有者&#125; 客户数据模型 12345678910db.organizations&#123; &apos;_id&apos;: ObjectId, &apos;name&apos;: String, // 客户名称 &apos;address&apos;: Array, // 地址 &apos;isArchive&apos;: Boolean， // 归档状态 &apos;createdTime&apos;: Date, // 创建时间 &apos;updatedTime&apos;: Date, // 创建时间 &apos;owner&apos;: Object // 拥有者&#125; 有了数据模型，我们就可以用它来做数据聚合了，下面会列举出客户管理系统中常用的数据聚合实践。 在 CRM 系统中，作为销售管理，他管辖的地区在指定时间生成的机会是他所关注的。如果他需要筛选出2018年5月1日之后创建的机会的跟进信息，可以通过创建时间的筛选实现他的目标，聚合管道语句如下： 涉及到的组合：$match -&gt; $project 1234db.deals.aggregate([ &#123; $match: &#123; createdTime: &#123; &apos;$gte&apos;: ISODate(&apos;2018-05-01&apos;) &#125; &#125; &#125;, &#123; $project: &#123; title: 1, owner: 1, status: 1, updatedTime: 1 &#125; &#125;]) 在 CRM 系统中，作为销售管理，经常需要统计每个销售业绩情况，用于他们的业绩考核指标。所以他需要统计每个销售赢单的机会数目，为了达成这一目标他可以先通过匹配条件筛选出所有赢单的机会，并过滤所有拥有者为空，然后再通过人员分组，计算每个销售赢单的机会数，聚合管道语句如下所示： 涉及到的组合：$match -&gt; $group 1234db.deals.aggregate([ &#123; $match: &#123; status: &apos;won&apos;, owner: &#123; &apos;$ne&apos;: null &#125; &#125; &#125;, &#123; $group: &#123; _id: &apos;$owner._id&apos;，num_deals: &#123; $sum: 1 &#125; &#125; &#125;]) 在 CRM 系统中，作为一名销售，经常需要拜访客户，拜访完成之后需要在机会中填写相应的跟进记录，所以对于他们来说需要完整的客户地址信息，用于日后的拜访使用。这时候他就可以根据拥有者是自己，并且关联的客户地址信息为空的筛选条件来找到那些机会信息缺失。一般情况下，便于记忆我们按照创建时间倒序要显示机会信息，聚合管道语句如下所示： 涉及到的组合：$match -&gt; $lookup -&gt; $match -&gt; $sort 1234567891011db.deals.aggregate([ &#123; $match: &#123; &apos;owner.name&apos;: &apos;张三&apos; &#125; &#125;, &#123; $lookup: &#123; from: &apos;organizations&apos;, localField: &apos;_organizationId&apos;, foreignField: &apos;_id&apos;, as: &apos;organization&apos; &#125; &#125;, &#123; $match: &#123; &apos;organization.address&apos;: &#123;&apos;$ne&apos;: &apos;&apos;&#125; &#125; &#125;, &#123; $sort: &#123; &apos;createdTime&apos;: -1 &#125; &#125;]) 在 CRM 系统中，作为一名刚入职的销售，可以通过查看别人的赢单的跟单机会来学习如何跟单。这时候他就可以根据状态是赢单且拥有者是张三的筛选条件，找出别人最近赢单的50条销售机会来进行学习。聚合管道语句如下所示： 涉及到的组合：$match -&gt; $project -&gt; $sort -&gt; $skip -&gt; $limit 1234567db.deals.aggregate([ &#123; $match: &#123; &apos;status&apos;: &apos;won&apos;, &apos;owner.name&apos;: &apos;张三&apos; &#125; &#125;, &#123; $project: &#123; &apos;name&apos;: 1, &apos;status&apos;: 1, &apos;wonTime&apos;: 1, &apos;note&apos;: 1 &#125;, &#123; $sort: &#123; &apos;wonTime&apos;: -1 &#125;, &#123; $skip: 0 &#125;, &#123; $limit: 50 &#125;]) 在 CRM 系统中，我们习惯把数据的完整性和成单概率挂钩，如果销售机会关联的联系人和客户信息缺失，往往代表这是一条成单率较低的机会。因为缺失联系人信息无法及时与客户联系会造成失单，所以我们可以通过聚合管道关联操作，寻找存在一个已归档或者拥有者为空的联系人和客户，找出对应的销售机会，评估该机会的信息缺失率，然后完善关联信息。聚合管道语句如下： 涉及到的组合：$match -&gt; $lookup -&gt; $lookup -&gt; $match -&gt; $sort -&gt; $skip -&gt; $limit 123456789101112131415161718192021222324252627282930313233db.deals.aggregate([ &#123; $match: &#123; &apos;owner.name&apos;: &apos;张三&apos;, &apos;$or&apos;: [ &#123; &apos;peoples&apos;: &#123; &apos;$ne&apos;: null &#125; &#125;, &#123; &apos;_organizationId&apos;:&#123; &apos;$ne&apos;: null &#125; &#125; ] &#125; &#125;, &#123; $lookup: &#123; from: &apos;peoples&apos;, localField: &apos;peoples&apos;, foreignField: &apos;_id&apos;, as: &apos;peoples&apos; &#125; &#125;, &#123; $lookup: &#123; from: &apos;organizations&apos;, localField: &apos;_organizationId&apos;, foreignField: &apos;_id&apos;, as: &apos;organization&apos; &#125; &#125;, &#123; $match: &#123; &apos;$or&apos;: [ &#123; &apos;peoples.isArchive&apos;: true &#125;, &#123; &apos;peoples.owner&apos;: &#123; &apos;$ne&apos;: null &#125; &#125;, &#123; &apos;organization.isArchive&apos;: true &#125;, &#123; &apos;organization.owner&apos;: &#123; &apos;$ne&apos;: null &#125; &#125; ] &#125;, &#123; $sort: &#123; &apos;createdTime&apos;: -1 &#125; &#125;, &#123; $skip: 0 &#125;, &#123; $limit: 50 &#125;]) 技巧我们在使用聚合管道满足我们的业务场景的同时，发现有很多小的技巧能够帮助我们优化数据查询，下面给大家列举一下： 管道操作符之$ifNull 定义：如果表达式计算为非空值，则计算表达式并返回表达式的值。如果表达式计算为空值，包括未定义的值或缺少字段的实例，则返回替换表达式的值。 如果需求是按照更新时间对未归档机会进行排序，普通的做法是：1234db.deals.aggregate([ &#123; $match: &#123; &apos;isArchive&apos;: false &#125; &#125;, &#123; $sort: &#123; &apos;updatedTime&apos;: -1 &#125;]) 这样存在一个问题，由于存在更新时间字段不存在或者值为空的脏数据，导致排序结果不准确，为了解决这个问题，当然我们也可以这样去做，排序里面指定多个字段排序：1234db.deals.aggregate([ &#123; $match: &#123; &apos;isArchive&apos;: false &#125; &#125;, &#123; $sort: &#123; &apos;updatedTime&apos;: -1，&apos;_id&apos;: -1 &#125;]) 如果我们运用管道操作符 $ifNull 去实现的话，可以更改更新时间结构，并填充默认值来达到我们期望的排序结果：12345678db.deals.aggregate([ &#123; $match: &#123; &apos;isArchive&apos;: false &#125; &#125;, &#123; $project: &#123; title: 1, updatedTime: &#123; $ifNull: [ &quot;$updatedTime&quot;, ISODate(&apos;9000-01-01&apos;)] &#125; &#125; &#125; &#123; $sort: &#123; &apos;updatedTime&apos;: -1&#125;]) 使用 $ifNull 数据填充来进行排序效率比空值比较排序效率要高，MongoDB 官方也给出了排序类型效率顺序图，如下所示： 图二：不同类型排值图 管道操作符之$cond 定义：评估布尔表达式以返回两个指定的返回表达式之一。如果我们要实现按照更新时间对未归档机会进行排序，更新时间为空的填充默认值，我们可以这样实现：123456789101112db.deals.aggregate([ &#123; $match: &#123; &apos;isArchive&apos;: false &#125; &#125;, &#123; $project: &#123; title: 1, updatedTime: &#123; $cond: &#123; if：&#123;&apos;$eq&apos;: [&apos;$updatedTime&apos;, null]&#125; , then: ISODate(&apos;9000-01-01&apos;) else &apos;$updatedTime&apos; &#125; &#125; &#125; &#125; &#123; $sort: &#123; &apos;updatedTime&apos;: -1&#125;]) 优化 策略优化 将 $match 和 $sort 放到管道的前面，可以给集合建立索引，来提高处理数据的效率 可以用 $match、$limit、$skip 对文档进行提前过滤，以减少后续处理文档的数量 MongoDB 自身优化器 $sort + $match 顺序优化 如果 $match 出现在 $sort 之后，优化器会自动把 $match 放到 $sort 前面 $skip + $limit 顺序优化 如果 $skip 在 $limit 之后，优化器会把 $limit 移动到 $skip 的前面，移动后 $limit的值等于原来的值加上 $skip 的值注意事项 返回结果大小 聚合结果返回的是一个文档，不能超过 16M，从 MongoDB 2.6版本以后，返回的结果可以是一个游标或者存储到集合中，返回的结果不受 16M 的限制。 内存 在进行 Group 操作的时候，如果内容超过 100 M，将会抛错 “Exceeded memory limit for $group, but not allow enternal sort, put allowDiskUse true”，如果需要处理大数据，可以使用 allowDiskUse 选项，存储到磁盘上。 聚合操作符使用 在进行 $project 操作的时候，我们时常会把不需要的值过滤掉，以此来减少聚合操作对内存的消耗，但是不可以删除默认的 _id, 如果删除会抛错 “exception: The top-level _id field is the only field currently supported for exclusion”，_id 作为官方字段不可以删除掉。 小结今天我为你介绍了 MongoDB 聚合管道的应用实践、技巧、优化以及注意事项，解释了聚合管道操作符的基础概念，希望能够对你有所帮助。 这就是以上全部的内容，留几道思考题给你吧。你们公司使用 MongoDB 聚合管道吗？一般使用在什么业务上面？你觉得好用吗？","categories":[{"name":"数据库","slug":"数据库","permalink":"https://sensitivemix.github.io/categories/数据库/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://sensitivemix.github.io/tags/Database/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://sensitivemix.github.io/tags/MongoDB/"}]},{"title":"区块链的运行原理","slug":"区块链的运行原理","date":"2018-04-08T07:17:12.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2018/04/08/区块链的运行原理/","link":"","permalink":"https://sensitivemix.github.io/2018/04/08/区块链的运行原理/","excerpt":"","text":"区块链到底是如何运行的？ 这一篇文章我将以比特币区块链为例来进行讲解，理由有两个： 由于区块链发展到目前阶段，各个技术方向都有长足的发展，那么为了方便你理解，我在这里介绍最简单、最容易理解的\b比特币区块链； 由于大部分区块链都是以比特币区块链为基础进行扩充的，所以首先了解比特币区块链有助于其他项目区块链的后续学习。 中心化记账的问题首先，我们借鉴了一个区块链描述中的经典情景来模拟中心化记账。 假设有一个有百户居民的村子，其中有一位德高望重的村长，村长有一个儿子。村民们都把钱存到村长家，村长负责记账。比如，张三用 1000 买了李四家的牛，村长就把张三名下的存款减去 1000，李四家加上 1000。听起来是不是很像银行的操作？ 对，我们就是先从中心化的银行记账开始聊起。村民都相信村长，才愿意把钱存到村长家，他们相信村长不会作恶。 可惜好景不长，老村长由于操劳过度，驾鹤西去了。新上任的村长儿子铁蛋很是聪明，但也有个毛病，就是粗心大意。他不但经常算错账，一次还被人偷改了账单。 不过，幸好村民自己都有记账，但是由于铁蛋每次错账后都要和别人核对半天，导致村民对新村长的记账能力十分不满。 时间就这么过着，然而最可怕的事情还是发生了，铁蛋的老婆竟然私下篡改账本，给铁蛋七大姑八大姨的余额全部偷偷加了好多，终于有一天事情暴露，村民们气冲冲地跑到铁蛋家里讨说法，于是一片混乱。 这时候有个叫中本聪的人站了出来，他说他设计了一套系统，可以不依赖任何人记账，于是，众人开始将目光集中到他的身上。 1. 公开记账中本聪说他的系统稍微麻烦一点，需要干三件事儿。 每家每户都派发一只信鸽。这就是 P2P 网络，是一个点对点的分布式网络，如果不好理解，你先不用理会，我会在后面讲到。 每家每户都发一个特殊的印章和一个扫描器。这个扫描器有两个功效，一是识别他人的交易是否真实有效，二是识别这个交易是不是自己账号的，\b同时识别并解锁未花费的余额。这就是非对称加密。 每家每户可以参与记账，不过不再记余额，而是记交易本身的内容。这就是区块链中的交易，这个“交易”对应的英文单词是“Transaction”，这是个专有名词，专指一笔账，不同于金融交易的 Trade。 这三条总体来说其实是干一件事情，就是： 每家每户都记账，账簿上不再记载每户村民的余额，而只记载每一笔 Transaction，即记载每一笔交易的付款人、收款人和付款金额。 那么问题就来了：如果每户都记账，肯定每户的账都不统一啊，你记你的，我记我的，最后不全乱了么？ 这个时候需要大家统一账本，保证大家的账本都是一致的。因为记录的交易是全村所有人有序产生的，所以这就需要有一个广播机制。这个广播机制，我先卖个关子，后面再讲。 中本聪说，其实很简单，我们现在先把全村所有人的资产都加起来。还真巧了，刚好 100 万。 中本聪接着说：“只要账簿的初始状态确定，并且每一笔交易可靠并按照物理时间自然记录，并且只加不改不删，这样，当前每户持有多少资产是可以推算出来的。” 中本聪说我现在把我的印章给你们看，这个印章很特殊，盖的章有两块标记，第一块是一个可以识别的标记，比如我往纸上一敲，可识别的标记是 1MsTg2。 这就是你们的代号，由于我们账本是公开的，使用真实姓名会很危险，所以你们记账的交易单上收款人、付款人都填这个码，不用写姓名。你的扫描器和你的印章生成的代号是关联的，有且仅有持有对应扫描器的人才能花费金额，这一步即为“解开交易”。 刚刚说印章有两块，这第二块内容配合这个扫描器才能看，肉眼看则都是乱码，扫描器一扫就知道第二块内容是否有效，这一步也就是“交易验证”。 并且所有交易大家都能接收，都能看到，但却解不开印章乱码部分的内容，仅仅收款方才能解开，因为你的扫描器和你印章生成的代号是关联的，有且仅有持有对应扫描器的人才能解开交易。 以上就是区块链中“公开记账”的过程。“公开记账”就是全网所有人都可以随时查看一套账本，然后按照规则透明公开地进行记账。 2. 创建创世区块创世区块是我们生成全村公开账本的第一笔交易的第一个信封，好比一篇文章总得有个开头一样。 于是乎，中本聪说我先生成第一个 Transaction，这个交易单的付款人为空，收款人是村长，付款金额是 100 万，因为是创世区块，产出多少个是可以随意规定的，由于我们上面统计了全村的账目情况，所以我就写了 100 万，待会儿付款给村长以后，我们可以按照原来的账本给大家发送对应的金额过去。 好了，我们有了第一笔交易，第一个信封也已经做好了。现在让村长把信封传给张三，张三复印一份，然后传给李四，李四继续传下去，一传十，十传百，直到传给全村人，这个步骤也就是“同步区块”，也就是全网都拿到这个信封，以及信封里面的 Transaction。 3. 交易由于上一节我们的创世区块把 100 万交给了村长，那么我们假设张三在村长那里的存款余额是 10 万，这时候村长要根据原来的旧账本，把这 10 万发送给张三，然后把旧账本上的账划掉。下面我们讨论一下如何构造这笔交易。 中本聪开始教村长写交易单，把 100 万分成两部分，第一部分 10 万，收款人是张三；第二部分是 90 万，收款人是自己；这样一个 Transaction 就做成啦。 前面我们说了，不能直接写名字，要写代号，这个代号也就是你的钱包地址，我们需要把收款人写名字的地方，让收款人拿出自己印章，把代号读出来，然后告诉村长即可。 100 万 10 万，张三 90 万，自己 村长写好 Transaction 以后，还需要拿出自己的印章，在 Transaction 上盖章，这个盖章的过程也就相当于区块链中的签名。这个章，全村人都可以拿扫描器扫一下验证是否有效，即验证付款人的章是否有效。 100 万 10 万，张三的印章（1s25vR） 90 万，村长的印章（13gYip） 就这样，村长一共写了 10 份 Transaction，分别代表了发送给不同人的交易，张三一笔 10 万，李四一笔 1 万，等等。 4. 打包 Transaction （挖矿）现在我们有了 Transaction，但是还需要东西把 Transaction 装起来，我们用一个特殊的信封把 Transaction 装起来，这个信封就是区块链中的“区块”，这个封装过程就是“打包交易”。 为什么要封装起来呢？是为了让打包交易的人能够在信封上署名，表示这次打包是由某某某打包的，其次全村的交易可能非常多，需要装配标号，方便大家查询。 我们看到上述的 Transaction 虽然已经生成，但是有个问题，就是没有规定谁有权利把 Transaction 封装到信封里。 我们在开篇的故事中看到了中心化操作肯定是不行的，假设在全村人中，这时候如何筛选出这些打包的人呢？ 中本聪这时候说了，由于我们村的人口增长，100 万未来可能不够，我们暂定 150 万，那多余的 50 万，我们就当奖励给这些装信封的人了，当然不能一次性给，谁装一次信封就领 3 个币。 这时候大家伙儿来劲了呀，只要装信封就能够领钱了，我们在这里把符合条件的人称作“矿工”。 但是中本聪又说了，要获得这个装信封的权利，是有条件的。我给大家出一个难题，谁先解出这个难题的答案，谁就有权利把 Transaction 装到一个信封中，并且要在此信封上盖上自己的章。 这个难题是这样的，它有两大特性，第一是容易验证，第二是计算过程非常复杂。 例如，有种棋牌类游戏叫作“24 点”，玩法就是给出任意 4 个整数，通过整数运算得到 24，比如现在给出 2、9、1、5 四个数，答案是（5-2）*（9-1）= 24。当然，本处仅是举例，“24 点”游戏的答案空间非常小，\b是远远不够生成信封的。 答案非常好验证，但是计算过程是一个尝试的过程，需要耗费大量的精力。而在真实的比特币中，采用的是寻找符合条件的目标哈希，这也就是比特币矿工所做的事情。 好了，这时候大家开始计算给出的难题，刚好李四第一个计算出来，那么这次装信封的操作就由李四完成，李四把 10 份 Transaction 装到信封中，也就是打包 Transaction，并且要在信封背面写上一个信封的\b摘要信息。 比如上一个信封中的第一个交易是什么、信封封面长什么样，最后要在信封上盖上章，也就是“签名”，矿工签名的目的是为了领币，也就是 Coinbase 交易。 以上过程在区块链领域称作“打包 Transaction”，也就是大名鼎鼎的“挖矿”。 5. 广播交易来说说上文提到的广播交易，广播是为了让全村人知道当前时刻你产生了一笔 Transaction，或者是你装好了一个信封。 广播的内容分两种，一种是广播 Transaction，一种是广播信封。第一种广播是意味着还有未被打包的 Transaction，而第二种广播信封则意味着这个 Transaction 已经被某个矿工确认。 收到了广播的通知后，大家先验证信封上难题的答案是否正确，这样便可以验证出信封是否被伪造，接着验里面的每笔交易，最后还要验证信封背面的内容，即上一个信封的摘要是否正确。因为上一个信封大家都已经确认，所以这样可以极大地规避作弊的可能。如果觉得没问题，就可以存入本地数据库中了。 \b至此，全村人的记账问题就差不多解决啦。","categories":[{"name":"前沿技术","slug":"前沿技术","permalink":"https://sensitivemix.github.io/categories/前沿技术/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://sensitivemix.github.io/tags/Blockchain/"}]},{"title":"区块链简介","slug":"区块链简介","date":"2018-03-09T07:15:57.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2018/03/09/区块链简介/","link":"","permalink":"https://sensitivemix.github.io/2018/03/09/区块链简介/","excerpt":"","text":"概况任何事物的发展，从来不是一蹴而就的。 商贸合作中签订的合同，怎么确保对方能遵守和执行？ 餐厅宣称刚从海里打捞上来的三文鱼，怎么证明捕捞时间和运输中的卫生？ 数字世界里，怎么证明你对资产的所有？ 这些看似很难解决的问题，在区块链的世界里已经有了初步的答案。 从数字货币说起货币是人类文明发展过程中的一大发明，最重要的职能包括价值尺度、流通手段、贮藏手段。很难想象离开了货币，现代社会庞大而复杂的经济和金融体系还能否持续运转。 历史上，货币的形态经历了多个阶段的演化，包括实物货币、金属货币、代用货币、信用货币、电子货币、数字货币等。货币自身的价值依托也从实物价值、发行方信用价值，到今天出现的对信息系统（包括算法、数学、密码学、软件等）的信任价值。 需求一般等价物都可以作为货币使用。然而平时最常见的还是纸币本位制，既方便携带、不易仿制、又相对容易辩伪。 注意，严格来讲，货币（money）不等于现金或通货（cash，currency），货币的范围更广。 或许有人认为信用卡相对纸币形式更方便。相对于信用卡这样的集中式支付体系来说，货币提供了更好的匿名性。另外，一旦碰到系统故障、断网、没有刷卡机器等情况，信用卡就不可用了。 无论是货币，还是信用卡模式，都需要额外的系统（例如银行）来完成生产、分发、管理等操作，带来很大的额外成本和使用风险。诸如伪造、信用卡诈骗、盗刷、转账等安全事件屡见不鲜。 很自然的，如果能实现一种数字货币，保持既有货币的这些特性，消除纸质货币的缺陷，无疑将带来巨大的社会变革，极大提高经济活动的运作效率。 数字货币相比于传统货币让我们来对比现在的数字货币和现实生活中的纸币： 属性 分析 胜出方 便携 这点上应该没有争议，显然数字形式的货币胜出。 数字货币 防伪 这点上应该说两者各有千秋，但数字货币可能略胜一筹。纸币依靠的是各种设计（纸张、油墨、暗纹、夹层等）上的精巧，数字货币依靠的则是密码学上的保障。事实上，纸币的伪造时有发生，但数字货币的伪造明面上还没能实现。 数字货币 辩伪 纸币即使依托验钞机仍会有误判情况，数字货币依靠密码学基本不可能出错。数字货币胜出。 数字货币 匿名 通常情况下，两者都能提供很好的匿名性。但都无法防御有意的追踪。 平局 交易 对纸币来说，谁持有纸币谁就是合法拥有者，交易通过纸币自身的转移即可完成。对数字货币来说则复杂的多，因为任何数字物品都是可以被复制的，因此需要额外的机制。为此，比特币发明了区块链技术来确保可靠不可篡改的交易。 纸币 资源 100 美元钞票的生产成本是 0.1 美元左右。100 面额人民币的生产成本说法众多，但估计应该在几毛到几块范围内。数字货币消耗的资源则复杂的多，以最坏情况估计，算出来多少就要消耗多少电（往往要更多）。 纸币 发行 纸币的发行需要第三方机构的参与，数字货币则通过分布式算法来完成发行。在人类历史上，通胀和通缩往往是不合理地发行货币造成的；数字货币尚无机会被验证，在这方面的表现还有待观察。 平局 可见，数字货币并非在所有领域都优于已有的货币形式。不带前提的在所有领域都鼓吹数字货币并不是一种严谨的态度，应该针对具体情况具体分析。实际上，仔细观察目前支持数字货币的交易机构就会发现端倪，当前还没有一种数字货币能完整起到货币的职能。 最后，虽然当前的数字货币“实验”已经取得了巨大成功，但可见的局限也很明显：其依赖的分布式账本技术还缺乏大规模场景下考验；性能和安全性还有待提升；资源的消耗还过高等等。这些问题还有待于相关技术的进一步发展。 实现挑战设计和实现一个数字货币并非易事。 在现实生活中，因为纸币具备可转移性，相对容易地完成价值的交割。但是因为电子内容天然具备零复制成本，无法通过发送电子内容来完成价值的转移。持有人可以试图将同一份电子货币发给多个人，这种被称为“双重支付攻击（Double-Spent）”。 也许有人会讲，当前银行中的货币都是电子化的，因为通过账号里面的数字记录了资产。说的没错，这种电子货币模式有人称为“数字货币 1.0”，它实际上是假定存在一个安全可靠的第三方记账机构来实现，这个机构利用信用作为抵押，来完成交易。 这种中心化控制下的数字货币实现相对简单，但需要一个中心管控系统。但是，很多时候并不存在一个安全可靠的第三方记账机构来充当这个中心管控的角色。 例如，贸易两国可能缺乏足够的外汇储备；网络上的匿名双方进行直接买卖；交易的两个机构彼此互不信任，找不到双方都认可的第三方担保；汇率的变化；可能无法连接到第三方的系统；第三方的系统可能会出现故障…… 总结一下，在去中心化的场景下，存在几个难题： 货币的防伪：谁来负责验证货币； 货币交易：如何确定货币从一方转移到另外一方； 避免双重支付：如何避免出现双重支付。 好吧，这事其实不太容易。 比特币出现在不存在一个第三方记账机构的情况下，如何实现一个数字货币系统呢？ 近三十年来，数字货币技术朝着这个方向努力，经历了几代演进，包括 e-Cash、HashCash、B-money等。 1983 年，David Chaum 最早提出ecash，并于 1989 年创建了 Digicash 公司。ecash 系统是首个匿名化的数字加密货币（anonymous cryptographic electronic money, or electronic cash system），基于 David Chaum 发明的盲签名技术，曾被应用于银行小额支付中。ecash 依赖于一个中心化的中介机构，导致它最终失败。 1997 年，Adam Back 发明了 Hashcash，来解决邮件系统中 DoS 攻击问题。Hashcash 首次提出用工作量证明（Proof of Work，PoW）机制来获取额度，该机制后来被后续数字货币技术所采用。 1998 年，Wei Dai 提出了 B-money，将 PoW 引入数字货币生成过程中。B-money 同时是首个面向去中心化设计的数字货币。从概念上看已经比较完善，但是很遗憾的是，其未能提出具体的设计实现。 上面这些数字货币都或多或少的依赖于一个第三方系统的信用担保。直到比特币的出现，将 PoW 与共识机制结合在一起，首次从实践意义上实现了一套去中心化的数字货币系统。 比特币网络无需任何管理机构，自身通过数学和密码学原理来确保了所有交易的成功进行，比特币自身的价值是通过背后的计算力为背书。这也促使人们开始思考在未来的数字世界中，该如何衡量价值，如何发行货币。 目前看来，数字货币比较有影响力的模式有两种，一种是类似 paypal 这样的选择跟已有的系统合作，成为代理；一种是以比特币这样的完全丢弃已有体系的分布式技术。 现在还很难讲哪种模式将成为未来的主流，甚至未来还可能出现更先进的技术。但对比特币这一类数字货币的设计进行探索，将是一件十分有趣的事情。 什么是区块链定义区块链（Blockchain）技术自身仍然在飞速发展中，目前还缺乏统一的规范和标准。 wikipedia 给出的定义为： A blockchain —originally, block chain —is a distributed database that maintains a continuously-growing list of data records hardened against tampering and revision. It consists of data structure blocks—which hold exclusively data in initial blockchain implementations, and both data and programs in some of the more recent implementations—with each block holding batches of individual transactions and the results of any blockchain executables. Each block contains a timestamp and information linking it to a previous block. 最早区块链技术雏形出现在比特币项目中。作为比特币背后的分布式记账平台，在无集中式管理的情况下，比特币网络稳定运行了近八年时间，支持了海量的交易记录，并未出现严重的漏洞。 注：比特币历史上唯一已知的漏洞事件曾导致比特币的恶意增发，但问题很快被发现并修正，相关非法交易被撤销。 公认的最早关于区块链的描述性文献是中本聪所撰写的 比特币：一种点对点的电子现金系统，但该文献重点在于讨论比特币系统，实际上并没有明确提出区块链的定义和概念。在其中，区块链被描述为用于记录比特币交易的账目历史。 图 1.4.3.1 - 古老的账本 记账技术历史悠久，现代复式记账系统（Double Entry Bookkeeping）是由意大利数学家卢卡·帕西奥利，1494 年在《Summa de arithmetica, geometrica, proportioni et proportionalità》一书中最早制定。复式记账法对每一笔账目同时记录来源和去向，首次将对账验证功能引入记账过程，提升了记账的可靠性。从这个角度来看，区块链是首个自带对账功能的数字记账技术实现。 更广泛意义地看，区块链属于一种去中心化的记录技术。参与到系统上的节点，可能不属于同一组织、彼此无需信任；区块链数据由所有节点共同维护，每个参与维护节点都能复制获得一份完整记录的拷贝。 跟传统的记账技术相比，其特点应该包括： 维护一条不断增长的链，只可能添加记录，而发生过的记录都不可篡改； 去中心化，或者说多中心化，无需集中的控制而能达成共识，实现上尽量分布式； 通过密码学的机制来确保交易无法抵赖和破坏，并尽量保护用户信息和记录的隐私性。 更进一步的，还可以将智能合约跟区块链结合到一起，让其提供除了交易（比特币区块链已经支持简单的脚本计算）功能外更灵活的合约功能，执行更为复杂的操作。这样扩展之后的区块链，已经超越了单纯数据记录的功能了，实际上带有点“普适计算”的意味了。 基本原理区块链的基本原理理解起来并不难。基本概念包括： 交易（Transaction）：一次操作，导致账本状态的一次改变，如添加一条记录； 区块（Block）：记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识； 链（Chain）：由一个个区块按照发生顺序串联而成，是整个状态变化的日志记录。 如果把区块链作为一个状态机，则每次交易就是试图改变一次状态，而每次共识生成的区块，就是参与者对于区块中所有交易内容导致状态改变的结果进行确认。 图 1.4.3.2 - 区块链示例 分类根据参与者的不同，可以分为公开（Public）链、联盟（Consortium）链和私有（Private）链。 公开链，顾名思义，任何人都可以参与使用和维护，典型的如比特币区块链，信息是完全公开的。 如果引入许可机制，包括私有链和联盟链两种。 私有链，则是集中管理者进行限制，只能得到内部少数人可以使用，信息不公开。 联盟链则介于两者之间，由若干组织一起合作维护一条区块链，该区块链的使用必须是有权限的管理，相关信息会得到保护，典型如银联组织。 目前来看，公开链将会更多的吸引社区和媒体的眼球，但更多的商业价值应该在联盟链和私有链上。 根据使用目的和场景的不同，又可以分为以数字货币为目的的货币链，以记录产权为目的的产权链，以众筹为目的的众筹链等。 小结区块链是第一个试图自带信任化和防止篡改的分布式记录系统。它的出现，让大家意识到，除了互联网这样的尽力而为的基础设施外，我们还能打造一个彼此信任的基础设施。 类似比特币这样的大规模长时间自治运行的系统，也为区块链技术的应用开启了更多遐想的空间。如果人与人之间的交易无法伪造，合同都能确保可靠执行，世界是不是更美好一些了呢？这是技术进步再次给人类发展带来福利。 不提这种去中心化的金融系统是否能在现实中普及，在跨国交易、跨组织合作日益频繁的今天，已经有了不少有意义的尝试和参考。 更进一步，比特币只是基于区块链技术的一种金融应用（而且是直接嵌入区块链中），区块链技术还能带来更通用的计算能力。Hyperledger 和 Ethereum 就试图做类似的事情，基于区块链再做一层平台层，让别人基于平台开发应用变得更简单。 另外，区块链本身可以作为分布式存储，也自然可以作为分布式计算引擎。可以想象，整个加入集群的设备都是计算引擎，大家通过付费来使用计算力，是不是就有点普适计算的意味了？ 有理由相信，随着更多商业应用场景的出现，区块链技术将在未来金融和信息技术领域占据一席之地。","categories":[{"name":"前沿技术","slug":"前沿技术","permalink":"https://sensitivemix.github.io/categories/前沿技术/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://sensitivemix.github.io/tags/Blockchain/"}]},{"title":"Javascript 设计模式与开发实践总结","slug":"Javascript-设计模式与开发实践总结","date":"2018-02-26T07:13:59.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2018/02/26/Javascript-设计模式与开发实践总结/","link":"","permalink":"https://sensitivemix.github.io/2018/02/26/Javascript-设计模式与开发实践总结/","excerpt":"","text":"2018.02.04第一章：基础部分1.1 多态类型语言和鸭子语言 鸭子类型：走起来像鸭子，叫起来也像鸭子，那么他就是一只鸭子。1.2 多态多态含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。 基本多态12345678910111213var makeSound = function (animal) &#123; if (animal instanceOf Duck) &#123; console.log(&apos;嘎嘎嘎&apos;) &#125; else if (animal instanceOf Chicken) &#123; console.log(&apos;咯咯咯&apos;) &#125;&#125;var Duck = function() &#123;&#125;var Chicken = function() &#123;&#125;makeSound(new Duck())makeSound(new Chicken()) 优化多态12345678910111213var makeSound = function (animal) &#123; animal.sound()&#125;var Duck = function() &#123;&#125;Duck.prototype.sound = function() &#123; console.log(&apos;嘎嘎嘎&apos;)&#125;var Chicken = function() &#123;&#125;Chiecken.prototype.sound = function() &#123; console.log(&apos;咯咯咯&apos;)&#125; ES6 多态类1234567891011121314151617181920212223class MakeSound &#123; sound (animal) &#123; animal.sound() &#125;&#125;class Duck &#123; sound () &#123; console.log(&apos;嘎嘎嘎&apos;) &#125;&#125;class Chicken &#123; sound () &#123; console.log(&apos;咯咯咯&apos;) &#125;&#125;var makesound = new MakeSound()var duck = new Duck()var chicken = new Chicken()makesound.sound(duck)makesound.sound(chicken) 1.2.6 多态在面向对象中的设计假设我们要编写一个地图应用，现在有两家可选的地图 API 提供商供我们接入自己的应用。 目前我们选择的是谷歌地图，谷歌地图的 API 中提供了 show 方法，负责在页面上展示整个地图。 示例代码如下 ： 12345678910var googleMap = &#123; show: function()&#123;console.log( &apos;开始渲染谷歌地图&apos; ); &#125;&#125;;var renderMap = function()&#123; googleMap.show();&#125;;renderMap(); // 输出:开始渲染谷歌地图 后来因为某些原因，要把谷歌地图换成百度地图，为了让 renderMap 函数保持一定的弹性， 我们用一些条件分支来让 renderMap 函数同时支持谷歌地图和百度地图: 12345678910111213141516171819var googleMap = &#123; show: function()&#123;console.log( &apos;开始渲染谷歌地图&apos; ); &#125;&#125;;var baiduMap = &#123; show: function()&#123;console.log( &apos;开始渲染百度地图&apos; ); &#125;&#125;;var renderMap = function( type )&#123; if ( type === &apos;google&apos; )&#123; googleMap.show();&#125;else if ( type === &apos;baidu&apos; )&#123; baiduMap.show();&#125; &#125;;renderMap( &apos;google&apos; ); // 输出:开始渲染谷歌地图 renderMap( &apos;baidu&apos; ); // 输出:开始渲染百度地图 可以看到，虽然 renderMap 函数目前保持了一定的弹性，但这种弹性是很脆弱的，一旦需要 替换成搜搜地图，那无疑必须得改动 renderMap 函数，继续往里面堆砌条件分支语句。 优化实现： 123456789101112131415161718192021class RenderMap &#123; start (Map) &#123; new Map().show() &#125;&#125;class BaiduMap &#123; show () &#123; console.log(&apos;开始渲染百度地图&apos;) &#125;&#125;class GoogleMap &#123; show () &#123; console.log(&apos;开始渲染谷歌地图&apos;) &#125;&#125;const rendermap = new RenderMap()rendermap.start(BaiduMap)rendermap.start(GoogleMap) ### 1.4.1 使用克隆的原型模式从设计模式的角度讲，原型模式是用于创建对象的一种模式，如果我们想要创建一个对象， 一种方法是先指定它的类型，然后通过类来创建这个对象。原型模式选择了另外一种方式，我们 不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。 既然原型模式是通过克隆来创建对象的，那么很自然地会想到，如果需要一个跟某个对象一 模一样的对象，就可以使用原型模式。 假设我们在编写一个飞机大战的网页游戏。某种飞机拥有分身技能，当它使用分身技能的时 候，要在页面中创建一些跟它一模一样的飞机。如果不使用原型模式，那么在创建分身之前，无 疑必须先保存该飞机的当前血量、炮弹等级、防御等级等信息，随后将这些信息设置到新创建的 飞机上面，这样才能得到一架一模一样的新飞机。 1如果使用原型模式，我们只需要调用负责克隆的方法，便能完成同样的功能。 原型模式的实现关键，是语言本身是否提供了 clone 方法。ECMAScript 5 提供了 Object.create 方法，可以用来克隆对象。代码如下: 123456789101112131415161718192021Object.create = Object.create || function( obj )&#123; var F = function() &#123;&#125; F.prototype = obj return new F() &#125;class Flane &#123; constructor () &#123; this.height = 100 this.width = 200 &#125;&#125;var flane = new Flane()flane.height = 101flane.width = 201console.log(flane)const cloneFlane = Object.create(new Flane())console.log(cloneFlane) 2018.02.051.4.4 原型编程规范 所有数据都是对象 要得到一个对象，不是实例化一个类，而是找到一个对象作为原型并克隆它 对象会记住他的原型 如果对象无法响应某个请求，它会把这个请求委托给它的原型第二章：this、apply 和 call2.1.1 关于 this 的指向 作为对象的方法调用 123456789var obj = &#123; a: 1, getA: function()&#123; alert ( this === obj ); // 输出:true alert ( this.a ); // 输出: 1 &#125; &#125;;obj.getA(); 作为普通函数调用 1234567window.globalName = &apos;jack&apos;var map = function () &#123; return this.globalName&#125;console.log(map()) 构造器调用 123456var MyClass = function () &#123; this.name = &apos;jack&apos;&#125;var myclass = new MyClass()console.log(myclass.name) Function.prototype.apply 和 Function.prototype.call 12345678910111213var object = &#123; name: &apos;jack&apos;, getName: function () &#123; return this.name &#125;&#125;var objectClone = &#123; name: &apos;rose&apos;&#125;console.log(object.getName())console.log(object.getName.call(objectClone)) 2.2 call 和 apply关键在于传入参数的形式不同 apply 接受两个参数，第一个参数指向 this 的指向，第二个参数作为一个带下标的集合，这个集合可以是个数组，也可以是一个类数组，apply 方法将这个参数传递给被调用的函数： 12345var func = function (a, b, c) &#123; console.log([a, b, c])&#125;func.apply(null, [1, 2, 3]) call 接受多个参数，第一个参数指向 this 的指向，后面的参数依次传递给被调用的函数 1234var func = function (a, b, c) &#123; console.log([a, b, c])&#125;func.call(null, 1, 2, 3) 用途 改变 this 指向 Function.prototype.bind 12345678910111213141516171819Function.prototype.bind = function()&#123; var self = this, // 保存原函数 var context = [].shift.call( arguments ), var args = [].slice.call( arguments ); return function()&#123; // 返回一个新的函数 // 需要绑定的 this 上下文 // 剩余的参数转成数组 return self.apply( context, [].concat.call( args, [].slice.call( arguments ) ) ); // 执行新的函数的时候，会把之前传入的 context 当作新函数体内的 this// 并且组合两次分别传入的参数，作为新函数的参数&#125; &#125;;var obj = &#123; name: &apos;sven&apos;&#125;;var func = function( a, b, c, d )&#123;alert ( this.name ); // 输出:svenalert ( [ a, b, c, d ] ) // 输出:[ 1, 2, 3, 4 ]&#125;.bind( obj, 1, 2 ); func( 3, 4 ); 借用其他对象的方法 1234567891011121314var a = function (name) &#123; this.name = name&#125;var B = function () &#123; a.apply(this, arguments)&#125;B.prototype.getName = function () &#123; return this.name&#125;var b = new B(&apos;hello&apos;)console.log(b.getName()) 2018.02.07第二部分：设计模式 单例模式 单例模式的定义：保证一个类仅有一个实例，并提供唯一访问它的全局访问点。 2018.02.10 单例模式实例1234567891011121314151617181920212223242526var createLoginLayer = function()&#123; var div = document.createElement( &apos;div&apos; ) div.innerHTML = &apos;我是登录浮窗&apos; div.style.display = &apos;none&apos; document.body.appendChild( div ) return div&#125;var createSingleLoginLayer = getSingle( createLoginLayer )document.getElementById( &apos;loginBtn&apos; ).onclick = function()&#123; var loginLayer = createSingleLoginLayer() loginLayer.style.display = &apos;block&apos;&#125;下面我们再试试创建唯一的 iframe 用于动态加载第三方页面:var createSingleIframe = getSingle( function() &#123; var iframe = document.createElement ( &apos;iframe&apos; ) document.body.appendChild( iframe ) return iframe&#125;)document.getElementById( &apos;loginBtn&apos; ).onclick = function()&#123; var loginLayer = createSingleIframe() loginLayer.src = &apos;http://baidu.com&apos; })2018.02.12 第五章： 策略模式定义一系列算法，把他们封装起来，并且使他们可以相互替换。 5.1.3 实例代码12345678910111213141516171819202122232425262728var financeA = function () &#123;&#125;financeA.prototype.calculate = function (salary) &#123; return salary * 2&#125;var financeB = function () &#123;&#125; financeB.prototype.calculate = function (salary) &#123; return salary * 3&#125;var financeC = function () &#123;&#125;financeC.prototype.calculate = function (salary) &#123; return salary * 4&#125;var Bonus = function () &#123; this.stragety = null this.salary = null &#125;Bonus.protoType.setStragety = function (stragety) &#123; return this.stragety = stragety&#125;Bouns.protoType.getBonus = function (stragety) &#123; // 取得奖金数额 this.setStragety(stragety).calculate(this.salary) // 将计算奖金操作委托给对应的策略对象&#125; 5.7 策略模式的优缺点 策略模式利用组合和委托和多态技术的思想，可以有效的避免多重条件选择条件。 策略模式提供了对开放-封闭原则的完美支持，将算法封装到 strategy 中，使得他们易于切换，易于理解，易于扩展。 策略模式的算法也可以复用在系统其它地方，从而避免许多重复的复制粘贴工作。 在策略模式中，利用组合和委托实现了 context 执行算法的能力，这也是继承一种更轻便的实现方案。### 第六章：代理模式6.2 虚拟代理虚拟代码就是把开销很大的对象，留存到需要它的地方再去创建。6.8 缓存代理缓存代理可以为一些开销大的运算结果提供暂时的存储，可用于 AJAX 请求对象6.10 其他代理模式 保护代理 保护代理用于控制不同权限的对象对目标对象访问 防火墙代理 控制网络资源的访问 远程代理 为一个对象在不同地址空间提供局部代表 智能引用代理 取代简单的指针，在对象访问的时候提供一些特殊的操作，比如计算一个对象被引用的次数 写时复制代理 通常用于复制一个庞大的对象，写时复制延迟了复制的过程。当对象真正被修改的时候，才去进行复制操作。写时复制是虚拟代理的一种变体，DLL （操作系统的动态链接库）是典型的运用场景 2018.02.26享元模式：解决性能问题而生适用场景： 一个程序中使用了大量重复对象 由于使用大量对象，造成内存开销 对象的大对数状态多可以变成外部状态 剥离出对象的外部状态之外，可以用较少的共享对象取代大量对象 对象池：数据库连接对象，HTTP连接池适用场景","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://sensitivemix.github.io/categories/设计模式/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://sensitivemix.github.io/tags/Javascript/"},{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://sensitivemix.github.io/tags/DesignPattern/"}]},{"title":"单点登录基本概念","slug":"单点登录基本概念","date":"2017-06-19T13:40:28.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2017/06/19/单点登录基本概念/","link":"","permalink":"https://sensitivemix.github.io/2017/06/19/单点登录基本概念/","excerpt":"","text":"前言 目前大部分网站都支持单点登录，何谓单点登录，就是一个账号可以登录多个网站，不用在每个网站都注册一个账号。 流程 访问网站 跳转到授权服务器请求code授权码 授权服务器接受到请求根据回调地址，响应授权码 客户端收到授权码，转换成授权token认证 存入session或者持久化存储","categories":[{"name":"开发","slug":"开发","permalink":"https://sensitivemix.github.io/categories/开发/"}],"tags":[{"name":"Login","slug":"Login","permalink":"https://sensitivemix.github.io/tags/Login/"}]},{"title":"前端入门学习资料","slug":"前端入门学习资料","date":"2017-06-17T01:58:59.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2017/06/17/前端入门学习资料/","link":"","permalink":"https://sensitivemix.github.io/2017/06/17/前端入门学习资料/","excerpt":"","text":"第一阶段： 基础，包含 HTML CSS JavaScript可学习的网站：w3c：http://www.w3school.com.cn/ （只看HTML/CSS JavaScript模块即可）慕课网：http://www.imooc.com/course/programdetail/pid/32html/css基础课程： https://www.codecademy.com/learn/webless： http://www.bootcss.com/p/lesscss/sass： http://www.sasschina.com/guide/flex 布局：语法篇和实例篇 http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html http://www.ruanyifeng.com/blog/2015/07/flex-examples.html注：less和sass都是让编写css变得更简单，你可以先熟悉其中一种，推荐less，简单些flex是一种布局，可以避免各种相对绝对定位引起的浮动。 仿写的页面 http://www.thatsitmag.com/ 用HTML和CSS实现这个页面，CSS用less写，页面布局用flex，如果能够完成，你的HTML和CSS就差不多了。要有耐心。 一些不错的技术论坛，有问题可以去那找答案或者发帖求助：segmentfault：https://segmentfault.com/dio.io：http://div.io/#/welcomev2ex：https://www.v2ex.com/一些不错的app：segmentfault开发者头条推酷36氪前端工程师一些不错的微信公众号：前端大全前端圈前端早读课程序员那些事互联网实习by拉勾网乔布简历注：在一些论坛和微信公众号上能看到招聘信息，你可以看看目前的招聘要求，自己要学的技术有哪些，增加动力。等你基础差不多了，我再给你整理深一点的东西。在学习过程中学到的新的知识点，遇到问题是如何解决的，都可以记录下来，推荐你用石墨文档记录。 js: http://es6.ruanyifeng.com/ react中文:http://www.css88.com/react/docs/getting-started.htmlreact英文： http://reactjs.cn/react/docs/reusable-components.html#prop- redux中文: http://cn.redux.js.org/redux英文:http://redux.js.org/ github基本操作命令演示 http://learngitbranching.js.org/?locale=zh_CNsourcetree: https://www.sourcetreeapp.com/","categories":[{"name":"学习资料","slug":"学习资料","permalink":"https://sensitivemix.github.io/categories/学习资料/"}],"tags":[{"name":"Frontend","slug":"Frontend","permalink":"https://sensitivemix.github.io/tags/Frontend/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://sensitivemix.github.io/tags/Tutorial/"}]},{"title":"编码基础之 c 语言指针分析","slug":"编码基础之 c 语言指针分析","date":"2017-06-12T14:55:07.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2017/06/12/编码基础之 c 语言指针分析/","link":"","permalink":"https://sensitivemix.github.io/2017/06/12/编码基础之 c 语言指针分析/","excerpt":"","text":"第一章 指针的概念指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。 要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。让我们分别说明。先声明几个指针放着做例子：例一：(1)int ptr;(2)char ptr;(3)int *ptr;(4)int (ptr)[3];(5)int (ptr)[4];如果看不懂后几个例子的话，请参阅我前段时间贴出的文?lt;&lt;如何理解c和c++的复杂类型声明&gt;&gt;。 1.指针的类型。从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：(1)int ptr; //指针的类型是int (2)char ptr; //指针的类型是char (3)int ptr; //指针的类型是 int (4)int (ptr)[3]; //指针的类型是 int()[3](5)int (ptr)[4]; //指针的类型是 int ()[4]怎么样？找出指针的类型的方法是不是很简单？ 2.指针所指向的类型。当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符去掉，剩下的就是指针所指向的类型。例如：(1)int ptr; //指针所指向的类型是int(2)char ptr; //指针所指向的的类型是char(3)int **ptr; //指针所指向的的类型是 int (4)int (ptr)[3]; //指针所指向的的类型是 int()[3](5)int (ptr)[4]; //指针所指向的的类型是 int ()[4]在指针的算术运算中，指针所指向的类型有很大的作用。指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C越来越熟悉时，你会发现，把与指针搅和在一起的”类型”这个概念分成”指针的类型”和”指针所指向的类型”两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。 指针的值，或者叫指针所指向的内存区或地址。指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指向的类型是什么？该指针指向了哪里？ 指针本身所占据的内存区。指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。 第二章 指针的算术运算 指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。例如：例二： char a[20]; int *ptr=a;…… ptr++;在上例中，指针ptr的类型是int,它指向的类型是int，它被初始化为指向整形变量a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针ptr的值加上了sizeof(int)，在32位程序中，是被加上了4。由于地址是用字节做单位的，故ptr所指向的地址由原来的变量a的地址向高地址方向增加了4个字节。由于char类型的长度是一个字节，所以，原来ptr是指向数组a的第0号单元开始的四个字节，此时指向了数组a中从第4号单元开始的四个字节。我们可以用一个指针和一个循环来遍历一个数组，看例子：例三：例三：int array[20];int ptr=array;…//此处略去为整型数组赋值的代码。…for(i=0;i&lt;20;i++){(*ptr)++;ptr++；}这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1，所以每次循环都能访问数组的下一个单元。再看例子：例四： char a[20]; int *ptr=a;…… ptr+=5;在这个例子中，ptr被加上了5，编译器是这样处理的：将指针ptr的值加上5乘sizeof(int)，在32位程序中就是加上了5乘4=20。由于地址的单位是字节，故现在的ptr所指向的地址比起加5后的ptr所指向的地址来说，向高地址方向移动了20个字节。在这个例子中，没加5前的ptr指向数组a的第0号单元开始的四个字节，加5后，ptr已经指向了数组a的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。如果上例中，ptr是被减去5，那么处理过程大同小异，只不过ptr的值是被减去5乘sizeof(int)，新的ptr指向的地址将比原来的ptr所指向的地址向低地址方向移动了20个字节。 总结一下，一个指针ptrold加上一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值增加了n乘sizeof(ptrold所指向的类型)个字节。就是说，ptrnew所指向的内存区将比ptrold所指向的内存区向高地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。一个指针ptrold减去一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值减少了n乘sizeof(ptrold所指向的类型)个字节，就是说，ptrnew所指向的内存区将比ptrold所指向的内存区向低地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。 第三章 运算符号&amp;和* 这里&amp;是取地址运算符，是…书上叫做”间接运算符”。&amp;a的运算结果是一个指针，指针的类型是a的类型加个，指针所指向的类型是a的类型，指针所指向的地址嘛，那就是a的地址。p的运算结果就五花八门了。总之p的结果是p所指向的东西，这个东西有这些特点：它的类型是p指向的类型，它所占用的地址是p所指向的地址。例五：int a=12;int b;int p;int **ptr;p=&a;//&amp;a的结果是一个指针，类型是int，指向的类型是int，指向的地址是a的地址。p=24;//p的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，显然，p就是变量a。ptr=&p;//&amp;p的结果是个指针，该指针的类型是p的类型加个，在这里是int。该指针所指向的类型是p的类型，这里是int。该指针所指向的地址就是指针p自己的地址。 ptr=&b;//ptr是个指针，&amp;b的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以用&amp;b来给ptr赋值就是毫无问题的了。 ptr=34;//ptr的结果是ptr所指向的东西，在这里是一个指针，对这个指针再做一次运算，结果就是一个int类型的变量。 第四章 指针表达式 一个表达式的最后结果如果是一个指针，那么这个表达式就叫指针表达式。下面是一些指针表达式的例子：例六：int a,b;int array[10];int pa;pa=&a;//&amp;a是一个指针表达式。int **ptr=&pa;//&amp;pa也是一个指针表达式。 ptr=&b;//ptr和&amp;b都是指针表达式。pa=array;pa++;//这也是指针表达式。例七：char arr[20];char *parr=arr;//如果把arr看作指针的话，arr也是指针表达式char str;str=parr;//parr是指针表达式str=(parr+1);//(parr+1)是指针表达式str=(parr+2);//(parr+2)是指针表达式 由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。在例七中，&amp;a不是一个左值，因为它还没有占据明确的内存。ptr是一个左值，因为ptr这个指针已经占据了内存，其实ptr就是指针pa，既然pa已经在内存中有了自己的位置，那么ptr当然也有了自己的位置。 第五章 数组和指针的关系 如果对声明数组的语句不太明白的话，请参阅我前段时间贴出的文?lt;&lt;如何理解c和c++的复杂类型声明&gt;&gt;。数组的数组名其实可以看作一个指针。看下例：例八：int array[10]={0,1,2,3,4,5,6,7,8,9},value;……value=array[0];//也可写成：value=array;value=array[3];//也可写成：value=(array+3);value=array[4];//也可写成：value=(array+4);上例中，一般而言数组名array代表数组本身，类型是int [10]，但如果把array看做指针的话，它指向数组的第0个单元，类型是int ，所指向的类型是数组单元的类型即int。因此array等于0就一点也不奇怪了。同理，array+3是一个指向数组第3个单元的指针，所以(array+3)等于3。其它依此类推。 例九：例九：char str[3]={“Hello,this is a sample!”,“Hi,good morning.”,“Hello world”};char s[80]；strcpy(s,str[0]);//也可写成strcpy(s,str);strcpy(s,str[1]);//也可写成strcpy(s,(str+1));strcpy(s,str[2]);//也可写成strcpy(s,(str+2));上例中，str是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名str当作一个指针的话，它指向数组的第0号单元，它的类型是char，它指向的类型是char 。 str也是一个指针，它的类型是char*，它所指向的类型是char，它指向的地址是字符串”Hello,this is a sample!”的第一个字符的地址，即’H’的地址。str+1也是一个指针，它指向数组的第1号单元，它的类型是char，它指向的类型是char 。 (str+1)也是一个指针，它的类型是char*，它所指向的类型是char，它指向“Hi,good morning.”的第一个字符’H’，等等。 下面总结一下数组的数组名的问题。声明了一个数组TYPE array[n]，则数组名称array就有了两重含义：第一，它代表整个数组，它的类型是TYPE [n]；第二，它是一个指针，该指针的类型是TYPE，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0号单元，该指针自己占有单独的内存区，注意它和数组第0号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++的表达式是错误的。在不同的表达式中数组名array可以扮演不同的角色。在表达式sizeof(array)中，数组名array代表数组本身，故这时sizeof函数测出的是整个数组的大小。在表达式array中，array扮演的是指针，因此这个表达式的结果就是数组第0号单元的值。sizeof(array)测出的是数组单元的大小。表达式array+n（其中n=0，1，2，….。）中，array扮演的是指针，故array+n的结果是一个指针，它的类型是TYPE，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大小。例十：int array[10];int (ptr)[10];ptr=&array;上例中ptr是一个指针，它的类型是int ()[10]，他指向的类型是int [10]，我们用整个数组的首地址来初始化它。在语句ptr=&amp;array中，array代表数组本身。 本节中提到了函数sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？答案是前者。例如： int (ptr)[10];则在32位程序中，有：sizeof(int()[10])==4sizeof(int [10])==40sizeof(ptr)==4实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。 第六章 指针和结构类型的关系 可以声明一个指向结构类型对象的指针。例十一：struct MyStruct{int a;int b;int c;}MyStruct ss={20,30,40};//声明了结构对象ss，并把ss的三个成员初始化为20，30和40。MyStruct ptr=&ss;//声明了一个指向结构对象ss的指针。它的类型是MyStruct,它指向的类型是MyStruct。int pstr=(int)&ss;//声明了一个指向结构对象ss的指针。但是它的类型和它指向的类型和ptr是不同的。 请问怎样通过指针ptr来访问ss的三个成员变量？答案：ptr-&gt;a;ptr-&gt;b;ptr-&gt;c;又请问怎样通过指针pstr来访问ss的三个成员变量？答案：pstr；//访问了ss的成员a。 (pstr+1);//访问了ss的成员b。(pstr+2)//访问了ss的成员c。呵呵，虽然我在我的MSVC++6.0上调式过上述代码，但是要知道，这样使用pstr来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元：例十二：int array[3]={35,56,37};int pa=array;通过指针pa访问数组array的三个单元的方法是：pa;//访问了第0号单元 (pa+1);//访问了第1号单元(pa+2);//访问了第2号单元从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干?quot;填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。所以，在例十二中，即使pstr访问到了结构对象ss的第一个成员变量a，也不能保证(pstr+1)就一定能访问到结构成员b。因为成员a和成员b之间可能会有若干填充字节，说不定(pstr+1)就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。通过指针访问结构成员的正确方法应该是象例十二中使用指针ptr的方法。 第七章 指针和函数的关系 可以把一个指针声明成为一个指向函数的指针。int fun1(char,int);int (pfun1)(char,int);pfun1=fun1;….….int a=(pfun1)(“abcdefg”,7);//通过函数指针调用函数。可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。例十三：int fun(char);int a;char str[]=”abcdefghijklmn”;a=fun(str);……int fun(chars){int num=0;for(int i=0;i{num+=*s;s++;}return num;)这个例子中的函数fun统计一个字符串中各个字符的ASCII码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把str作为实参传递给形参s后，实际是把str的值传递给了s，s所指向的地址就和str所指向的地址一致，但是str和s各自占用各自的存储空间。在函数体内对s进行自加1运算，并不意味着同时对str进行了自加1运算。 第八章 指针类型转换 当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。在我们前面所举的例子中，绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。例十四：1.float f=12.3; float *fptr=&f; int p;在上面的例子中，假如我们想让指针p指向实数f，应该怎么搞？是用下面的语句吗？p=&f;不对。因为指针p的类型是int，它指向的类型是int。表达式&amp;f的结果是一个指针，指针的类型是float,它指向的类型是float。两者不一致，直接赋值的方法是不行的。至少在我的MSVC++6.0上，对指针的赋值语句要求赋值号两边的类型一致，所指向的类型也一致，其它的编译器上我没试过，大家可以试试。为了实现我们的目的，需要进行”强制类型转换”：p=(int)&f;如果有一个指针p，我们需要把它的类型和所指向的类型改为TYEP和TYPE，那么语法格式是：(TYPE)p；这样强制类型转换的结果是一个新指针，该新指针的类型是TYPE*，它指向的类型是TYPE，它指向的地址就是原指针指向的地址。而原来的指针p的一切属性都没有被修改。 一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，也会发生指针类型的转换。例十五：void fun(char);int a=125,b;fun((char)&amp;a);……void fun(chars){char c;c=(s+3);(s+3)=(s+0);(s+0)=c;c=(s+2);(s+2)=(s+1);(s+1)=c;}}注意这是一个32位程序，故int类型占了四个字节，char类型占一个字节。函数fun的作用是把一个整数的四个字节的顺序来个颠倒。注意到了吗？在函数调用语句中，实参&amp;a的结果是一个指针，它的类型是int ，它指向的类型是int。形参这个指针的类型是char，它指向的类型是char。这样，在实参和形参的结合过程中，我们必须进行一次从int类型到char类型的转换。结合这个例子，我们可以这样来想象编译器进行转换的过程：编译器先构造一个临时指针 chartemp，然后执行temp=(char)&amp;a，最后再把temp的值传递给s。所以最后的结果是：s的类型是char,它指向的类型是char，它指向的地址就是a的首地址。 我们已经知道，指针的值就是指针指向的地址，在32位程序中，指针的值其实是一个32位整数。那可不可以把一个整数当作指针的值直接赋给指针呢？就象下面的语句：unsigned int a;TYPE ptr;//TYPE是int，char或结构类型等等类型。……a=20345686;ptr=20345686;//我们的目的是要使指针ptr指向地址20345686（十进制）ptr=a;//我们的目的是要使指针ptr指向地址20345686（十进制）编译一下吧。结果发现后面两条语句全是错的。那么我们的目的就不能达到了吗？不，还有办法：unsigned int a;TYPE ptr;//TYPE是int，char或结构类型等等类型。……a=某个数，这个数必须代表一个合法的地址；ptr=(TYPE)a；//呵呵，这就可以了。严格说来这里的(TYPE)和指针类型转换中的(TYPE)还不一样。这里的(TYPE)的意思是把无符号整数a的值当作一个地址来看待。上面强调了a的值必须代表一个合法的地址，否则的话，在你使用ptr的时候，就会出现非法操作错误。 想想能不能反过来，把指针指向的地址即指针的值当作一个整数取出来。完全可以。下面的例子演示了把一个指针的值当作一个整数取出来，然后再把这个整数当作一个地址赋给一个指针：例十六：int a=123,b;int ptr=&a;char str;b=(int)ptr;//把指针ptr的值当作一个整数取出来。str=(char*)b;//把这个整数的值当作一个地址赋给指针str。 好了，现在我们已经知道了，可以把指针的值当作一个整数取出来，也可以把一个整数值当作地址赋给一个指针。 第九章 指针的安全问题 看下面的例子：例十七：char s=’a’;int ptr;ptr=(int)&s;ptr=1298；指针ptr是一个int类型的指针，它指向的类型是int。它指向的地址就是s的首地址。在32位程序中，s占一个字节，int类型占四个字节。最后一条语句不但改变了s所占的一个字节，还把和s相临的高地址方向的三个字节也改变了。这三个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。也许这三个字节里存储了非常重要的数据，也许这三个字节里正好是程序的一条代码，而由于你对指针的马虎应用，这三个字节的值被改变了！这会造成崩溃性的错误。让我们再来看一例：例十八： char a; int *ptr=&a;…… ptr++; ptr=115;该例子完全可以通过编译，并能执行。但是看到没有？第3句对指针ptr进行自加1运算后，ptr指向了和整形变量a相邻的高地址方向的一块存储区。这块存储区里是什么？我们不知道。有可能它是一个非常重要的数据，甚至可能是一条代码。而第4句竟然往这片存储区里写入一个数据！这是严重的错误。所以在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里。在用指针访问数组的时候，也要注意不要超出数组的低端和高端界限，否则也会造成类似的错误。在指针的强制类型转换：ptr1=(TYPE)ptr2中，如果sizeof(ptr2的类型)大于sizeof(ptr1的类型)，那么在使用指针ptr1来访问ptr2所指向的存储区时是安全的。如果sizeof(ptr2的类型)小于sizeof(ptr1的类型)，那么在使用指针ptr1来访问ptr2所指向的存储区时是不安全的。至于为什么，读者结合例十七来想一想，应该会明白的。","categories":[{"name":"开发","slug":"开发","permalink":"https://sensitivemix.github.io/categories/开发/"}],"tags":[{"name":"C Pointer","slug":"C-Pointer","permalink":"https://sensitivemix.github.io/tags/C-Pointer/"}]},{"title":"你一定遇到 SqlServer 安装依赖的坑之Microsoft SqlServer Management SDK SFC","slug":"你一定遇到 SqlServer 安装依赖的坑之Microsoft SqlServer Management SDK SFC","date":"2017-06-11T14:33:02.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2017/06/11/你一定遇到 SqlServer 安装依赖的坑之Microsoft SqlServer Management SDK SFC/","link":"","permalink":"https://sensitivemix.github.io/2017/06/11/你一定遇到 SqlServer 安装依赖的坑之Microsoft SqlServer Management SDK SFC/","excerpt":"","text":"I have installed MS SQL Server 2012 R2 and when I try to update model from database under EDMX file I am facing that error. Could not load file or assembly Microsoft.SqlServer.management.sdk.sfc version 11.0.0.0 Solutions: IF Microsoft.SqlServer.management.sdk.sfc version 12.0.0.0 cannot find by visual studioGoto: http://www.microsoft.com/en-us/download/details.aspx?id=42295 DownLoad: ENU\\x86\\SharedManagementObjects.msi for X64 OS ORENU\\x64\\SharedManagementObjects.msi for X64 OS (According to our computer) IF Microsoft.SqlServer.management.sdk.sfc version 11.0.0.0 cannot find by visual studioGoto: https://www.microsoft.com/en-us/download/details.aspx?id=35580 DownLoad: ENU\\x86\\SharedManagementObjects.msi for X64 OS ORENU\\x64\\SharedManagementObjects.msi for X64 OS (According to our computer) IF Microsoft.SqlServer.management.sdk.sfc version 10.0.0.0 cannot find by visual studioGoto: https://www.microsoft.com/en-us/download/details.aspx?id=26728 DownLoad: ENU\\x86\\SharedManagementObjects.msi for X64 OS ORENU\\x64\\SharedManagementObjects.msi for X64 OS (According to our computer) After intalled,and restart visual studio, you will find everything work normally.","categories":[{"name":"数据库","slug":"数据库","permalink":"https://sensitivemix.github.io/categories/数据库/"}],"tags":[{"name":"SqlServer","slug":"SqlServer","permalink":"https://sensitivemix.github.io/tags/SqlServer/"},{"name":"Database","slug":"Database","permalink":"https://sensitivemix.github.io/tags/Database/"}]},{"title":"代码覆盖率必知必会","slug":"代码覆盖率必知必会","date":"2017-06-11T14:32:16.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2017/06/11/代码覆盖率必知必会/","link":"","permalink":"https://sensitivemix.github.io/2017/06/11/代码覆盖率必知必会/","excerpt":"","text":"代码覆盖率（Code Coverage）是反映测试用例对被测软件覆盖程度的重要指标，也是衡量测试工作进展情况的重要指标。它也是对测试工作进行量化的重要指标之一，测试工作往往不如开发那样激动人心，一个重要原因之一就是测试难于量化，而代码覆盖率恰恰是解决着一问题的重要指标。根据其覆盖内容的不同，又可以细分为：语句覆盖、判定覆盖、条件覆盖、路径覆盖以及循环覆盖等等，这里有一篇很好的博客《代码覆盖率浅谈》介绍了各种不同覆盖率的定义。有的理解起来还是蛮拗口的，但其实不难，用到了再看就成！在所有这些覆盖中语句覆盖（Statement coverage）是最简单的，也是最常用的、最有效的覆盖率，Visual Studio采用的是语句覆盖中的基本块覆盖（Basic block coverage）。 对于敏捷开发团队而言，代码覆盖率是每个Sprint要完成的硬性质量标准（Exit Criteria）之一，覆盖率高低根据项目的不同而不同：75%，80%甚至100%都是可能的。代码覆盖率是一个白盒概念，毕竟它最终还是要落实到代码。既然代码覆盖率如此重要，那么什么时候该用它？该如何用它？ 有人认为代码覆盖率重要，所以从项目的一开始就要进行代码覆盖率的检查和分析，即 获取覆盖率 –&gt; 发现未覆盖的代码 –&gt; 添加新测试用例。这样的使用方式，我把它命名为“**代码覆盖率驱动的测试（CCDT，Code Coverage Driven Test）**”。CCDT看起来很美，理论上无懈可击，但实际操作则完全不是那么回事儿。先不说这种方式是否正确，单就由此引入的开销来说，就够项目组喝一壶的，呵呵！之所这样说，是因为CCDT需要经历：获取覆盖率、分析覆盖率和添加测试用例这三步，每一步都存在着很多潜在“副产品”开销，尤其是前两步。要获取覆盖率，需要执行所有的测试用例，而你知道现在业界70%的测试仍然是手动的，仅为了覆盖率就频繁的执行测试用例，显然是不现实的；频繁分析覆盖率结果也是一件耗时的工作，无论开发人员还是测试人员做都是如此，尤其是对于采用敏捷开发方法的团队，短迭代不允许引入如此劳神的工作内容。胡凯在他的博客中称这种唯覆盖率论症状为“[测试覆盖率强迫症](http://www.infoq.com/cn/articles/test-coverage-ocd)”，其中有一句描述很精彩： “ 测试覆盖率仅仅能够告诉团队什么没有被测试，根本就回答不了软件是否经过了有效测试！” 我认为对于测试团队而言，测试的过程应该是**用户场景覆盖驱动的测试（USCDT，User Scenario Coverage Driven Test）** ，即测试人员应该从用户真实使用场景出发，思考要测试的内容和设计测试用例。代码覆盖率是对USCDT的**必要补充**，以发现其中未覆盖的场景（Test Hole）。代码覆盖应该是在项目/迭代的中后期引入，不用很频繁，点到为止，例如对一个3-4周的迭代，3次的覆盖率检查就已经足够了。当然，如果你的自动化测试比例比较高，采用持续集成（Continuous Integration）的方式，例如：Visual Studio 2010中持续集成的构建功能，每次都能自动的进行代码覆盖率的统计，则可以更早，更频繁进行代码覆盖率，但前提一定是这不会带来过多的开销。 说了这么多，下面来点儿实际的吧，看看Visual Studio 2010中如何获取代码覆盖率数据！在Visual Studio的集成开发环境中获自动化测试用例的码覆盖率数据是最简单的（采用命令行方式则稍复杂一些，但它还可以用来获取手动测试用例的覆盖数据），只需要下面三步: 步骤一 ：在Test Settings配置中选择Code Coverage (Updated 2011/6/1) 这里需要注意，当选择Code Coverage项时，还要选择“Configure”按钮去配置一下要针对哪一个文件（.exe/.dl）收集覆盖数据，Visual Studio会自动对这个文件进行instrument操作，否则是不会收集到覆盖数据的。 步骤二 ：执行自动化测试用例 步骤三 ：查看代码覆盖率结果 随着编程语言和开发工具的现代化和傻瓜化，现在获取和分析代码覆盖率工作越来越简单了，但人们对代码覆盖数据的使用却仍然停留在比较原始的阶段。其中还有很多值得去深入发掘的好东东，用于帮助测试团队优化测试过程和测试用例的设计。《代码覆盖从简到繁 (四) – 为代码签入把门儿 》一文中介绍了，如何在代码签入的流程中引入覆盖率检查。","categories":[{"name":"总结","slug":"总结","permalink":"https://sensitivemix.github.io/categories/总结/"}],"tags":[{"name":"CI","slug":"CI","permalink":"https://sensitivemix.github.io/tags/CI/"},{"name":"CodeCoverage","slug":"CodeCoverage","permalink":"https://sensitivemix.github.io/tags/CodeCoverage/"}]},{"title":"那些年用过的 JQuery 之经典 QQ 表情插件","slug":"那些年用过的 JQuery 之经典 QQ 表情插件","date":"2017-06-11T14:26:45.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2017/06/11/那些年用过的 JQuery 之经典 QQ 表情插件/","link":"","permalink":"https://sensitivemix.github.io/2017/06/11/那些年用过的 JQuery 之经典 QQ 表情插件/","excerpt":"","text":"由于目前在接触聊天室项目，接到一个需求实现一个类似QQ表情。在网上找了一款jquery经典表情插件。下面介绍一个用法： HTML： 首先在html页面的head中引入jQuery库文件和QQ表情插件jquery.qqFace.js文件 然后在body中加入以下html代码： 1 div> 2 3 4 textarea> 5 表情span>p> 6 div> 7 div> CSS： 我们用CSS来美化页面，关键是表情按钮图片span.emotion的鼠标滑上与移开效果，以及调用表情插件后，显示的表情.qqFace面板效果，请看代码: 1 .comment{width:680px; margin:20px auto; position:relative} 2 .comment h3{height:28px; line-height:28px} 3 .com_form{width:100%; position:relative} 4 .input{width:99%; height:60px; border:1px solid #ccc} 5 .com_form p{height:28px; line-height:28px; position:relative} 6 span.emotion{width:42px; height:20px; background:url(icon.gif) no-repeat 2px 2px; 7 padding-left:20px; cursor:pointer} 8 span.emotion:hover{background-position:2px -28px} 9 .qqFace{margin-top:4px;background:#fff;padding:2px;border:1px #dfe6f6 solid;} 10 .qqFace table td{padding:0px;} 11 .qqFace table td img{cursor:pointer;border:1px #fff solid;} 12 .qqFace table td img:hover{border:1px #0066cc solid;} 13 #show{width:680px; margin:20px auto} jquery: 当我们点击页面输入框下方那个笑脸时，触发调用qqface表情插件，简单几行就搞定。 1 $(function(){ 2 $('.emotion').qqFace({ 3 4 assign:'saytext', //给输入框赋值 5 path:'face/' //表情图片存放的路径 6 }); 7 ... 8 }); 当选择表情图片后，输入框中会插入一段如[em_5]之类的代码，代表插入的表情图片，实际应用中，点提交按钮后应该将这段表情代码连同其他内容插入到数据表中。而在页面显示的时候，我们应该将表情代码替换成真正的图片显示在页面上。下面的代码是插入表情图片后，点击提交按钮，使用javascript自定义函数将表情代码替换并显示： 1 $(function(){ 2 ... 3 $(\".sub_btn\").click(function(){ 4 var str = $(\"#saytext\").val(); 5 $(\"#show\").html(replace_em(str)); 6 }); 7 }); 8 function replace_em(str){_ _9 str = str.replace(/\\g,'；'); 11 str = str.replace(/\\n/g,'；'); 12 str = str.replace(/[em_([0-9]*)]/g,''); 13 return str; 14 };'); str = str.replace(/\\n/g, ';'); str = str.replace(/[em_([0-9]*)]/g, ''); return str; }, //提交聊天消息内容 submit: function () { var str = $(\"#Y_iSend_Input\").val(); $(\"#Y_iSend_Input\").val(CHAT.replace_em(str)); var message_text = d.getElementById(\"Y_iSend_Input\").value; } }","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://sensitivemix.github.io/categories/开发工具/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://sensitivemix.github.io/tags/Javascript/"},{"name":"Jquery","slug":"Jquery","permalink":"https://sensitivemix.github.io/tags/Jquery/"}]},{"title":"websocket 聊天室","slug":"websocket 聊天室","date":"2017-06-11T14:25:57.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2017/06/11/websocket 聊天室/","link":"","permalink":"https://sensitivemix.github.io/2017/06/11/websocket 聊天室/","excerpt":"","text":"金股棒架构分析与发布在本文中，我们将一步步编写出来聊天室PC端和APP端重新做一次梳理，以及进行一些优化，让整个项目更容易理解和扩展。其次我们还会介绍一些前端流行的工具，帮助我们构建项目，便于发布。 项目结构目前PC端和APP端项目的架构大致相似，如下图： 箭头代表了读取数据的流向，服务端和客户端基本上都分为三层： 服务端：在MongoDB和mongoose之上，我们添加了一层模型的controller，这一层直接处理一些业务相关的逻辑；在这之上，我们直接通过http API或者socket.io将所提供的接口暴露出来；这一块的代码全部写在了app.js中； 客户端：针对不同的组件或者页面，我们对应了不同的controller，而这些controller都是通过$http或者socket 服务直接于服务端通信的；各个controller之间共享数据很困难。 基于上面的问题，我们做出以下调整： 将服务端逻辑从app.js分拆为http和socket两个服务中； 在客户端提供一个统一的数据接口层，向上为controller提供数据服务，向下和服务端通信，同步数据。 新的结构应该像下面这样： 分拆http和socket服务首先简化app.js： 123456789101112131415161718192021222324252627// ...var api = require(&apos;./services/api&apos;)var socketApi = require(&apos;./services/socketApi&apos;)// ...app.post(&apos;/api/login&apos;, api.login)app.get(&apos;/api/logout&apos;, api.logout)app.get(&apos;/api/validate&apos;, api.validate)// ...io.sockets.on(&apos;connection&apos;, function(socket) &#123; socketApi.connect(socket) socket.on(&apos;disconnect&apos;, function() &#123; socketApi.disconnect(socket) &#125;) socket.on(&apos;technode&apos;, function(request) &#123; socketApi[request.action](request.data, socket, io) &#125;)&#125;)// ... 我们把http和socket的回调分别放到api.js和socketApi.js中，在socket通信方面做了简化，使用technode作为统一的事件名，而需要调用的接口名，则由请求数据中的action来决定。每个socket请求都会变成下面这样： 客户端的请求： 123socket.emit(&apos;technode&apos;, &#123; action: &apos;getRoom&apos;&#125;) 下面是服务端的返回： 1234567891011socket.emit(&apos;technode&apos;, &#123; &quot;action&quot;: &quot;getRoom&quot;, &quot;data&quot;: [&#123; &quot;name&quot;: &quot;Socket.IO&quot;, &quot;_id&quot;: &quot;52b0e5dd0a5e66fa26000001&quot;, &quot;__v&quot;: 0, &quot;createAt&quot;: &quot;2013-12-18T00:01:33.528Z&quot;, &quot;users&quot;: [], &quot;messages&quot;: [] &#125;]&#125;) 客户端则根据action，进行不同的处理： 12345socket.on(&apos;technode&apos;, function (data) &#123; switch (data.action) &#123; // ... &#125;&#125;) 而本身api.js和socketApi.js内的处理，与第三章的基本无异，不再细说。 客户端缓存为什么需要客户端缓存？有两点原因： 在第三章的实现中，在房间列表和房间切换时，controller都会通过socket从服务端重新获取房间列表或房间； 在第三章的实现中，我们无法在controller之间共享数据，比如在LoginCtrl中，用户登录后，我们需要更新$rootScope的用户信息，采用了scope事件机制来实现。 我们需要一个缓存数据和共享数据的组件，这个组件将服务端请求来的数据缓存下来，避免重复的从服务端请求相同的数据，其次是对所有的controller提供接口，让controller间可以共享（读取、修改）同一份数据。 我们把这个组件命名为server，与服务端通信完全通过这个组件，数据缓存到这个组件之中，controller直接与它通信，不必关心真正的服务器是什么样的。 123456789101112131415161718192021222324252627282930313233343536373839angular.module(&apos;techNodeApp&apos;).factory(&apos;server&apos;, [&apos;$cacheFactory&apos;, &apos;$q&apos;, &apos;$http&apos;, &apos;socket&apos;, function($cacheFactory, $q, $http, socket) &#123; var cache = window.cache = $cacheFactory(&apos;technode&apos;) socket.on(&apos;technode&apos;, function(data) &#123; switch (data.action) &#123; case &apos;getRoom&apos;: if (data._roomId) &#123; angular.extend(cache.get(data._roomId), data.data) &#125; else &#123; data.data.forEach(function (room) &#123; cache.get(&apos;rooms&apos;).push(room) &#125;) &#125; break // case something else // handle for socket events &#125; &#125;) socket.on(&apos;err&apos;, function (data) &#123; // handle server err &#125;) return &#123; validate: function() &#123; var deferred = $q.defer() $http(&#123; url: &apos;/api/validate&apos;, method: &apos;GET&apos; &#125;).success(function(user) &#123; angular.extend(cache.get(&apos;user&apos;), user) deferred.resolve() &#125;).error(function(data) &#123; deferred.reject() &#125;) return deferred.promise &#125; // more API &#125;&#125;]) 在server中，我们使用了两个Angular提供的组件，$q和$cacheFactory。 $q$q是Angular对JavaScript异步编程模式Promise的实现，参考了https://github.com/kriskowal/q 。在TechNode对它的用法相对比较简单，仅仅是将Ajax请求隐藏起来。以server.validate为例： 12345678910111213validate: function() &#123; var deferred = $q.defer() $http(&#123; url: &apos;/api/validate&apos;, method: &apos;GET&apos; &#125;).success(function(user) &#123; angular.extend(cache.get(&apos;user&apos;), user) deferred.resolve() &#125;).error(function(data) &#123; deferred.reject() &#125;) return deferred.promise&#125; $q.defer()获取一个differed（推迟）对象，然后return deferred.promise先返回promise（承诺），在服务器端成功返回后，resolve（兑现）承诺，或者遇到问题，reject（拒绝）兑现。 在technode.js中我们可以这样使用： 1234567server.validate().then(function() &#123; if ($location.path() === &apos;/login&apos;) &#123; $location.path(&apos;/rooms&apos;) &#125;&#125;, function() &#123; $location.path(&apos;/login&apos;)&#125;) server.validate()获取promise（承诺）对象，then(resolvedCallback, rejectCallack)（然后）根据承诺的兑现情况进行不同的处理。 换句话说，technode.js中的techNodeApp问server，用户是不是登录了，server必须调用服务端接口进行验证，因此server给techNodeApp许诺，techNodeApp则只需要针对许诺是否兑现进行处理就好了。 所有与http请求相关的接口，我们都做了相似的处理。 $cacheFactory$cacheFactory是Angular提供的缓存组件，该组件直接将数据存放在内存中。 123456789101112131415var cache = window.cache = $cacheFactory(&apos;technode&apos;)// ...cache.put(&apos;rooms&apos;, [])// ...cache.get(&apos;rooms&apos;) &amp;&amp; cache.get(&apos;rooms&apos;).forEach(function(room) &#123; if (room._id === _roomId) &#123; room.users = room.users.filter(function(user) &#123; return user._id !== _userId &#125;) &#125;&#125;) 直接调用$cacheFactory，传入cacheId，Angular就为我构造出一块缓存区域，我们就可以通过get、put等等方法来存储或者获取缓存数据了。 $cacheFactory还提供了一种TechNode中未使用的特性，即这块缓存可以是LRU的，什么是LRU？即这块缓存是有大小的（避免缓存开销过大，影响网易性能），并且这块缓存使用LRU算法来淘汰长时间未使用的数据。 controller与server有了server，我们来看看controller有什么变化？这是原来的RoomCtrl的代码： 12345678910111213141516171819202122angular.module(&apos;techNodeApp&apos;).controller(&apos;RoomCtrl&apos;, function($scope, $routeParams, $scope, socket) &#123; socket.on(&apos;rooms.read&apos; + $routeParams._roomId, function(room) &#123; $scope.room = room &#125;) socket.emit(&apos;rooms.read&apos;, &#123; _roomId: $routeParams._roomId &#125;) socket.on(&apos;messages.add&apos;, function(message) &#123; $scope.room.messages.push(message) &#125;) // ... socket.on(&apos;users.join&apos;, function (join) &#123; $scope.room.users.push(join.user) &#125;) socket.on(&apos;users.leave&apos;, function(leave) &#123; _userId = leave.user._id $scope.room.users = $scope.room.users.filter(function(user) &#123; return user._id != _userId &#125;) &#125;)&#125;) 这是基于server组件修改后的RoomCtrl： 123456angular.module(&apos;techNodeApp&apos;).controller(&apos;RoomCtrl&apos;, [&apos;$scope&apos;, &apos;$routeParams&apos;, &apos;$scope&apos;, &apos;server&apos;, function($scope, $routeParams, $scope, server) &#123; $scope.room = server.getRoom($routeParams._roomId) // ...&#125;]) 我们可以发现如下的变化： RoomCtrl不再直接与服务端通信读取当前的房间信息； 无需监听用户进入、离开或者新消息的事件。 RoomCtrl只需调用server.getRoom，传入房间的id即可。那房间信息不是需要到服务端读取么？这是怎么实现的？ 这完全得益于Angular数据绑定特性，即数据变化，视图也会跟着变化： 123456789101112131415getRoom: function(_roomId) &#123; if (!cache.get(_roomId)) &#123; cache.put(_roomId, &#123; users: [], messages: [] &#125;) socket.emit(&apos;technode&apos;, &#123; action: &apos;getRoom&apos;, data: &#123; _roomId: _roomId &#125; &#125;) &#125; return cache.get(_roomId)&#125; 这里的处理方式与promise有异曲同工之妙。getRoom方法，如果在缓存中没有找到房间的数据，就先新建一个房间对象，不过里面的数据都是空的（此时，RoomCtrl渲染出来的是一个空的房间视图），然后通过socket向服务端请求房间数据；如果找到就直接返回从缓存中获取的房间数据，RoomCtrl就可以渲染出来一个正常的房间视图。 而在服务端返回房间信息后， 12345678case &apos;getRoom&apos;: if (data._roomId) &#123; angular.extend(cache.get(data._roomId), data.data) &#125; else &#123; data.data.forEach(function (room) &#123; cache.get(&apos;rooms&apos;).push(room) &#125;) &#125; 我们使用服务端的数据填充到空房间即可，Angular即根据数据的变化，渲染出新的房间视图。 我们必须保证更新的房间对象必须是视图绑定的对象，因此我们一开始就返回一个房间对象，后面只是修改这个对象的属性。 同理，RoomCtrl也无需出来用户进入或者离开房间，有新消息这类事件，因为server组件会自动更新对应的数据，RoomCtrl只需要按照数据渲染即可。 好了，我们利用客户端缓存和Angular数据绑定特性，大大简化了TechNode控制器层。到此，我们的开发之旅已经接近尾声，接下来，我们将学习如何将前端程序打包，发布！ 使用Grunt打包TechNode开发时，为了解耦和便于维护，我们把代码拆成单独的文件，JavaScript代码、CSS代码和HTML都是单独的。在生产环境中，为了提高性能，我们需要把这些分开的文件合并到一起。如果你的网站使用CDN的化，我们还需要给每个版本的文件，添加上唯一的标识，便于维护CDN的缓存。 Grunt是目前JavaScript最流行的项目自动化构建工具。Grunt官方提供了很多插件，也有大量的第三方插件。我们可以轻松地使用Grunt检查、压缩合并代码，甚至发布应用程序。我们将基于grunt-usemin等几个流行的Grunt插件来构建TechNode项目。 首先我们需要做一些准备，安装Grunt命令行和运行时，在TechNode根目录新建Gruntfile.js。 1npm install -g grunt-cli &amp;&amp; npm install grunt --save-dev &amp;&amp; touch Gruntfile.js 为了使用grunt-usemin来压缩我们的代码，我们需要在index.html添加一些特殊的注释来来帮助grunt-usemin找到需要合并的文件： 12345678910111213141516171819202122232425262728&lt;!-- build:css /css/technode.css --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/components/bootstrap/dist/css/bootstrap.min.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/styles/style.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/styles/login.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/styles/rooms.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/styles/room.css&quot;&gt;&lt;!-- endbuild --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;&lt;!-- build:js /script/technode.js --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/components/jquery/jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/components/bootstrap/dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/components/angular/angular.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/components/angular-route/angular-route.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/components/moment/moment.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/components/angular-moment/angular-moment.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/components/moment/lang/zh-cn.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/technode.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/services/socket.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/services/server.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/router.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/directives/auto-scroll-to-bottom.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/directives/ctrl-enter-break-line.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/controllers/login.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/controllers/rooms.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/controllers/room.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/controllers/message-creator.js&quot;&gt;&lt;/script&gt;&lt;!-- endbuild --&gt; 我们分别在css和javascript的引用周围加上了注释，&lt;!-- build:css /css/technode.css --&gt;标明我们需要把下面这些css都合并到technode.css这个文件中，javascript全都合并到technode.js中。 注意，socket.io.js这个文件并没有包含进来，因为它是socket.io自己输出的，并没有在我们的自己的源码中。当然，我们甚至可以把这个文件保存到源码中，自己引用也是可以的。 首先使用grunt-contrib-copy将不需要打包压缩的文件拷贝到build目录中，修改Gruntfile.js 123456789101112131415161718module.exports = function (grunt) &#123; grunt.initConfig(&#123; copy: &#123; main: &#123; files: [ &#123;expand: true, cwd: &apos;static/components/bootstrap/dist/fonts/&apos;, src: [&apos;**&apos;], dest: &apos;build/fonts&apos;&#125;, &#123;&apos;build/index.html&apos;: &apos;static/index.html&apos;&#125;, &#123;&apos;build/favicon.ico&apos;: &apos;static/favicon.ico&apos;&#125; ] &#125; &#125; &#125;) grunt.loadNpmTasks(&apos;grunt-contrib-copy&apos;) grunt.registerTask(&apos;default&apos;, [ &apos;copy&apos; ])&#125; grunt-usemin为我们提供了一个useminPrepare的task，这个task就是基于我们在index.html文件中的配置，自动生成合并和压缩代码的配置： 1234567891011121314151617181920212223242526module.exports = function (grunt) &#123; grunt.initConfig(&#123; copy: &#123; main: &#123; files: [ &#123;expand: true, cwd: &apos;static/components/bootstrap/dist/fonts/&apos;, src: [&apos;**&apos;], dest: &apos;build/fonts&apos;&#125;, &#123;&apos;build/index.html&apos;: &apos;static/index.html&apos;&#125;, &#123;&apos;build/favicon.ico&apos;: &apos;static/favicon.ico&apos;&#125; ] &#125; &#125;, useminPrepare: &#123; html: &apos;static/index.html&apos;, options: &#123; dest: &apos;build&apos; &#125; &#125; &#125;) grunt.loadNpmTasks(&apos;grunt-usemin&apos;) grunt.loadNpmTasks(&apos;grunt-contrib-copy&apos;) grunt.registerTask(&apos;default&apos;, [ &apos;copy&apos;, &apos;useminPrepare&apos; ])&#125; npm install grunt-usemin --save-dev，运行grunt试试看： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Running &quot;useminPrepare:html&quot; (useminPrepare) taskGoing through static/index.html to update the configLooking for build script HTML comment blocksConfiguration is now: concat: &#123; generated: &#123; files: [ &#123; dest: &apos;.tmp/concat/css/technode.css&apos;, src: [ &apos;static/components/bootstrap/dist/css/bootstrap.min.css&apos;, &apos;static/styles/style.css&apos;, &apos;static/styles/login.css&apos;, &apos;static/styles/rooms.css&apos;, &apos;static/styles/room.css&apos; ] &#125;, &#123; dest: &apos;.tmp/concat/script/technode.js&apos;, src: [ &apos;static/components/jquery/jquery.js&apos;, &apos;static/components/bootstrap/dist/js/bootstrap.min.js&apos;, &apos;static/components/angular/angular.js&apos;, &apos;static/components/angular-route/angular-route.js&apos;, &apos;static/components/moment/moment.js&apos;, &apos;static/components/angular-moment/angular-moment.js&apos;, &apos;static/components/moment/lang/zh-cn.js&apos;, &apos;static/technode.js&apos;, &apos;static/services/socket.js&apos;, &apos;static/services/server.js&apos;, &apos;static/router.js&apos;, &apos;static/directives/auto-scroll-to-bottom.js&apos;, &apos;static/directives/ctrl-enter-break-line.js&apos;, &apos;static/controllers/login.js&apos;, &apos;static/controllers/rooms.js&apos;, &apos;static/controllers/room.js&apos;, &apos;static/controllers/message-creator.js&apos; ] &#125; ] &#125; &#125; uglify: &#123; generated: &#123; files: [ &#123; dest: &apos;build/script/technode.js&apos;, src: [ &apos;.tmp/concat/script/technode.js&apos; ] &#125; ] &#125; &#125; cssmin: &#123; generated: &#123; files: [ &#123; dest: &apos;build/css/technode.css&apos;, src: [ &apos;.tmp/concat/css/technode.css&apos; ] &#125; ] &#125; &#125; 它为我们生成了本来需要手动编写的其他task的配置，接下来，安装其他几个需要的grunt task，继续修改Gruntfile.js： 1234567891011121314151617181920212223242526272829303132module.exports = function (grunt) &#123; grunt.initConfig(&#123; copy: &#123; main: &#123; files: [ &#123;expand: true, cwd: &apos;static/components/bootstrap/dist/fonts/&apos;, src: [&apos;**&apos;], dest: &apos;build/fonts&apos;&#125;, &#123;&apos;build/index.html&apos;: &apos;static/index.html&apos;&#125;, &#123;&apos;build/favicon.ico&apos;: &apos;static/favicon.ico&apos;&#125; ] &#125; &#125;, useminPrepare: &#123; html: &apos;static/index.html&apos;, options: &#123; dest: &apos;build&apos; &#125; &#125; &#125;) grunt.loadNpmTasks(&apos;grunt-usemin&apos;) grunt.loadNpmTasks(&apos;grunt-contrib-copy&apos;) grunt.loadNpmTasks(&apos;grunt-contrib-concat&apos;) grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;) grunt.loadNpmTasks(&apos;grunt-contrib-cssmin&apos;) grunt.registerTask(&apos;default&apos;, [ &apos;copy&apos;, &apos;useminPrepare&apos;, &apos;concat&apos;, &apos;uglify&apos;, &apos;cssmin&apos; ])&#125; 安装好新的依赖，再运行grunt试试看。首先concat根据useminPrepare生成的配置，将css和js分别合并到.tmp/concat/css/technode.css和.tmp/concat/script/technode.js中；然后uglify和cssmin分别将这两个文件压缩成了build/css/technode.css和build/script/technode.js，我们的css文件和js文件就打包压缩好了。 除此之外我们还需要把pages中的html内联到index.html中。在Angular中，我们既可以将模板文件单独放在不同的html文件中，也可以像下面这样，内联在html中： 123456789&lt;script type=&quot;text/ng-template&quot; id=&quot;/pages/login.html&quot;&gt;&lt;form class=&quot;form-inline form-login&quot; ng-submit=&quot;login()&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot;&gt;Gmail&lt;/label&gt; &lt;input type=&quot;email&quot; required class=&quot;form-control&quot; ng-model=&quot;email&quot; placeholder=&quot;Gmail账号&quot; /&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-enter&quot;&gt;进入&lt;/button&gt;&lt;/form&gt;&lt;/script&gt; grunt-inline-angular-templates就可以实现这样的需求： 1234567891011inline_angular_templates: &#123; dist: &#123; options: &#123; base: &apos;static/&apos;, prefix: &apos;/&apos; &#125;, files: &#123; &apos;build/index.html&apos;: [&apos;static/pages/*.html&apos;] &#125; &#125;&#125; 使用grunt-rev，为静态文件加上唯一标识，使用grunt-contrib-clean在每次打包开始时，清除.tmp和build里的内容： 1234567891011121314151617rev: &#123; options: &#123; encoding: &apos;utf8&apos;, algorithm: &apos;md5&apos;, length: 8 &#125;, assets: &#123; files: [&#123; src: [ &apos;build/**/*.&#123;jpg,jpeg,gif,png,js,css,eot,svg,ttf,woff&#125;&apos; ] &#125;] &#125;&#125;,clean: &#123; main:[&apos;.tmp&apos;, &apos;build&apos;]&#125; 最后，使用grunt-usemin提供的task usemin，将html中标记的合并区块已经css中的字体引用使用build目录中对应的压缩做了唯一标记的文件名替换掉： 1234567891011grunt.registerTask(&apos;default&apos;, [ &apos;clean&apos;, &apos;copy&apos;, &apos;useminPrepare&apos;, &apos;concat&apos;, &apos;uglify&apos;, &apos;cssmin&apos;, &apos;rev&apos;, &apos;usemin&apos;, &apos;inline_angular_templates&apos;]) 于是我们整个构建的过程结束了，所有文件都按照我们想要的方式处理好了。 我们再来回顾一下打包的过程，开始那么多的js，首先被concat到了tmp/concat/technode.js中，然后aglify压缩到build/script/tecnhode.js中，接着rev根据文件内容为其生成了唯一的标示7add9650.technode.js，最后，usemin再把build/index.html中的js区块换成了&lt;script src=&quot;/script/7add9650.technode.js&quot;&gt;&lt;/script&gt;。这就是我们采用的整个打包压缩过程。同理css也是如此。 发布TechNode发布之前我们还需要做一些准备工作，我们需要让生产环境中访问的是打包压缩过的静态文件，express为我们提供了一种区分开发环境和生产环境的方式： 123456789app.configure(&apos;development&apos;, function () &#123; app.set(&apos;staticPath&apos;, &apos;/static&apos;)&#125;)app.configure(&apos;production&apos;, function () &#123; app.set(&apos;staticPath&apos;, &apos;/build&apos;)&#125;)app.use(express.static(__dirname + app.get(&apos;staticPath&apos;))) 如果我们运行node app.js express默认采用的是development环境，我们可以使用NODE_ENV=production node app.js来启用生产环境的配置，我们这里的做法很简单，将静态文件的路径指定到编译后的/build目录即可。 修改config.js中的MongoDB配置，修改成对应的你在MongoHQ的数据库，例如：mongodb://technode:technode@troup.mongohq.com:10046/technode 修改开发环境对应的Procfile文件，添加web: NODE_ENV=production node app.js，让TechNode以生产模式启动。","categories":[{"name":"开发","slug":"开发","permalink":"https://sensitivemix.github.io/categories/开发/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://sensitivemix.github.io/tags/Node-js/"},{"name":"Socket.io","slug":"Socket-io","permalink":"https://sensitivemix.github.io/tags/Socket-io/"}]},{"title":"如何用 Node.js Cluster，监听异常的邮件提醒服务","slug":"如何用 Node.js Cluster，监听异常的邮件提醒服务","date":"2017-06-11T14:24:57.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2017/06/11/如何用 Node.js Cluster，监听异常的邮件提醒服务/","link":"","permalink":"https://sensitivemix.github.io/2017/06/11/如何用 Node.js Cluster，监听异常的邮件提醒服务/","excerpt":"","text":"12345 __ __ __ _ __ ____ ____ ____/ /__ _____/ /_ _______/ /____ _____ ___ ____ ___ ____ _(_) / / __ \\/ __ \\/ __ / _ \\______/ ___/ / / / / ___/ __/ _ \\/ ___/_____/ _ \\/ __ `__ \\/ __ `/ / / / / / / /_/ / /_/ / __/_____/ /__/ / /_/ (__ ) /_/ __/ / /_____/ __/ / / / / / /_/ / / //_/ /_/\\____/\\__,_/\\___/ \\___/_/\\__,_/____/\\__/\\___/_/ \\___/_/ /_/ /_/\\__,_/_/_/ A module for taking advantage of the built-in cluster module in node v0.8 and above.send email if cluster exception,you will recieve a detail email about worker exception. Installation1npm install https://github.com/sunNode/node-cluster-email UsageInitialize mail plugin with the given email(s), with the given options. Options: from sender email timeout sendmail timeout in milliseconds subject defaulting to “cluster({worker}) exception: {message}” template function called with local variables (usually jade / ejs template etc) Example12345678910111213141516171819202122232425262728const cluster = require('cluster')const cpu = require ('os').cpus().lengthconst mail = require('node-cluster-mail')/** * [if description] * @param &#123;[type]&#125; cluster.isMaster [description] * @return &#123;[type]&#125; [description] */if (cluster.isMaster) &#123; // Fork workers. for (let i = 0; i &lt; cpu; i++) &#123; cluster.fork(); &#125; cluster.on('exit', function(worker, code, signal) &#123; mail('phonenix@gmail.com',&#123;'from':'phonenix-test@gmail.com','cc':'phonenix-test2@gmail.com'&#125;) console.log('worker ' + worker.process.pid + ' died'); &#125;); cluster.on('fork', function(worker) &#123; console.log(`workers: $&#123;worker.id&#125; worker.process.pid :$&#123;worker.process.pid&#125;`)&#125;);&#125; else &#123; // Workers can share any TCP connection // In this service its a restify server require('./app')&#125; Referencenode-cluster-email","categories":[{"name":"开发","slug":"开发","permalink":"https://sensitivemix.github.io/categories/开发/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://sensitivemix.github.io/tags/Node-js/"},{"name":"Cluster","slug":"Cluster","permalink":"https://sensitivemix.github.io/tags/Cluster/"}]},{"title":"基于 Node.js 构建微服务中的 MockService","slug":"基于 Node.js 构建微服务中的 MockService","date":"2017-06-11T14:23:55.000Z","updated":"2019-04-14T02:29:42.000Z","comments":true,"path":"2017/06/11/基于 Node.js 构建微服务中的 MockService/","link":"","permalink":"https://sensitivemix.github.io/2017/06/11/基于 Node.js 构建微服务中的 MockService/","excerpt":"","text":"缘起由于现在微服务越来越火了，越来越多的微服务融入到了日常开发当中。在开发微服务的时候，经常会遇到一个问题由于依赖于其他服务，导致你的进度受到阻碍。使你不得不先mock出你期望调用依赖服务的输出，来继续迭代开发。大部分情况下我们写在我们自己的服务中，因为这样方便省事，但是随着需要mock的服务越来越多，会发现越来越难管理，开发重构成本变高，于是在此基础上封装了一个基于Node.js可以根据配置文件生成Mock服务。 缘生为了方便添加和删除不同的mock服务，将所有的mock服务写入了配置文件，你可以根据你所定义的配置文件生成mock服务，如下所示： 1234567891011121314151617181920212223242526&#123; 'PATH':'./src/mocks', 'PORT':'9001', \"SERVICES\":[ &#123; \"name\": \"authorization\", \"Handlers\": [ &#123; \"method\": \"GET\", \"resHeader\": \"HTTP/1.1 200 OK\", \"resContent\": \"&#123; succeed: true,msg: ok &#125;\" &#125;, &#123; \"method\": \"POST\", \"resHeader\": \"HTTP/1.1 200 OK\", \"resContent\": \"&#123; succeed: true,msg: ok &#125;\" &#125;, &#123; \"method\": \"GET--a=b.mock\", \"resHeader\": \"HTTP/1.1 200 OK\", \"resContent\": \"&#123; succeed: true,msg: ok &#125;\" &#125; ] &#125; ]&#125; Options: method Request Method GET--a=b.mock Request GET /hello?a=b resHeader Response Header resContent Response Content npm run mock Generate Mock Server npm run clean Clean Mock Server 配置文件中的PATH是你存放的所有mock服务文件夹，填入请求的方式，以及期望的访问的HTTP状态和返回值。启动mock服务器，一个简单的mock服务就生成了。修改文件配置以后，可以清理生成的mock服务重新生成。 项目结构 启动截图 生成成功 清理截图 项目地址 node-mock-factory","categories":[{"name":"开发","slug":"开发","permalink":"https://sensitivemix.github.io/categories/开发/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://sensitivemix.github.io/tags/Node-js/"},{"name":"MockService","slug":"MockService","permalink":"https://sensitivemix.github.io/tags/MockService/"}]}]}