<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙祁的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sensitivemix.github.io/"/>
  <updated>2019-04-16T09:03:02.000Z</updated>
  <id>https://sensitivemix.github.io/</id>
  
  <author>
    <name>孙祁</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何书写 Node DEV API 文档 </title>
    <link href="https://sensitivemix.github.io/2019/04/16/%E5%A6%82%E4%BD%95%E4%B9%A6%E5%86%99-Node-DEV-API-%E6%96%87%E6%A1%A3/"/>
    <id>https://sensitivemix.github.io/2019/04/16/如何书写-Node-DEV-API-文档/</id>
    <published>2019-04-16T09:02:20.000Z</published>
    <updated>2019-04-16T09:03:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要-API-文档"><a href="#为什么需要-API-文档" class="headerlink" title="为什么需要 API 文档"></a>为什么需要 API 文档</h2><p>目前大的环境下面，基本服务都以单体服务转换成前后端分离的服务，客户端作为调用方，服务端作为提供方需要给予到调用方通俗易懂的文档。</p><h2 id="常见-API-文档有哪些"><a href="#常见-API-文档有哪些" class="headerlink" title="常见 API 文档有哪些"></a>常见 API 文档有哪些</h2><ol><li><a href="https://github.com/GitbookIO/gitbook" target="_blank" rel="noopener">gitbook</a><blockquote><p>Modern documentation format and toolchain using Git and Markdown </p></blockquote></li></ol><p><img src="https://uploader.shimo.im/f/45J30B4D0d4L7CWC.png!thumbnail" alt="图片"></p><ul><li><a href="https://github.com/GitbookIO/gitbook/blob/master/docs/setup.md" target="_blank" rel="noopener">Usage</a></li><li>优点：<ul><li>类似书籍的管理方式（适合写书）</li><li>支持多人协作，支持保存在 Github 中</li><li>支持 Build 成静态网页，部署方便</li></ul></li><li>缺点：<ul><li>需要熟悉 <strong>Markdown </strong>语法，不是实时生成，需要使用 <a href="https://github.com/GitbookIO/gitbook-cli" target="_blank" rel="noopener">Git-cli</a> 打包文件</li><li>以一本书籍作为起点，只能放到单个项目中</li></ul></li><li>总结：适合写书籍，不太适合 API 开发文档</li></ul><ol start="2"><li><a href="https://github.com/jsdoc3/jsdoc" target="_blank" rel="noopener">jsdoc</a><blockquote><p>An API documentation generator for JavaScript.</p></blockquote></li></ol><p><img src="https://uploader.shimo.im/f/UyoiKuM54H08ylGa.png!thumbnail" alt="图片"></p><ul><li><a href="http://usejsdoc.org/" target="_blank" rel="noopener">Usage</a></li><li>优点：<ul><li>功能丰富，支持引入块状注释（<a href="https://www.html.cn/doc/jsdoc/tags-example.html" target="_blank" rel="noopener">Block Tags</a>）</li><li>功能丰富，支持内联注释（<a href="https://www.html.cn/doc/jsdoc/tags-inline-link.html" target="_blank" rel="noopener">Inline Tags</a>）</li><li>强大的社区支持，各个平台支持 jsdocs 插件</li></ul></li><li>缺点：<ul><li>有一定的学习成本，需要学习它的块状注释使用方式</li><li>UI 只能单项目使用，每个项目的 DOC UI 独立 </li></ul></li><li>在线样例（<a href="https://github.com/SoftwareBrothers/better-docs" target="_blank" rel="noopener">b</a><a href="https://softwarebrothers.github.io/admin-bro-dev/index.html" target="_blank" rel="noopener">etter-</a><a href="https://github.com/SoftwareBrothers/better-docs" target="_blank" rel="noopener">d</a><a href="https://github.com/SoftwareBrothers/better-docs" target="_blank" rel="noopener">ocs</a> <a href="https://nhnent.github.io/tui.jsdoc-template/latest/" target="_blank" rel="noopener">tui-jsdoc-template</a>)</li><li>总结：适合深度定制项目，比如说我们对外开放 API 给开发者使用。</li></ul><ol start="3"><li><a href="https://github.com/Surnet/swagger-jsdoc" target="_blank" rel="noopener">swagger-jsdoc</a><blockquote><p>Generates swagger doc based on JSDoc.</p></blockquote></li></ol><p><img src="https://uploader.shimo.im/f/fHtWq6Xh6gcnZNZm.png!thumbnail" alt="图片"></p><ul><li><a href="https://github.com/Surnet/swagger-jsdoc/tree/master/example/v2" target="_blank" rel="noopener">Usage</a></li><li>优点：<ul><li>集合 Swagger，支持按照类似 JSDoc 方式生成文档</li><li>支持错误定位，如果注释书写错误，能够抛出具体的错误栈</li><li>支持 <a href="https://github.com/Surnet/swagger-jsdoc/blob/master/docs/CLI.md" target="_blank" rel="noopener">CLI</a>，自由选择文件输出位置</li></ul></li><li>缺点：<ul><li>书写格式不友好，强格式要求，对于新手来说不容易上手，官方样例较少，很多语法需要对于 Swagger YAML 格式，自己理解进行映射</li><li>没有能够完成安装 JSDoc 格式来书写注释，更倾向于 YAML 文件</li></ul></li></ul><ol start="4"><li><a href="https://github.com/SensitiveMix/doc-generators" target="_blank" rel="noopener">doc-generators</a><blockquote><p>simple generator handler for swagger</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @typedef Product</span><br><span class="line"> * @property &#123;integer&#125; id</span><br><span class="line"> * @property &#123;string&#125; name.required - Some description for product</span><br><span class="line"> * @property &#123;Array.&lt;Point&gt;&#125; Point</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * This function comment is parsed by doctrine</span><br><span class="line"> * sdfkjsldfkj</span><br><span class="line"> * @route POST /users</span><br><span class="line"> * @param &#123;Point.model&#125; point.body.required - the new point</span><br><span class="line"> * @group foo - Operations about user</span><br><span class="line"> * @param &#123;string&#125; email.query.required - username or email</span><br><span class="line"> * @param &#123;string&#125; password.query.required - user&apos;s password.</span><br><span class="line"> * @param &#123;enum&#125; status.query.required - Status values that need to be considered for filter - eg: available,pending</span><br><span class="line"> * @operationId retrieveFooInfo</span><br><span class="line"> * @produces application/json application/xml</span><br><span class="line"> * @consumes application/json application/xml</span><br><span class="line"> * @returns &#123;Response.model&#125; 200 - An array of user info</span><br><span class="line"> * @returns &#123;Product.model&#125;  default - Unexpected error</span><br><span class="line"> * @returns &#123;Array.&lt;Point&gt;&#125; Point - Some description for point</span><br><span class="line"> * @headers &#123;integer&#125; 200.X-Rate-Limit - calls per hour allowed by the user</span><br><span class="line"> * @headers &#123;string&#125; 200.X-Expires-After - date in UTC when token expires</span><br><span class="line"> * @security JWT</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></blockquote></li></ol><ul><li><a href="https://github.com/SensitiveMix/doc-generators/blob/master/example/router.js" target="_blank" rel="noopener">Usage</a></li><li>优点：<ul><li>支持集成 Swagger，支持按照类似 JSDoc 方式生成文档</li><li>友好的文档的注释，贴合 IDE 函数注释</li></ul></li><li>缺点：<ul><li>实现可用的基础上，需要支持到 IDE，方便一键生成，支持自动化<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * verify quarantine site</span><br><span class="line"> * @route POST /ui/quarantine/v1/verify_od_dedicated_quarantine_site</span><br><span class="line"> * @group quarantine</span><br><span class="line"> * @param &#123;QuarantineJSON.model&#125; body.body.required - post body</span><br><span class="line"> * @returns &#123;object&#125; 200 - An array of handler info</span><br><span class="line"> * @returns &#123;Error&#125; 400 - invalid site</span><br><span class="line"> * @returns &#123;Error&#125; 500 - internal error</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * JSON parameters require a model. This one just has &quot;name&quot;</span><br><span class="line"> * @typedef QuarantineJSON</span><br><span class="line"> * @property &#123;string&#125; site.required - quarantine site info</span><br><span class="line"> */</span><br><span class="line">    server.post(&apos;/ui/quarantine/v1/verify_od_dedicated_quarantine_site&apos;, middleware.other.verifyLoginInfo,</span><br><span class="line">        rbac.quarantine.write, quarantine.verifyOdDedicatedQuarantineSite);</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * HTTP API statistics</span><br><span class="line"> * @route GET /monit/v1/metric</span><br><span class="line"> * @group monit</span><br><span class="line"> * @param &#123;string&#125; sort.query - asc | desc</span><br><span class="line"> * @param &#123;string&#125; direction.query - count | avarageMillisecondCost | routeName</span><br><span class="line"> * @returns &#123;object&#125; 200 - An array of user info</span><br><span class="line"> * @returns &#123;metrics.model&#125; default - Unexpected error</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @typedef metrics</span><br><span class="line"> * @property &#123;string&#125; routeName.required - &apos;getuiadminv1company_plans&apos;</span><br><span class="line"> * @property &#123;number&#125; count.required - route invoke times</span><br><span class="line"> * @property &#123;number&#125; avarageMillisecondCost.required - route avg second cost</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">server.get(&quot;/monit/v1/metric&quot;, validator.query(&#123;</span><br><span class="line">    type: &apos;object&apos;,</span><br><span class="line">    properties: &#123;</span><br><span class="line">        sort: &#123; type: &apos;string&apos;, enum: [&apos;count&apos;] &#125;,</span><br><span class="line">        direction: &#123; type: &apos;string&apos;, enum: [&apos;asc&apos;, &apos;desc&apos;] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;), monitService.apiMetricHandlers);</span><br></pre></td></tr></table></figure><p>项目地址：<a href="https://github.com/SensitiveMix/doc-generators" target="_blank" rel="noopener">https://github.com/SensitiveMix/doc-generators</a><br>喜欢的同学请点个 Star 😆</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么需要-API-文档&quot;&gt;&lt;a href=&quot;#为什么需要-API-文档&quot; class=&quot;headerlink&quot; title=&quot;为什么需要 API 文档&quot;&gt;&lt;/a&gt;为什么需要 API 文档&lt;/h2&gt;&lt;p&gt;目前大的环境下面，基本服务都以单体服务转换成前后端分离的服务
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://sensitivemix.github.io/tags/Node-js/"/>
    
      <category term="Swagger Doc" scheme="https://sensitivemix.github.io/tags/Swagger-Doc/"/>
    
  </entry>
  
  <entry>
    <title>数据库原理</title>
    <link href="https://sensitivemix.github.io/2019/01/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
    <id>https://sensitivemix.github.io/2019/01/07/数据库原理/</id>
    <published>2019-01-07T14:08:33.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>事务<br>概念：事务指的是满足 ACID 特性到一组操作，可以通过 commit 提交事务，也可以使用 rollback 进行回滚。</p><p><img src="https://uploader.shimo.im/f/wK9AMcadwgsMzbrP.png!thumbnail" alt="图片"></p><p><strong>1. 原子性（Atomicity）</strong><br>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。<br>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><p><strong>2. 一致性（Consistency）</strong><br>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><p><strong>3. 隔离性（Isolation）</strong><br>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><p><strong>4. 持久性（Durability）</strong><br>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>使用重做日志来保证持久性。</p><p>AUTOCOMMIT</p><p>Mysql 采用自动提交的方式，如果没有特殊设置事务级别，每个查询都会当做一个事务来提交。</p><p>并发一致性问题</p><ol><li><p><strong>丢失修改</strong></p><p> T1 和 T2 两个事务都对数据进行了修改，T1 先修改，T2 再修复，这样 T2 就可能覆盖 T1 的数据<br><img src="https://uploader.shimo.im/f/DJvWdegkPLIIYzXw.png!thumbnail" alt="图片"></p></li><li><p><strong>脏读</strong></p><p> T1 通过事务对数据进行了更改，T2 读取了数据，这时候 T1 撤销了更改，这样 T2 读取的数据就是脏数据<br><img src="https://uploader.shimo.im/f/H220cdPI0TEGw5AX.png!thumbnail" alt="图片"></p></li><li><p><strong>不可重复读</strong></p><p> T2 读取了数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不一样。<br><img src="https://uploader.shimo.im/f/EuoHic3Uh14wl1xx.png!thumbnail" alt="图片"></p></li><li><p><strong>幻影读</strong></p><p> T1 读取某个范围的数据，T2 往这个范围中插入数据，T1 再次读取的时候和第一次读取的结果不一样。<br><img src="https://uploader.shimo.im/f/Yyji5JUWT10qOsnQ.png!thumbnail" alt="图片"><br>产生并发不一致的主要原因是破坏了事务的隔离性，解决办法是通过对并发进行控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁实现需要用户自己控制，相当的负责。所以数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;事务&lt;br&gt;概念：事务指的是满足 ACID 特性到一组操作，可以通过 commit 提交事务，也可以使用 rollback 进行回滚。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://uploader.shimo.im/f/wK9AMcadwgsMzbrP.png!thu
      
    
    </summary>
    
      <category term="数据库" scheme="https://sensitivemix.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Database" scheme="https://sensitivemix.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>如何设计关系型数据库</title>
    <link href="https://sensitivemix.github.io/2019/01/06/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://sensitivemix.github.io/2019/01/06/如何设计关系型数据库/</id>
    <published>2019-01-06T07:33:07.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RDBMS"><a href="#RDBMS" class="headerlink" title="RDBMS"></a>RDBMS</h3><p>从 0 到 1 设计关系型数据库，总共分为两个部分：</p><ul><li><p>程序实例</p><ul><li>存储管理模块</li><li>缓存模块（需要设计淘汰机制</li><li>SQL 解析</li><li>日志管理（记录所有操作）</li><li>权限划分（授权模块）</li><li>容灾机制（保证数据库高可用）</li><li>索引管理（保证数据查询执行效率）</li><li>锁管理（保证数据 ACID）</li></ul></li><li><p>存储模块</p><ul><li>文件系统（保证数据持久化）   </li></ul></li></ul><h3 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h3><p><strong>为什么使用索引</strong></p><ol><li>快速查询数据，避免全表扫描，提升检索效率 </li></ol><p><strong>什么样的信息可以成为索引</strong></p><ol><li>主键和唯一键可以作为索引</li></ol><p><strong>索引的数据结构</strong></p><ol><li>生成索引，建立<strong>二叉查找树</strong>进行二分查找 </li><li>生成索引，建立 <strong>B-Tr    ee</strong> 结构进行查找<ol><li>根结点至少包含两个孩子、终端节点位于同一层、树中每个节点最多含有 m 个孩子（m &gt;+ 2）、除了根节点和叶节点外，其他每个节点至少有 ceil(m/2) 个孩子）通过合并、分裂来保持结构，层数不会变深</li></ol></li><li>生成索引，建立 <strong>B+- Tree</strong> 进行查找<ol><li>非叶子节点关键字和指针个数一样</li><li>非叶子节点的子数指针 P[i]，指向关键字值[K[i], K[i+1]] 的子树</li><li>非叶子节点仅用来索引，数据都保存在叶子节点中</li><li>所有叶子节点均有一个链指针指向下一个叶子节点（方便统计和查询）</li><li>优点<ol><li>磁盘读写代价更低</li><li>查询效率更加稳定 logn</li><li>有利于对数据库的扫描</li></ol></li></ol></li><li>生成索引，建立 Hash 结构进行查找<ol><li>无法避免全表扫描</li><li>只能做 ‘=’ ‘in’ 等操作，无法做范围查询（hash 之后无法保证值的大小）</li><li>无法用于排序操作</li><li>不能利用部分索引键做查询</li><li>hash 值重复率较高的情况下，效率没有 B Tree 效率高（不稳定）</li></ol></li><li>bitMap （位图）<ol><li>只有几种值的时候（男，女），纯 CPU 叠加操作</li><li>缺点，锁的粒度大，不适用高并发的系统，适合统计较多的系统</li></ol></li></ol><p><strong>密集索引和稀疏索引的区别</strong></p><ol><li>密集索引的文件中每个搜索码值都对应一个索引值</li><li>稀疏索引文件只为索引码的某些值建立索引项 </li></ol><p><strong>InnoDB</strong></p><ol><li>若一个索引被定义，则这个索引被定义为密集索引</li><li>若没有索引被定义，该表的第一个唯一非空索引则作为密集索引</li><li>若不满足上述条件，内部会自己生成一个隐藏主键</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;RDBMS&quot;&gt;&lt;a href=&quot;#RDBMS&quot; class=&quot;headerlink&quot; title=&quot;RDBMS&quot;&gt;&lt;/a&gt;RDBMS&lt;/h3&gt;&lt;p&gt;从 0 到 1 设计关系型数据库，总共分为两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;程序实例&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://sensitivemix.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Database" scheme="https://sensitivemix.github.io/tags/Database/"/>
    
      <category term="MongoDB" scheme="https://sensitivemix.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Redis 的持久和取舍</title>
    <link href="https://sensitivemix.github.io/2019/01/01/Redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%92%8C%E5%8F%96%E8%88%8D/"/>
    <id>https://sensitivemix.github.io/2019/01/01/Redis-的持久和取舍/</id>
    <published>2019-01-01T13:32:37.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><h3 id="持久化的作用"><a href="#持久化的作用" class="headerlink" title="持久化的作用"></a>持久化的作用</h3><ul><li><p>什么是持久化</p><ul><li>所有的数据都保存在内存中，重启会造成数据丢失，所以需要对数据的更新将异步保存在磁盘中</li></ul></li><li><p>主流数据库的持久化方式</p><ul><li>快照（mysql dump）</li><li>写日志（Mysql Binlog、MongoDB oplog、HBase Hlog）</li></ul></li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><ul><li><p>什么是 RDB</p><ul><li><p>Redis 存取快照，一般是 RDB 二进制文件，当重启的时候，Redis 重新载入这个快照，做到数据不丢失</p></li><li><p>缓存名称， dbfilename dump.rdb，常用命名 dbfilename dump-${port}.rdb</p></li><li><p>存储位置，dir ./，需要考虑到分盘</p></li></ul></li><li><p>触发机制 - 主要三种方式</p><ul><li><p>save，同步命令，排队执行，容易造成阻塞；文件策略，新文件替换老的文件，复杂度 O(n)，不消耗额外内存；</p></li><li><p>bgsave，异步命令，后台执行；fork（阻塞发生在 fork） 子进程来执行操作；文件策略，新文件替换老的文件，复杂度 O(n)，缺点是消耗额外内存用于 fork</p></li><li><p>auto，自动执行（save 60 10000）60 秒钟改变 10000 数据，自动生成 RDB 文件；</p></li></ul></li><li><p>触发机制 - 不可忽略的方式</p><ul><li><p>全量复制，适用于主从复制场景，主会自动生成 RDB 文件</p></li><li><p>debug reload，不需要清空重启，触发 RDB 文件生成</p></li><li><p>shutdown，shutdown save 生成 RDB 文件</p></li></ul></li></ul><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><ul><li><p>RDB 现存问题</p><ul><li>耗时耗性能，O（n）数据，fork() 消耗内存；copy-on-write 策略；Disk I/O 性能损耗</li><li>不可控，易丢失数据，宕机丢失数据</li></ul></li><li><p>什么是AOF</p><ul><li>根据写入命令写入日志文件中，实时监控写入</li></ul></li><li><p>三种策略</p><ul><li><p>always，写在缓冲区中，每条命令 fsync 到磁盘，缺点 IO 开销大，优点不丢失数据</p></li><li><p>everysec，每秒写入磁盘中，容易丢失一秒的数据</p></li><li><p>no，操作系统来决定什么时候该 fsync 到磁盘，缺点不可控，优点就是不用管</p></li></ul></li><li><p>重写</p><ul><li><p>老的方式出现文件逐渐变大的问题，重写回 REDIS 会非常慢，针对这个问题提供了重写的功能，合并命令，几条命令合并成一条命令；过期的也不会写入新的文件；优点减少磁盘占用量，加速恢复速度</p></li><li><p>bgwriteof，fork 出子进程来重写，在内存进行重写</p></li></ul></li><li><p>配置</p><ul><li><p>auto-aof-rewrite-min-size（重写尺寸)</p></li><li><p>auto-aof-rewrite-percentage （文件增长率）</p></li><li><p>aof_current_size （当前尺寸）</p></li><li><p>aof_base_size （上次启动和重写的尺寸）</p></li></ul></li></ul><h3 id="RDB-和-AOF-抉择"><a href="#RDB-和-AOF-抉择" class="headerlink" title="RDB 和 AOF 抉择"></a>RDB 和 AOF 抉择</h3><ul><li>比较</li></ul><table><thead><tr><th>命令</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr><tr><td>轻重</td><td>重</td><td>轻</td></tr></tbody></table><ul><li><p>RDB 最佳策略</p><ul><li>“关”，默认不开启（主从关闭掉），全量复制需要这个策略</li><li>集中管理，对数据备份有一定作用</li><li>主从，从开，保存历史文件（从节点不进行读写），不适合频繁读写，对磁盘存在影响</li></ul></li><li><p>AOF 最佳策略</p><ul><li>“开” 缓存和存储，对数据源没有很大</li><li>重写集中管理，单机多部署，60-70% 内存给 Redis</li><li>everysec</li></ul></li><li><p>最佳策略</p><ul><li>小分片，maxMemory</li><li>缓存或者存储</li><li>监控（磁盘、内存、负载、网络）</li><li>足够内存（不需要全量给 Redis）</li></ul></li></ul><h3 id="常见运维问题："><a href="#常见运维问题：" class="headerlink" title="常见运维问题："></a>常见运维问题：</h3><ul><li><p>fork 操作（内存页的拷贝）</p><ul><li><p>同步操作</p></li><li><p>与内存量息息相关，内存越大，耗时越长（与机器类型相关）</p></li><li><p>info: latest_fork_usec 上个执行 fork 微秒数</p></li></ul></li><li><p>改善 fork</p><ul><li><p>优先使用物理机或者高效支持 fork 操作的虚拟化技术</p></li><li><p>控制 Redis 实例最大的可用内存</p></li><li><p>合理配置 Linux 内存分配策略：vm.overcommit_memory=1</p></li><li><p>降低 fork 频率：放宽 AOF 重写触发时机，不必要的全量复制</p></li></ul></li><li><p>进程外开销和优化</p><ul><li><p>CPU</p><ul><li><p>开销：RDB 和 AOF 文件生成，属于 CPU 密集型</p></li><li><p>优化：不做 CPU 绑定，不和 CPU 密集型项目一起部署</p></li></ul></li><li><p>内存</p><ul><li><p>开销：fork 内存开销，copy-on-write</p></li><li><p>优化：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</p></li></ul></li><li><p>硬盘</p><ul><li><p>开销：AOF 和 RDB 文件写入</p></li><li><p>优化：</p><ul><li><p>不要和高硬盘负载服务部署在一起：存储服务、消息队列等</p></li><li><p>no-apendfsync-on-rewrite = yes</p></li><li><p>根据写入量决定磁盘类型：例如 SSD</p></li><li><p>单机多部署持久化目录可以考虑分盘</p></li></ul></li></ul></li><li><p>AOF 追加阻塞</p><ul><li><p>定位</p><ul><li><p>Redis 日志 asynchronous AOF fsync is take too long</p></li><li><p>Redis 命令，info Persistence（查看历史累计阻塞）；</p></li><li><p>Linux 系统命令 Top 来查看资源占用</p></li></ul></li></ul></li><li><p>单机多实例部署</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要内容：&lt;/p&gt;
&lt;h3 id=&quot;持久化的作用&quot;&gt;&lt;a href=&quot;#持久化的作用&quot; class=&quot;headerlink&quot; title=&quot;持久化的作用&quot;&gt;&lt;/a&gt;持久化的作用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是持久化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的数据都保存在内存中
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://sensitivemix.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>跨域与安全</title>
    <link href="https://sensitivemix.github.io/2018/12/02/%E8%B7%A8%E5%9F%9F%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    <id>https://sensitivemix.github.io/2018/12/02/跨域与安全/</id>
    <published>2018-12-02T14:03:24.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于跨域，有两个误区：</p><ol><li>✕ 动态请求就会有跨域的问题</li></ol><p>✔ 跨域只存在于浏览器端，不存在于安卓/ios/Node.js/python/ java等其它环境</p><ol start="2"><li>✕ 跨域就是请求发不出去了</li></ol><p>✔ 跨域请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</p><p>之所以会跨域，是因为受到了同源策略的限制，同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。</p><p>如下图所示：</p><p>Screenshot-0.png</p><p>这三个源分别由于域名、协议和端口号不一致，导致会受到同源策略的限制。</p><p>同源策略具体限制些什么呢？</p><ol><li>不能向工作在不同源的的服务请求数据（client to server）</li></ol><p>这里有个问题之前也困扰了我很久，就是为什么home.com加载的cdn.home.com/index.js可以向home.com发请求而不会跨域呢？其实home.com加载的JS是工作在home.com的，它的源不是提供JS的cdn，所以这个时候是没有跨域的问题的，并且script标签能够加载非同源的资源，不受同源策略的影响。</p><ol start="2"><li>无法获取不同源的document/cookie等BOM和DOM，可以说任何有关另外一个源的信息都无法得到 （client to client）</li></ol><p>为什么会有同源策略呢？</p><ol><li>为什么要限制不同源发请求？</li></ol><p>假设用户登陆了bank.com，同时打开了evil.com，如果没有任何限制，evil.com可以向bank.com请求到任何信息，进而就可以在evil.com向bank.com发转账请求等。</p><p>如果这样，为什么不直接限制写，只限制读？</p><p>因为如果连请求都发不出去了，那就不能做跨域资源共享了，无法读取返回结果，evil.com就无法继续下一步的操作，如获取转账请求的一些必要的验证信息。</p><ol start="2"><li>为什么限制跨域的DOM读取？</li></ol><p>如果不限制的话，那么很容易就可以伪装其它的网站，如套一个iframe或者通过window.open的方法，从而得到用户的操作和输入，如账户、密码。</p><p>另外，添加这个http头可以限制别人把你的网站套成它的iframe：</p><p>X-Frame-Options: SAMEORIGIN</p><p>同源策略提供了安全的同时也造成了不方便，因为有时候我们需要跨域请求，如获取第三方提供的服务信息，由于第三方的源和本网站的源不一样，所以这个时候就受到跨域的限制。</p><p>跨域最常用的方法，应当属CORS，如下图所示：</p><p>Screenshot-1.png</p><p>只要浏览器检测到响应头带上了CORS，并且允许的源包括了本网站，那么就不会拦截请求响应。</p><p>CORS把请求分为两种，一种是简单请求，另一种是需要触发预检请求，这两者是相对的，怎样才算“不简单”？只要属于下面的其中一种就不是简单请求：</p><p>（1）使用了除GET/POST/HEAD之外的请求方式，如PUT/DELETE</p><p>（2）使用了除Content-Type/Accept等几个常用的http头</p><p>这个时候就认为需要先发个预检请求，预检请求使用OPTIONS方式去检查当前请求是否安全，如下图所示：</p><p>Screenshot-3.png</p><p>代码里面只发了一个请求，但在控制台看到了两个请求，第一个是OPTIONS，服务端返回：</p><p>Screenshot-4.png</p><p>返回头里面包含了允许的请求头、请求方式、源，以及预检请求的有效期，上图是设置了20天，在这个有效期内就不用再发一个options的请求，实际上浏览器有一个最长时间，如Chrome是5分钟。如果在预检请求检测到当前请求不符合服务端设定的要求，则不会发出去了直接抛异常，这个时候就不用去发“复杂”的请求了。</p><p>如本源不在允许的源范围内，则会抛异常，无法获取返回结果：</p><p>Screenshot-5.png</p><p>location / {<br>     if ($request_method = ‘OPTIONS’) {<br>        add_header ‘Access-Control-Allow-Origin’ ‘<em>‘;<br>        add_header ‘Access-Control-Allow-Methods’ ‘GET, POST, OPTIONS’;<br>        add_header ‘Access-Control-Max-Age’ 1728000;<br>        add_header ‘Content-Type’ ‘text/plain; charset=utf-8’;<br>        add_header ‘Content-Length’ 0;<br>        return 204;<br>     }<br>     add_header ‘Access-Control-Allow-Origin’ ‘</em>‘;<br>     add_header ‘Access-Control-Allow-Methods’ ‘GET, POST, OPTIONS, PUT, DELETE’;<br>     add_header ‘Access-Control-Allow-Headers’ ‘DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range’;<br>     add_header ‘Access-Control-Expose-Headers’ ‘DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range’;<br>}<br>第二种常用的跨域的方法是JSONP，JSONP是利用了script标签能够跨域，如下代码所示：</p><p>function updateList (data) {<br>    console.log(data);<br>}</p><p>$body.append(‘&lt;script src=“<a href="http://otherdomain.com/request?callback=updateList&quot;&gt;" target="_blank" rel="noopener">http://otherdomain.com/request?callback=updateList&quot;&gt;</a>‘);<br>代码先定义一个全局函数，然后把这个函数名通过callback参数添加到script标签的src，script的src就是需要跨域的请求，然后这个请求返回可执行的JS文本：</p><p>// script响应返回的js内容为<br>updateList([{<br>    name: ‘hello’<br>}]);<br>由于它是一个js，并且已经定义了upldateList函数，所以能正常执行，并且跨域的数据通过传参得到。这就是JSONP的原理。</p><p>所以由于script/iframe/img等标签的请求默认是能带上cookie（cookie里面带上了登陆验证的票token），用这些标签发请求是能够绕过同源策略的，因此就可以利用这些标签做跨站请求伪造（CSRF），如下面代码所示：</p><p>// 转账请求</p><iframe src="http://Abank.com/app/transferFunds?amount=1500&destinationAccount=..."></iframe><p>// 配置路由器添加代理<br><img src="http://192.168.1.1/admin/config/outsideInterface?nexthop=123.45.67.89" style="display:none"><br>如果相应的网站支持GET请求，或者没有做进一步的防护措施，那么如果用户在另外一个页面登陆过了，再打开一个“有毒”的网站就中招了。</p><p>而动态ajax请求默认是不带cookie的，如果你要带cookie，可以设置ajax的一个属性withCredentials，如下代码所示：</p><p>// 原生请求<br>let xhr = new XMLHttpRequest();<br>xhr.withCredentials = true;<br>xhr.open(“GET”, “<a href="http://otherdomain.com/list&quot;)" target="_blank" rel="noopener">http://otherdomain.com/list&quot;)</a>;<br>xhr.send();</p><p>// jquery请求<br>$.ajax({<br>   url: “<a href="http://otherdomain.com/list&quot;" target="_blank" rel="noopener">http://otherdomain.com/list&quot;</a>,<br>   xhrFields: {<br>      withCredentials: true<br>   }<br>});<br>这个时候就和img/script标签一样，能带上cookie，并且还支持除GET之外的其它方式。所以这种方式也是能实现CSRF的，如下图所示：</p><p>Screenshot-6.png</p><p>所以如果转账请求只是不支持GET，没做其它的防护措施，仍然有CSRF攻击的风险。那怎么办呢？</p><p>方法一是每次请求都要在参数里面显示地带上token即登陆的票，虽然跨域请求能带上cookie，但是通过document.cookie仍然是获取不到其它源的cookie的，所以攻击者无法在代码里面拿到cookie里面的token，所以就没办法了。方法一的缺点是会暴露token，所以需要带token的最好不能是GET，因为GET会把参数拼在url里面，用户可能会无意把链接发给别人，但不知道这个链接带上了自己的登陆信息。</p><p>方法二是每次转账请求前都先请求一个随机串，这个串只能用一次转账或者支付请求，用完就废弃，只有这个串对得上才能请求成功，攻击者是无法拿到这个串的，因为如果跨域请求带cookie，浏览器要求Access-Control-Allow-Origin不能为通配符，只能为指定的源，如：</p><p>Access-Control-Allow-Origin: <a href="http://renren.com" target="_blank" rel="noopener">http://renren.com</a></p><p>由于攻击者所在的域名不在这个源里面，所以它是无法得到请求结果，所以请求不到随机串。因此这种方式也是可以避免CSRF攻击。</p><p>假设Allow-Origin为*，ajax设置withCredentials为true时，浏览器会抛异常，无法得到返回结果：</p><p>Screenshot-7.png</p><p>另外服务还需要指定Allow-Credentials的头部，如下代码所示：</p><p>add_header “Access-Control-Allow-Origin” “<a href="http://fedren.com&quot;" target="_blank" rel="noopener">http://fedren.com&quot;</a>;<br>add_header “Access-Control-Allow-Credentials” “true”;</p><p>关于cookie还有两个地方值得注意，如下图所示：</p><p>Screenshot-8.png</p><p>讨论完了client to server，我们再讨论client to client，即如何和一个frame通信，包括iframe或者使用window.open打开的页面。</p><p>iframe访问父页面可通过window.parent得到父窗口的window对象，通过open打开的可以用window.opener，进而得到父窗口的任何东西；父窗口如果和iframe同源的，那么可通过iframe.contentWindow得到iframe的window对象，如果和iframe不同源，则存在跨域的问题，这个时候可通过postMessage进行通讯。</p><p> 使用postMessage的基本原理如下图所示：</p><p>// main frame<br>let iframeWin = document.querySelector(“#my-iframe”)<br>                .contentWindow;<br>iframeWin.postMessage({age: 18}, “<a href="http://parent.com&quot;)" target="_blank" rel="noopener">http://parent.com&quot;)</a>;<br>iframeWin.onmessage = function(event) {<br>    console.log(“recv from iframe “, event.data);<br>};</p><p>// iframe<br>window.onmessage = function(event) {<br>    // test event.origin<br>    if (event.origin !== expectOrigin) {<br>        return;<br>    }<br>    console.log(“recv from main frame “, event.data);<br>};</p><p>window.parent.postMessage(“hello, this is from iframe “, “<a href="http://child.com&quot;)" target="_blank" rel="noopener">http://child.com&quot;)</a>;</p><p>以页面嵌入youtobe视频为例，通过以下代码可以在页面嵌入一个youtobe视频，嵌入的是一个跨域的iframe，所以就涉及到如何和iframe进行通信的问题。如怎么知道iframe的状态，触发父页面定义的事件onPlayerReady，这个是iframe通知父页面，而父页面可以调player.stopVideo控制iframe的行为，这个是父页面通知iframe。</p><p>Screenshot-9.png</p><p>iframe通知父页面是通过window.parent.postMessage，同时监听message事件：</p><p>Screenshot-10.png</p><p>经检查上面代码4304行的c就是window.parent，这个embed-player.js是iframe的js，iframe的js通过postMessage发送了一个消息，如上图右边的窗口所示，然后在父窗口的widgetapi.js就收到了这个消息</p><p>同样地，父窗口的JS也是使用postMessage向iframe发送消息，如下图所示：</p><p>Screenshot-11.png</p><p>当然postMessage不限于跨域，同域的也可以使用，只是同域的话可以通过window对象互相操作，你可能需要额外定义一些全局变量或者函数供其它frame使用，或者是定义一套事件机制（可以借助原生事件/jQuery/Vue事件等）。</p><p>这里有一个特例，就是子域如mail.hello.com要跨hello.com的时候，可以显式地设置子域的document.domain值为父域的domain：</p><p>document.domain = “hello.com”;<br>就不会有跨域的问题了。</p><p>补充一点，如果需要和同源的不同标签页进行通信可以使用localStorage，即一个页面设置localStorage，其它页面就会触发storage事件：</p><p>window.addEventListener(‘storage’, function(e) {<br>    e.key;<br>    e.oldValue;<br>    e.newValue;<br>    e.url;<br>    e.storageArea;<br>});</p><p>再补充一点，websocket是不受同源策略限制的，没有跨域的问题。CSS的字体文件是会有跨域问题，指定CORS就能加载其它源的字体文件（通常是放在cdn上的）。而canvas动态加载的外部image，也是需要指定CORS头才能进行图片处理，否则只能画不能读取。</p><p>最后，跨域分为两种，一种是跨域请求，另一种访问跨域的页面，跨域请求可以通过CORS/JSONP等方法进行访问，跨域的页面主要通过postMesssage的方式。由于跨域请求不但能发出去还能带上cookie，所以要规避跨站请求伪造攻击的风险，特别是涉及到钱的那种请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于跨域，有两个误区：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;✕ 动态请求就会有跨域的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;✔ 跨域只存在于浏览器端，不存在于安卓/ios/Node.js/python/ java等其它环境&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;✕ 跨域就是请求发不
      
    
    </summary>
    
      <category term="开发" scheme="https://sensitivemix.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="InfluxDB" scheme="https://sensitivemix.github.io/tags/InfluxDB/"/>
    
      <category term="Database" scheme="https://sensitivemix.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>如何构建易于运维的后端应用</title>
    <link href="https://sensitivemix.github.io/2018/12/01/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E6%98%93%E4%BA%8E%E8%BF%90%E7%BB%B4%E7%9A%84%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8/"/>
    <id>https://sensitivemix.github.io/2018/12/01/如何构建易于运维的后端应用/</id>
    <published>2018-12-01T06:42:27.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="六点要点"><a href="#六点要点" class="headerlink" title="六点要点"></a>六点要点</h4><ul><li><p>保持简单并消除不一致</p><ul><li>无状态的、事务的（stateless、scalable）</li><li>单一代码库 （Codebase -&gt; Deploys）</li></ul></li><li><p>简单地观察和干预内部行为</p><ul><li>日志级别 （trace、debug、info、warn、error、fatal）</li><li>结构化日志 （bunyan、winston）</li><li>时序数据和图表（Grafana）</li><li>时序数据（InfluxDB）</li><li>通过环境变量管理配置<ul><li>exports.LISTEN = process.env.LISTEN || 3000</li></ul></li></ul></li><li>出了问题要有办法发现<ul><li>self-check<ul><li>yield []</li><li>Promise.all []</li></ul></li><li>错误收集（Sentry、raven）</li></ul></li><li>操作自动化<ul><li>Why<ul><li>保证一致</li><li>节省时间</li><li>可重复</li><li>可复用</li></ul></li><li>How<ul><li>依赖（package.json）</li><li>数据库变更（db-migrate）</li><li>系统环境（Dockerfile）</li><li>构建、测试和发布（CI）</li><li>其他自动化脚本</li></ul></li></ul></li><li>尝试从错误中自动恢复<ul><li>数据一致性修复任务（MySQL MongoDB Redis Cache）</li></ul></li><li>划清组件之间的界限<ul><li>守护进程（重启）</li><li>负载均衡（Https、IP限流）</li><li>日志（写入文件、轮转he ）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;六点要点&quot;&gt;&lt;a href=&quot;#六点要点&quot; class=&quot;headerlink&quot; title=&quot;六点要点&quot;&gt;&lt;/a&gt;六点要点&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;保持简单并消除不一致&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无状态的、事务的（stateless、scalable）&lt;
      
    
    </summary>
    
      <category term="学习资料" scheme="https://sensitivemix.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
      <category term="Tutorial" scheme="https://sensitivemix.github.io/tags/Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 代码整洁之道中文版</title>
    <link href="https://sensitivemix.github.io/2018/12/01/JavaScript-%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B8%AD%E6%96%87%E7%89%88/"/>
    <id>https://sensitivemix.github.io/2018/12/01/JavaScript-代码整洁之道中文版/</id>
    <published>2018-12-01T06:33:40.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<p># </p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><p><a href="#概述">概述</a></p></li><li><p><a href="#变量">变量</a></p></li><li><p><a href="#函数">函数</a></p></li><li><p><a href="#对象和数据结构">对象和数据结构</a></p></li><li><p><a href="#类">类</a></p></li><li><p><a href="#测试">测试</a></p></li><li><p><a href="#并发">并发</a></p></li><li><p><a href="#错误处理">错误处理</a></p></li><li><p><a href="#格式">格式</a></p></li><li><p><a href="#注释">注释</a></p></li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="http://p0.qhimg.com/t01cb6a971284a41620.jpg" alt="一张幽默的图片：软件质量通过你在阅读代码的时候有多少报怨来进行评估"></p><p>Robert C. Martin 在 <a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882" target="_blank" rel="noopener">《代码整洁之道》</a> 中提到的软件工程原则，同样适用于 JavaScript。这不是一个风格参考。它指导如何用 JavaScript 编写可读、可复用、可重构的软件。</p><p>并不是每一个原则都必须严格遵循，甚至很少得到大家的认同。它们仅用于参考，不过要知道这些原则都是《代码整洁之道》的作者们累积多年的集体经验。</p><p>我们在软件工程方面的技术发展刚刚超过 50 年，我们仍然在学习很多东西。当软件架构和架构本身一样古老的时候，我们应该遵循更为严格规则。现在，对于你和你的团队编写的 JavaScript 代码，不妨依据这些准则来进行质量评估。</p><p>还有一件事：知道这些不会马上让你成为更好的软件开发者，在工作中常年使用这些准则不能让你避免错误。每一段代码都从最初的草图开始到最终成型，就像为湿粘土塑形一样。最后，当我们与同行一起审查的时候，再把不完美的地方消除掉。不要因为初稿需要改善而否定自己，需要要否定的只是那些代码！</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="使用有准确意义的变量名"><a href="#使用有准确意义的变量名" class="headerlink" title="使用有准确意义的变量名"></a>使用有准确意义的变量名</h3><p>不好:</p><p>var yyyymmdstr = moment().format(‘YYYY/MM/DD’);</p><p>好:</p><p>var yearMonthDay = moment().format(‘YYYY/MM/DD’);</p><h3 id="在变量的值不会改变时使用-ES6-的常量"><a href="#在变量的值不会改变时使用-ES6-的常量" class="headerlink" title="在变量的值不会改变时使用 ES6 的常量"></a>在变量的值不会改变时使用 ES6 的常量</h3><p>在不好的示例中，变量可以被改变。如果你申明一个常量，它会在整个程序中始终保持不变。</p><p>不好:</p><p>var FIRST_US_PRESIDENT = “George Washington”;</p><p>好:</p><p>const FIRST_US_PRESIDENT = “George Washington”;</p><h3 id="对同一类型的变量使用相同的词汇"><a href="#对同一类型的变量使用相同的词汇" class="headerlink" title="对同一类型的变量使用相同的词汇"></a>对同一类型的变量使用相同的词汇</h3><p>不好:</p><p>getUserInfo();<br>getClientData();<br>getCustomerRecord();</p><p>好:</p><p>getUser();</p><h3 id="使用可检索的名称"><a href="#使用可检索的名称" class="headerlink" title="使用可检索的名称"></a>使用可检索的名称</h3><p>我们阅读的代码永远比写的折。写可读性强、易于检索的的代码非常重要。在程序中使用无明确意义的变量名会难以理解，对读者造成伤害。所以，把名称定义成可检索的。</p><p>不好:</p><p>// 见鬼，525600 是个啥？<br>for (var i = 0; i &lt; 525600; i++) {<br>  runCronJob();<br>}</p><p>好:</p><p>// 用 `var` 申明为大写的全局变量<br>var MINUTES_IN_A_YEAR = 525600;<br>for (var i = 0; i &lt; MINUTES_IN_A_YEAR; i++) {<br>  runCronJob();<br>}</p><h3 id="使用解释性的变量"><a href="#使用解释性的变量" class="headerlink" title="使用解释性的变量"></a>使用解释性的变量</h3><p>不好:</p><p>const cityStateRegex = /^(.+)[,\\s]+(.+?)\s*(\d{5})?$/;<br>saveCityState(cityStateRegex.match(cityStateRegex)[1], cityStateRegex.match(cityStateRegex)[2]);</p><p>好:</p><p>const cityStateRegex = /^(.+)[,\\s]+(.+?)\s*(\d{5})?$/;<br>const match = cityStateRegex.match(cityStateRegex)<br>const city = match[1];<br>const state = match[2];<br>saveCityState(city, state);</p><h3 id="避免暗示"><a href="#避免暗示" class="headerlink" title="避免暗示"></a>避免暗示</h3><p>显式优于隐式。</p><p>不好:</p><p>var locations = [‘Austin’, ‘New York’, ‘San Francisco’];<br>locations.forEach((l) =&gt; {<br>  doStuff();<br>  doSomeOtherStuff();<br>  …<br>  …<br>  …<br>  // 等等，`l` 又是什么？<br>  dispatch(l);<br>});</p><p>好:</p><p>var locations = [‘Austin’, ‘New York’, ‘San Francisco’];<br>locations.forEach((location) =&gt; {<br>  doStuff();<br>  doSomeOtherStuff();<br>  …<br>  …<br>  …<br>  dispatch(location);<br>});</p><h3 id="不要添加没必要的上下文"><a href="#不要添加没必要的上下文" class="headerlink" title="不要添加没必要的上下文"></a>不要添加没必要的上下文</h3><p>如果你的类名称/对象名称已经说明了它们是什么，不要在(属性)变量名里重复。</p><p>不好:</p><p>var Car = {<br>  carMake: ‘Honda’,<br>  carModel: ‘Accord’,<br>  carColor: ‘Blue’<br>};</p><p>function paintCar(car) {<br>  car.carColor = ‘Red’;<br>}</p><p>好:</p><p>var Car = {<br>  make: ‘Honda’,<br>  model: ‘Accord’,<br>  color: ‘Blue’<br>};</p><p>function paintCar(car) {<br>  car.color = ‘Red’;<br>}</p><h3 id="短路语法比条件语句更清晰"><a href="#短路语法比条件语句更清晰" class="headerlink" title="短路语法比条件语句更清晰"></a>短路语法比条件语句更清晰</h3><p>不好:</p><p>function createMicrobrewery(name) {<br>  var breweryName;<br>  if (name) {<br>    breweryName = name;<br>  } else {<br>    breweryName = ‘Hipster Brew Co.’;<br>  }<br>}</p><p>好:</p><p>function createMicrobrewery(name) {<br>  var breweryName = name || ‘Hipster Brew Co.’<br>}</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数参数-理论上少于等于2个"><a href="#函数参数-理论上少于等于2个" class="headerlink" title="函数参数 (理论上少于等于2个)"></a>函数参数 (理论上少于等于2个)</h3><p>限制函数参数的数量极为重要，它会让你更容易测试函数。超过3个参数会导致组合膨胀，以致于你必须根据不同的参数对大量不同的情况进行测试。</p><p>理想情况下是没有参数。有一个或者两个参数也还好，三个就应该避免了。多于那个数量就应该考虑合并。通常情况下，如果你有多于2个参数，你的函数会尝试做太多事情。如果不是这样，大多数时候可以使用一个高阶对象作为参数使用。</p><p>既然 JavaScript 允许我们在运行时随意创建对象，而不需要预先定义样板，那么你在需要很多参数的时候就可以使用一个对象来处理。</p><p>不好:</p><p>function createMenu(title, body, buttonText, cancellable) {<br>  …<br>}</p><p>好:</p><p>var menuConfig = {<br>  title: ‘Foo’,<br>  body: ‘Bar’,<br>  buttonText: ‘Baz’,<br>  cancellable: true<br>}</p><p>function createMenu(menuConfig) {<br>  …<br>}</p><h3 id="一个函数只做一件事"><a href="#一个函数只做一件事" class="headerlink" title="一个函数只做一件事"></a>一个函数只做一件事</h3><p>目前这是软件工程中最重要的原则。如果函数做了较多的事情，它就难以组合、测试和推测。当你让函数只做一件事情的时候，它们就很容易重构，而且代码读起来也会清晰得多。你只需要遵循本指南的这一条，就能领先于其他很多开发者。</p><p>不好:</p><p>function emailClients(clients) {<br>  clients.forEach(client =&gt; {<br>    let clientRecord = database.lookup(client);<br>    if (clientRecord.isActive()) {<br>      email(client);<br>    }<br>  });<br>}</p><p>好:</p><p>function emailClients(clients) {<br>  clients.forEach(client =&gt; {<br>    emailClientIfNeeded(client);<br>  });<br>}</p><p>function emailClientIfNeeded(client) {<br>  if (isClientActive(client)) {<br>    email(client);<br>  }<br>}</p><p>function isClientActive(client) {<br>  let clientRecord = database.lookup(client);<br>  return clientRecord.isActive();<br>}</p><h3 id="函数名称要说明它做的事"><a href="#函数名称要说明它做的事" class="headerlink" title="函数名称要说明它做的事"></a>函数名称要说明它做的事</h3><p>不好:</p><p>function dateAdd(date, month) {<br>  // …<br>}</p><p>let date = new Date();</p><p>// 很难从函数名了解到加了什么<br>dateAdd(date, 1);</p><p>好:</p><p>function dateAddMonth(date, month) {<br>  // …<br>}</p><p>let date = new Date();<br>dateAddMonth(date, 1);</p><h3 id="函数应该只抽象一个层次"><a href="#函数应该只抽象一个层次" class="headerlink" title="函数应该只抽象一个层次"></a>函数应该只抽象一个层次</h3><p>如果你有多个层次的抽象，那么你的函数通常做了太多事情，此时应该拆分函数使其易于复用和易于测试。</p><p>不好:</p><p>function parseBetterJSAlternative(code) {<br>  let REGEXES = [<br>    // …<br>  ];</p><p>  let statements = code.split(‘ ‘);<br>  let tokens;<br>  REGEXES.forEach((REGEX) =&gt; {<br>    statements.forEach((statement) =&gt; {<br>      // …<br>    })<br>  });</p><p>  let ast;<br>  tokens.forEach((token) =&gt; {<br>    // lex…<br>  });</p><p>  ast.forEach((node) =&gt; {<br>    // parse…<br>  })<br>}</p><p>好:</p><p>function tokenize(code) {<br>  let REGEXES = [<br>    // …<br>  ];</p><p>  let statements = code.split(‘ ‘);<br>  let tokens;<br>  REGEXES.forEach((REGEX) =&gt; {<br>    statements.forEach((statement) =&gt; {<br>      // …<br>    })<br>  });</p><p>  return tokens;<br>}</p><p>function lexer(tokens) {<br>  let ast;<br>  tokens.forEach((token) =&gt; {<br>    // lex…<br>  });</p><p>  return ast;<br>}</p><p>function parseBetterJSAlternative(code) {<br>  let tokens = tokenize(code);<br>  let ast = lexer(tokens);<br>  ast.forEach((node) =&gt; {<br>    // parse…<br>  })<br>}</p><h3 id="删除重复代码"><a href="#删除重复代码" class="headerlink" title="删除重复代码"></a>删除重复代码</h3><p>任何情况下，都不要有重复的代码。没有任何原因，它很可能是阻碍你成为专业开发者的最糟糕的一件事。重复代码意味着你要修改某些逻辑的时候要修改不止一个地方的代码。JavaScript 是弱类型语句，所以它很容易写通用性强的函数。记得利用这一点！</p><p>不好:</p><p>function showDeveloperList(developers) {<br>  developers.forEach(developers =&gt; {<br>    var expectedSalary = developer.calculateExpectedSalary();<br>    var experience = developer.getExperience();<br>    var githubLink = developer.getGithubLink();<br>    var data = {<br>      expectedSalary: expectedSalary,<br>      experience: experience,<br>      githubLink: githubLink<br>    };</p><pre><code>render(data);</code></pre><p>  });<br>}</p><p>function showManagerList(managers) {<br>  managers.forEach(manager =&gt; {<br>    var expectedSalary = manager.calculateExpectedSalary();<br>    var experience = manager.getExperience();<br>    var portfolio = manager.getMBAProjects();<br>    var data = {<br>      expectedSalary: expectedSalary,<br>      experience: experience,<br>      portfolio: portfolio<br>    };</p><pre><code>render(data);</code></pre><p>  });<br>}</p><p>好:</p><p>function showList(employees) {<br>  employees.forEach(employee =&gt; {<br>    var expectedSalary = employee.calculateExpectedSalary();<br>    var experience = employee.getExperience();<br>    var portfolio;</p><pre><code>if (employee.type === &apos;manager&apos;) {  portfolio = employee.getMBAProjects();} else {  portfolio = employee.getGithubLink();}var data = {  expectedSalary: expectedSalary,  experience: experience,  portfolio: portfolio};render(data);</code></pre><p>  });<br>}</p><h3 id="使用默认参数代替短路表达式"><a href="#使用默认参数代替短路表达式" class="headerlink" title="使用默认参数代替短路表达式"></a>使用默认参数代替短路表达式</h3><p>不好:</p><p>function writeForumComment(subject, body) {<br>  subject = subject || ‘No Subject’;<br>  body = body || ‘No text’;<br>}</p><p>好:</p><p>function writeForumComment(subject = ‘No subject’, body = ‘No text’) {<br>  …<br>}</p><h3 id="用-Object-assign-设置默认对象"><a href="#用-Object-assign-设置默认对象" class="headerlink" title="用 Object.assign 设置默认对象"></a>用 Object.assign 设置默认对象</h3><p>不好:</p><p>var menuConfig = {<br>  title: null,<br>  body: ‘Bar’,<br>  buttonText: null,<br>  cancellable: true<br>}</p><p>function createMenu(config) {<br>  config.title = config.title || ‘Foo’<br>  config.body = config.body || ‘Bar’<br>  config.buttonText = config.buttonText || ‘Baz’<br>  config.cancellable = config.cancellable === undefined ? config.cancellable : true;</p><p>}</p><p>createMenu(menuConfig);</p><p>好:</p><p>var menuConfig = {<br>  title: ‘Order’,<br>  // User did not include ‘body’ key<br>  buttonText: ‘Send’,<br>  cancellable: true<br>}</p><p>function createMenu(config) {<br>  config = Object.assign({<br>    title: ‘Foo’,<br>    body: ‘Bar’,<br>    buttonText: ‘Baz’,<br>    cancellable: true<br>  }, config);</p><p>  // 现在 config 等于: {title: “Foo”, body: “Bar”, buttonText: “Baz”, cancellable: true}<br>  // …<br>}</p><p>createMenu(menuConfig);</p><h3 id="不要把标记用作函数参数"><a href="#不要把标记用作函数参数" class="headerlink" title="不要把标记用作函数参数"></a>不要把标记用作函数参数</h3><p>标记告诉你的用户这个函数做的事情不止一件。但是函数应该只做一件事。如果你的函数中会根据某个布尔参数产生不同的分支，那就拆分这个函数。</p><p>不好:</p><p>function createFile(name, temp) {<br>  if (temp) {<br>    fs.create(‘./temp/‘ + name);<br>  } else {<br>    fs.create(name);<br>  }<br>}</p><p>好:</p><p>function createTempFile(name) {<br>  fs.create(‘./temp/‘ + name);<br>}</p><p>function createFile(name) {<br>  fs.create(name);<br>}</p><h3 id="避免副作用"><a href="#避免副作用" class="headerlink" title="避免副作用"></a>避免副作用</h3><p>如果一个函数不是获取一个输入的值并返回其它值，它就有可能产生副作用。这些副作用可能是写入文件、修改一些全局变量，或者意外地把你所有钱转给一个陌生人。</p><p>现在你确实需要在程序中有副作用。像前面提到的那样，你可能需要写入文件。现在你需要做的事情是搞清楚在哪里集中完成这件事情。不要使用几个函数或类来完成写入某个特定文件的工作。采用一个，就一个服务来完成。</p><p>关键点是避免觉的陷阱，比如在没有结构的对象间共享状态，使用可以被任意修改的易变的数据类型，没有集中处理发生的副作用等。如果你能做到，你就能比其他大多数程序员更愉快。</p><p>不好:</p><p>// 下面的函数使用了全局变量。<br>// 如果有另一个函数在使用 name，现在可能会因为 name 变成了数组而不能正常运行。<br>var name = ‘Ryan McDermott’;</p><p>function splitIntoFirstAndLastName() {<br>  name = name.split(‘ ‘);<br>}</p><p>splitIntoFirstAndLastName();</p><p>console.log(name); // [‘Ryan’, ‘McDermott’];</p><p>好:</p><p>function splitIntoFirstAndLastName(name) {<br>  return name.split(‘ ‘);<br>}</p><p>var name = ‘Ryan McDermott’<br>var newName = splitIntoFirstAndLastName(name);</p><p>console.log(name); // ‘Ryan McDermott’;<br>console.log(newName); // [‘Ryan’, ‘McDermott’];</p><h3 id="不要写入全局函数"><a href="#不要写入全局函数" class="headerlink" title="不要写入全局函数"></a>不要写入全局函数</h3><p>JavaScript 中全局污染是一件糟糕的事情，因为它可能和另外库发生冲突，然而使用你 API 的用户却不会知道——直到他们在生产中遇到一个异常。来思考一个例子：你想扩展 JavaScript 的原生 Array，使之拥有一个 <code>diff</code> 方法，用来展示两数据之前的区别，这时你会怎么做？你可以给 <code>Array.prototype</code> 添加一个新的函数，但它可能会与其它想做同样事情的库发生冲突。如果那个库实现的 <code>diff</code> 只是比如数组中第一个元素和最后一个元素的异同会发生什么事情呢？这就是为什么最好是使用 ES6 的类语法从全局的 <code>Array</code> 派生一个类来做这件事。</p><p>不好:</p><p>Array.prototype.diff = function(comparisonArray) {<br>  var values = [];<br>  var hash = {};</p><p>  for (var i of comparisonArray) {<br>    hash[i] = true;<br>  }</p><p>  for (var i of this) {<br>    if (!hash[i]) {<br>      values.push(i);<br>    }<br>  }</p><p>  return values;<br>}</p><p>好:</p><p>class SuperArray extends Array {<br>  constructor(…args) {<br>    super(…args);<br>  }</p><p>  diff(comparisonArray) {<br>    var values = [];<br>    var hash = {};</p><pre><code>for (var i of comparisonArray) {  hash\[i\] = true;}for (var i of this) {  if (!hash\[i\]) {    values.push(i);  }}return values;</code></pre><p>  }<br>}</p><h3 id="喜欢上命令式编程之上的函数式编程"><a href="#喜欢上命令式编程之上的函数式编程" class="headerlink" title="喜欢上命令式编程之上的函数式编程"></a>喜欢上命令式编程之上的函数式编程</h3><p>如果 Haskell 是 IPA 那么 JavaScript 就是 O’Douls。就是说，与 Haskell 不同，JavaScript 不是函数式编程语言，不过它仍然有一点函数式的意味。函数式语言更整洁也更容易测试，所以你最好能喜欢上这种编程风格。</p><p>不好:</p><p>const programmerOutput = [<br>  {<br>    name: ‘Uncle Bobby’,<br>    linesOfCode: 500<br>  }, {<br>    name: ‘Suzie Q’,<br>    linesOfCode: 1500<br>  }, {<br>    name: ‘Jimmy Gosling’,<br>    linesOfCode: 150<br>  }, {<br>    name: ‘Gracie Hopper’,<br>    linesOfCode: 1000<br>  }<br>];</p><p>var totalOutput = 0;</p><p>for (var i = 0; i &lt; programmerOutput.length; i++) {<br>  totalOutput += programmerOutput[i].linesOfCode;<br>}</p><p>好:</p><p>const programmerOutput = [<br>  {<br>    name: ‘Uncle Bobby’,<br>    linesOfCode: 500<br>  }, {<br>    name: ‘Suzie Q’,<br>    linesOfCode: 1500<br>  }, {<br>    name: ‘Jimmy Gosling’,<br>    linesOfCode: 150<br>  }, {<br>    name: ‘Gracie Hopper’,<br>    linesOfCode: 1000<br>  }<br>];</p><p>var totalOutput = programmerOutput<br>  .map((programmer) =&gt; programmer.linesOfCode)<br>  .reduce((acc, linesOfCode) =&gt; acc + linesOfCode, 0);</p><h3 id="封装条件"><a href="#封装条件" class="headerlink" title="封装条件"></a>封装条件</h3><p>不好:</p><p>if (fsm.state === ‘fetching’ &amp;&amp; isEmpty(listNode)) {<br>  /// …<br>}</p><p>好:</p><p>function shouldShowSpinner(fsm, listNode) {<br>  return fsm.state === ‘fetching’ &amp;&amp; isEmpty(listNode);<br>}</p><p>if (shouldShowSpinner(fsmInstance, listNodeInstance)) {<br>  // …<br>}</p><h3 id="避免否定条件"><a href="#避免否定条件" class="headerlink" title="避免否定条件"></a>避免否定条件</h3><p>不好:</p><p>function isDOMNodeNotPresent(node) {<br>  // …<br>}</p><p>if (!isDOMNodeNotPresent(node)) {<br>  // …<br>}</p><p>好:</p><p>function isDOMNodePresent(node) {<br>  // …<br>}</p><p>if (isDOMNodePresent(node)) {<br>  // …<br>}</p><h3 id="避免条件"><a href="#避免条件" class="headerlink" title="避免条件"></a>避免条件</h3><p>这似乎是个不可能完成的任务。大多数人第一次听到这个的时候会说，“没有 <code>if</code> 语句我该怎么办？”回答是在多数情况下都可以使用多态来实现相同的任务。第二个问题通常是，“那太好了，不过我为什么要这么做呢？”答案在于我们之前了解过整洁的概念：一个函数应该只做一件事情。如果你的类和函数有 <code>if</code> 语句，就意味着你的函数做了更多的事。记住，只做一件事。</p><p>不好:</p><p>class Airplane {<br>  //…<br>  getCruisingAltitude() {<br>    switch (this.type) {<br>      case ‘777’:<br>        return getMaxAltitude() - getPassengerCount();<br>      case ‘Air Force One’:<br>        return getMaxAltitude();<br>      case ‘Cessna’:<br>        return getMaxAltitude() - getFuelExpenditure();<br>    }<br>  }<br>}</p><p>好:</p><p>class Airplane {<br>  //…<br>}</p><p>class Boeing777 extends Airplane {<br>  //…<br>  getCruisingAltitude() {<br>    return getMaxAltitude() - getPassengerCount();<br>  }<br>}</p><p>class AirForceOne extends Airplane {<br>  //…<br>  getCruisingAltitude() {<br>    return getMaxAltitude();<br>  }<br>}</p><p>class Cessna extends Airplane {<br>  //…<br>  getCruisingAltitude() {<br>    return getMaxAltitude() - getFuelExpenditure();<br>  }<br>}</p><h3 id="避免类型检查-第1部分"><a href="#避免类型检查-第1部分" class="headerlink" title="避免类型检查(第1部分)"></a>避免类型检查(第1部分)</h3><p>JavaScript 是无类型的，也就是说函数可以获取任意类型的参数。有时候你会觉得这种自由是种折磨，因而会不由自主地在函数中使用类型检查。有很多种方法可以避免类型检查。首先要考虑的就是 API 的一致性。</p><p>不好:</p><p>function travelToTexas(vehicle) {<br>  if (vehicle instanceof Bicycle) {<br>    vehicle.peddle(this.currentLocation, new Location(‘texas’));<br>  } else if (vehicle instanceof Car) {<br>    vehicle.drive(this.currentLocation, new Location(‘texas’));<br>  }<br>}</p><p>好:</p><p>function travelToTexas(vehicle) {<br>  vehicle.move(this.currentLocation, new Location(‘texas’));<br>}</p><h3 id="避免类型检查-第2部分"><a href="#避免类型检查-第2部分" class="headerlink" title="避免类型检查(第2部分)"></a>避免类型检查(第2部分)</h3><p>如果你在处理基本类型的数据，比如字符串，整数和数组，又不能使用多态，这时你会觉得需要使用类型检查，那么可以考虑 TypeScript。这是普通 JavaScript 的完美替代品，它在标准的 JavaScript 语法之上提供了静态类型。普通 JavaScript 手工检查类型的问题在于这样会写很多废话，而人为的“类型安全”并不能弥补损失的可读性。让你的 JavaScript 保持整洁，写很好的测试，并保持良好的代码审查。否则让 TypeScript (我说过，这是很好的替代品)来做所有事情。</p><p>不好:</p><p>function combine(val1, val2) {<br>  if (typeof val1 == “number” &amp;&amp; typeof val2 == “number” ||<br>      typeof val1 == “string” &amp;&amp; typeof val2 == “string”) {<br>    return val1 + val2;<br>  } else {<br>    throw new Error(‘Must be of type String or Number’);<br>  }<br>}</p><p>好:</p><p>function combine(val1, val2) {<br>  return val1 + val2;<br>}</p><h3 id="不要过度优化"><a href="#不要过度优化" class="headerlink" title="不要过度优化"></a>不要过度优化</h3><p>现在浏览器在运行时悄悄地做了很多优化工作。很多时候你的优化都是在浪费时间。<a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers" target="_blank" rel="noopener">这里有很好的资源</a> 可以看看哪些优化比较缺乏。把它们作为目标，直到他们能固定下来的时候。</p><p>不好:</p><p>// 在旧浏览器中，每次循环的成本都比较高，因为每次都会重算 `len`。<br>// 现在浏览器中，这已经被优化了。<br>for (var i = 0, len = list.length; i &lt; len; i++) {<br>  // …<br>}</p><p>好:</p><p>for (var i = 0; i &lt; list.length; i++) {<br>  // …<br>}</p><h3 id="删除不用的代码"><a href="#删除不用的代码" class="headerlink" title="删除不用的代码"></a>删除不用的代码</h3><p>不用的代码和重复的代码一样糟糕。在代码库中保留无用的代码是毫无道理的事情。如果某段代码用不到，那就删掉它！如果你以后需要它，仍然可以从代码库的历史版本中找出来。</p><p>不好:</p><p>function oldRequestModule(url) {<br>  // …<br>}</p><p>function newRequestModule(url) {<br>  // …<br>}</p><p>var req = newRequestModule;<br>inventoryTracker(‘apples’, req, ‘<a href="http://www.inventory-awesome.io&#39;)" target="_blank" rel="noopener">www.inventory-awesome.io&#39;)</a>;</p><p>好:</p><p>function newRequestModule(url) {<br>  // …<br>}</p><p>var req = newRequestModule;<br>inventoryTracker(‘apples’, req, ‘<a href="http://www.inventory-awesome.io&#39;)" target="_blank" rel="noopener">www.inventory-awesome.io&#39;)</a>;</p><h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><h3 id="使用-getter-和-setter"><a href="#使用-getter-和-setter" class="headerlink" title="使用 getter 和 setter"></a>使用 getter 和 setter</h3><p>JavaScript 没有接口或者类型，也没有像 <code>public</code> 和 <code>private</code> 这样的关键字，所以很难应用设计模式。实事上，在对象上使用 getter 和 setter 访问数据远好于直接查找对象属性。“为什么？”你可能会这样问。那好，下面列出了原因：</p><ol><li><p>你想在获取对象属性的时候做更多的事，不必在代码中寻找所有访问的代码来逐个修改。</p></li><li><p>在进行 <code>set</code> 的时候可以进行额外的数据检验。</p></li><li><p>封装内部表现。</p></li><li><p>在获取或设置的时候易于添加日志和错误处理。</p></li><li><p>继承当前类，可以重写默认功能。</p></li><li><p>可以对对象属性进行懒加载，比如说从服务器获取属性的数据。</p></li></ol><p>不好:</p><p>class BankAccount {<br>  constructor() {<br>       this.balance = 1000;<br>  }<br>}</p><p>let bankAccount = new BankAccount();</p><p>// 买鞋…<br>bankAccount.balance = bankAccount.balance - 100;</p><p>好:</p><p>class BankAccount {<br>  constructor() {<br>       this.balance = 1000;<br>  }</p><p>  // It doesn’t have to be prefixed with `get` or `set` to be a getter/setter<br>  withdraw(amount) {<br>    if (verifyAmountCanBeDeducted(amount)) {<br>      this.balance -= amount;<br>    }<br>  }<br>}</p><p>let bankAccount = new BankAccount();</p><p>// 买鞋…<br>bankAccount.withdraw(100);</p><h3 id="让对象拥有私有成员"><a href="#让对象拥有私有成员" class="headerlink" title="让对象拥有私有成员"></a>让对象拥有私有成员</h3><p>这可以通过闭包实现(ES5以之前的版本)。</p><p>不好:</p><p>var Employee = function(name) {<br>  this.name = name;<br>}</p><p>Employee.prototype.getName = function() {<br>  return this.name;<br>}</p><p>var employee = new Employee(‘John Doe’);<br>console.log(‘Employee name: ‘ + employee.getName()); // Employee name: John Doe<br>delete employee.name;<br>console.log(‘Employee name: ‘ + employee.getName()); // Employee name: undefined</p><p>好:</p><p>var Employee = (function() {<br>  function Employee(name) {<br>    this.getName = function() {<br>      return name;<br>    };<br>  }</p><p>  return Employee;<br>}());</p><p>var employee = new Employee(‘John Doe’);<br>console.log(‘Employee name: ‘ + employee.getName()); // Employee name: John Doe<br>delete employee.name;<br>console.log(‘Employee name: ‘ + employee.getName()); // Employee name: John Doe</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则 (SRP)"></a>单一职责原则 (SRP)</h3><p>正如《代码整洁之道》所说，“不应该有超过一个原因来改变类”。往一个类里塞进许多功能是件诱人的事情，就像在坐飞机的时候只带一个手提箱一样。这带来的问题是，你的类不会在概念上有凝聚力，会有很多因素造成对它的改变。让你的类需要改变的次数最少是件非常重要的事情。这是因为如果一个类里塞入了太多功能，你只修改它的一部分，可能会让人难以理解它为何会影响代码库中其它相关模块。</p><p>不好:</p><p>class UserSettings {<br>  constructor(user) {<br>    this.user = user;<br>  }</p><p>  changeSettings(settings) {<br>    if (this.verifyCredentials(user)) {<br>      // …<br>    }<br>  }</p><p>  verifyCredentials(user) {<br>    // …<br>  }<br>}</p><p>好:</p><p>class UserAuth {<br>  constructor(user) {<br>    this.user = user;<br>  }</p><p>  verifyCredentials() {<br>    // …<br>  }<br>}</p><p>class UserSettings {<br>  constructor(user) {<br>    this.user = user;<br>    this.auth = new UserAuth(user)<br>  }</p><p>  changeSettings(settings) {<br>    if (this.auth.verifyCredentials()) {<br>      // …<br>    }<br>  }<br>}</p><h3 id="开放封装原则-OCP"><a href="#开放封装原则-OCP" class="headerlink" title="开放封装原则(OCP)"></a>开放封装原则(OCP)</h3><p>正如 Bertrand Meyer 所说，“软件实体(类、模块、函数等)应该对扩展开放，对修改封闭。”这是什么意思呢？这个原则基本上规定了你应该允许用户扩展你的模块，但不需要打开 <code>.js</code> 源代码文件来进行编辑。</p><p>不好:</p><p>class AjaxRequester {<br>  constructor() {<br>    // 如果我们需要另一个 HTTP 方法，比如 DELETE，该怎么办？<br>    // 我们必须打开这个文件然后手工把它加进去<br>    this.HTTP_METHODS = [‘POST’, ‘PUT’, ‘GET’];<br>  }</p><p>  get(url) {<br>    // …<br>  }</p><p>}</p><p>好:</p><p>class AjaxRequester {<br>  constructor() {<br>    this.HTTP_METHODS = [‘POST’, ‘PUT’, ‘GET’];<br>  }</p><p>  get(url) {<br>    // …<br>  }</p><p>  addHTTPMethod(method) {<br>    this.HTTP_METHODS.push(method);<br>  }<br>}</p><h3 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则(LSP)"></a>里氏替换原则(LSP)</h3><p>这是一个吓人的术语，但描述的却是个简单的概念。它的正式定义为“如果 S 是 T 的子类，那所有 T 类型的对象都可以替换为 S 类型的对象(即 S 类型的对象可以替代 T 类型的对象)，这个替换不会改变程序的任何性质(正确性、任务执行等)。”这确实是个吓人的定义。</p><p>对此最好的解释是，如果你有父类和子类，那么父类和子类可以交替使用而不会造成不正确的结果。这可能仍然让人感到疑惑，那么让我们看看经典的正方形和矩形的例子。在数学上，正方形也是矩形，但是如果你在模型中通过继承使用 “is-a” 关系，你很快就会陷入困境。</p><p>不好:</p><p>class Rectangle {<br>  constructor() {<br>    this.width = 0;<br>    this.height = 0;<br>  }</p><p>  setColor(color) {<br>    // …<br>  }</p><p>  render(area) {<br>    // …<br>  }</p><p>  setWidth(width) {<br>    this.width = width;<br>  }</p><p>  setHeight(height) {<br>    this.height = height;<br>  }</p><p>  getArea() {<br>    return this.width * this.height;<br>  }<br>}</p><p>class Square extends Rectangle {<br>  constructor() {<br>    super();<br>  }</p><p>  setWidth(width) {<br>    this.width = width;<br>    this.height = width;<br>  }</p><p>  setHeight(height) {<br>    this.width = height;<br>    this.height = height;<br>  }<br>}</p><p>function renderLargeRectangles(rectangles) {<br>  rectangles.forEach((rectangle) =&gt; {<br>    rectangle.setWidth(4);<br>    rectangle.setHeight(5);<br>    let area = rectangle.getArea(); // 不好：这里对正方形会返回 25，但应该是 20.<br>    rectangle.render(area);<br>  })<br>}</p><p>let rectangles = [new Rectangle(), new Rectangle(), new Square()];<br>renderLargeRectangles(rectangles);</p><p>好:</p><p>class Shape {<br>  constructor() {}</p><p>  setColor(color) {<br>    // …<br>  }</p><p>  render(area) {<br>    // …<br>  }<br>}</p><p>class Rectangle extends Shape {<br>  constructor() {<br>    super();<br>    this.width = 0;<br>    this.height = 0;<br>  }</p><p>  setWidth(width) {<br>    this.width = width;<br>  }</p><p>  setHeight(height) {<br>    this.height = height;<br>  }</p><p>  getArea() {<br>    return this.width * this.height;<br>  }<br>}</p><p>class Square extends Shape {<br>  constructor() {<br>    super();<br>    this.length = 0;<br>  }</p><p>  setLength(length) {<br>    this.length = length;<br>  }</p><p>  getArea() {<br>    return this.length * this.length;<br>  }<br>}</p><p>function renderLargeShapes(shapes) {<br>  shapes.forEach((shape) =&gt; {<br>    switch (shape.constructor.name) {<br>      case ‘Square’:<br>        shape.setLength(5);<br>      case ‘Rectangle’:<br>        shape.setWidth(4);<br>        shape.setHeight(5);<br>    }</p><pre><code>let area = shape.getArea();shape.render(area);</code></pre><p>  })<br>}</p><p>let shapes = [new Rectangle(), new Rectangle(), new Square()];<br>renderLargeShapes(shapes);</p><h3 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则(ISP)"></a>接口隔离原则(ISP)</h3><p>JavaScript 中没有接口，所以实行这个原则不能像其它语言那样严格。然而即使对 JavaScript 的弱类型系统来说，它仍然是重要的相关。</p><p>ISP 指出，“客户不应该依赖于那些他们不使用的接口。” 由于 Duck Typing 理论，接口在 JavaScript 中是个隐性契约。</p><p>在 JavaScript 中有一个很好的例子来演示这个原则，即一个拥有巨大设置对象的类。比较好的做法是不要求客户设置大量的选项，因为多数时候他们不需要所有设置。让这些选项成为可选的有助于防止“胖接口”。</p><p>不好:</p><p>class DOMTraverser {<br>  constructor(settings) {<br>    this.settings = settings;<br>    this.setup();<br>  }</p><p>  setup() {<br>    this.rootNode = this.settings.rootNode;<br>    this.animationModule.setup();<br>  }</p><p>  traverse() {<br>    // …<br>  }<br>}</p><p>let $ = new DOMTraverser({<br>  rootNode: document.getElementsByTagName(‘body’),<br>  animationModule: function() {} // 多数时候我们不需要动画<br>  // …<br>});</p><p>好:</p><p>class DOMTraverser {<br>  constructor(settings) {<br>    this.settings = settings;<br>    this.options = settings.options;<br>    this.setup();<br>  }</p><p>  setup() {<br>    this.rootNode = this.settings.rootNode;<br>    this.setupOptions();<br>  }</p><p>  setupOptions() {<br>    if (this.options.animationModule) {<br>      // …<br>    }<br>  }</p><p>  traverse() {<br>    // …<br>  }<br>}</p><p>let $ = new DOMTraverser({<br>  rootNode: document.getElementsByTagName(‘body’),<br>  options: {<br>    animationModule: function() {}<br>  }<br>});</p><h3 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则(DIP)"></a>依赖倒置原则(DIP)</h3><p>这个原则说明了两个基本问题：</p><p>1. 上层模块不应该依赖下层模块，两者都应该依赖抽象。</p><p>2. 抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</p><p>这一开始可能很难理解，但是如果你使用 Angular.js，你已经看到了对这个原则的一种实现形式：依赖注入(DI)。虽然它们不是完全相同的概念，DIP 阻止上层模块去了解下层模块的细节并设置它们。它可以通过 DI 来实现。这带来的巨大好处降低了模块间的耦合。耦合是种非常不好的开发模式，因为它让代码难以重构。</p><p>前提已经提到，JavaScript 没有接口，因此抽象依赖于隐性契约。也就是说，一个对象/类会把方法和属性暴露给另一个对象/类。在下面的例子中，隐性契约是任何用于 <code>InventoryTracker</code> 的 Request 模块都应该拥有 <code>requestItems</code> 方法。</p><p>不好:</p><p>class InventoryTracker {<br>  constructor(items) {<br>    this.items = items;</p><pre><code>// 不好：我们创建了一个依赖于特定请求的实现。// 我们应该只依赖请求方法：\`request\` 的 requestItemsthis.requester = new InventoryRequester();</code></pre><p>  }</p><p>  requestItems() {<br>    this.items.forEach((item) =&gt; {<br>      this.requester.requestItem(item);<br>    });<br>  }<br>}</p><p>class InventoryRequester {<br>  constructor() {<br>    this.REQ_METHODS = [‘HTTP’];<br>  }</p><p>  requestItem(item) {<br>    // …<br>  }<br>}</p><p>let inventoryTracker = new InventoryTracker([‘apples’, ‘bananas’]);<br>inventoryTracker.requestItems();</p><p>好:</p><p>class InventoryTracker {<br>  constructor(items, requester) {<br>    this.items = items;<br>    this.requester = requester;<br>  }</p><p>  requestItems() {<br>    this.items.forEach((item) =&gt; {<br>      this.requester.requestItem(item);<br>    });<br>  }<br>}</p><p>class InventoryRequesterV1 {<br>  constructor() {<br>    this.REQ_METHODS = [‘HTTP’];<br>  }</p><p>  requestItem(item) {<br>    // …<br>  }<br>}</p><p>class InventoryRequesterV2 {<br>  constructor() {<br>    this.REQ_METHODS = [‘WS’];<br>  }</p><p>  requestItem(item) {<br>    // …<br>  }<br>}</p><p>// 通过构建外部依赖并注入它们，我们很容易把请求模块替换成<br>// 一个使用 WebSocket 的新模块。<br>let inventoryTracker = new InventoryTracker([‘apples’, ‘bananas’], new InventoryRequesterV2());<br>inventoryTracker.requestItems();</p><h3 id="多用-ES6-类语法，少用-ES5-构造函数语法"><a href="#多用-ES6-类语法，少用-ES5-构造函数语法" class="headerlink" title="多用 ES6 类语法，少用 ES5 构造函数语法"></a>多用 ES6 类语法，少用 ES5 构造函数语法</h3><p>在经典的 ES5 的类定义中，很难找到易读的继承、构造、方法定义等。如果你需要继承(你会发现做不到)，那就应该使用类语法。不过，应该尽可能使用小函数而不是类，直到你需要更大更复杂的对象。</p><p>不好:</p><p>var Animal = function(age) {<br>    if (!(this instanceof Animal)) {<br>        throw new Error(“Instantiate Animal with `new`“);<br>    }</p><pre><code>this.age = age;</code></pre><p>};</p><p>Animal.prototype.move = function() {};</p><p>var Mammal = function(age, furColor) {<br>    if (!(this instanceof Mammal)) {<br>        throw new Error(“Instantiate Mammal with `new`“);<br>    }</p><pre><code>Animal.call(this, age);this.furColor = furColor;</code></pre><p>};</p><p>Mammal.prototype = Object.create(Animal.prototype);<br>Mammal.prototype.constructor = Mammal;<br>Mammal.prototype.liveBirth = function() {};</p><p>var Human = function(age, furColor, languageSpoken) {<br>    if (!(this instanceof Human)) {<br>        throw new Error(“Instantiate Human with `new`“);<br>    }</p><pre><code>Mammal.call(this, age, furColor);this.languageSpoken = languageSpoken;</code></pre><p>};</p><p>Human.prototype = Object.create(Mammal.prototype);<br>Human.prototype.constructor = Human;<br>Human.prototype.speak = function() {};</p><p>好:</p><p>class Animal {<br>    constructor(age) {<br>        this.age = age;<br>    }</p><pre><code>move() {}</code></pre><p>}</p><p>class Mammal extends Animal {<br>    constructor(age, furColor) {<br>        super(age);<br>        this.furColor = furColor;<br>    }</p><pre><code>liveBirth() {}</code></pre><p>}</p><p>class Human extends Mammal {<br>    constructor(age, furColor, languageSpoken) {<br>        super(age, furColor);<br>        this.languageSpoken = languageSpoken;<br>    }</p><pre><code>speak() {}</code></pre><p>}</p><h3 id="使用方法链"><a href="#使用方法链" class="headerlink" title="使用方法链"></a>使用方法链</h3><p>在这里我的意见与《代码整洁之道》的观点不同。有人认为方法链不整洁，而且违反了<a href="https://en.wikipedia.org/wiki/Law_of_Demeter" target="_blank" rel="noopener">得墨忒耳定律</a>。也许他们是对的，但这个模式在 JavaScript 中非常有用，你可以很多库中看到，比如 jQuery 和 Lodash。它让代码变得既简洁又有表现力。在类中，只需要在每个函数结束前返回 <code>this</code>，就实现了链式调用的类方法。</p><p>不好:</p><p>class Car {<br>  constructor() {<br>    this.make = ‘Honda’;<br>    this.model = ‘Accord’;<br>    this.color = ‘white’;<br>  }</p><p>  setMake(make) {<br>    this.name = name;<br>  }</p><p>  setModel(model) {<br>    this.model = model;<br>  }</p><p>  setColor(color) {<br>    this.color = color;<br>  }</p><p>  save() {<br>    console.log(this.make, this.model, this.color);<br>  }<br>}</p><p>let car = new Car();<br>car.setColor(‘pink’);<br>car.setMake(‘Ford’);<br>car.setModel(‘F-150’)<br>car.save();</p><p>好:</p><p>class Car {<br>  constructor() {<br>    this.make = ‘Honda’;<br>    this.model = ‘Accord’;<br>    this.color = ‘white’;<br>  }</p><p>  setMake(make) {<br>    this.name = name;<br>    // NOTE: 返回 this 以实现链式调用<br>    return this;<br>  }</p><p>  setModel(model) {<br>    this.model = model;<br>    // NOTE: 返回 this 以实现链式调用<br>    return this;<br>  }</p><p>  setColor(color) {<br>    this.color = color;<br>    // NOTE: 返回 this 以实现链式调用<br>    return this;<br>  }</p><p>  save() {<br>    console.log(this.make, this.model, this.color);<br>  }<br>}</p><p>let car = new Car()<br>  .setColor(‘pink’)<br>  .setMake(‘Ford’)<br>  .setModel(‘F-150’)<br>  .save();</p><h3 id="多用组合，少用继承"><a href="#多用组合，少用继承" class="headerlink" title="多用组合，少用继承"></a>多用组合，少用继承</h3><p>大家都知道 GoF 的<a href="https://en.wikipedia.org/wiki/Design_Patterns" target="_blank" rel="noopener">设计模式</a>，其中提到应该多用组合而不是继承。对于继承和组合，都有大量的理由在支撑，但这个准则的要点在于，你的想法本能地会想到继承，但这时候不防多思考一下用组合是否能更好的处理问题——某些时候，的确能。</p><p>你可能会考虑：“我什么时候该用继承？”这取决于你遇到的问题。这里有一个不错的清单说明了什么时候用继承比用组合更合适：</p><ol><li><p>你的继承是一个“is-a”关系，而不是“has-a”关系(Animal-&gt;Human 对比 User-&gt;UserDetails)。</p></li><li><p>可以从基础复用代码 (人可以像所有动物一样移动)。</p></li><li><p>你想通过修改基础来实现对所有子类的全局性更改。(改变动物移动时的热量消耗)。</p></li></ol><p>不好:</p><p>class Employee {<br>  constructor(name, email) {<br>    this.name = name;<br>    this.email = email;<br>  }</p><p>  // …<br>}</p><p>// 这样不好，因为 Employees “拥有” 税务数据。EmployeeTaxData 不是属于 Employee 的一个类型<br>class EmployeeTaxData extends Employee {<br>  constructor(ssn, salary) {<br>    super();<br>    this.ssn = ssn;<br>    this.salary = salary;<br>  }</p><p>  // …<br>}</p><p>好:</p><p>class Employee {<br>  constructor(name, email) {<br>    this.name = name;<br>    this.email = email;</p><p>  }</p><p>  setTaxData(ssn, salary) {<br>    this.taxData = new EmployeeTaxData(ssn, salary);<br>  }<br>  // …<br>}</p><p>class EmployeeTaxData {<br>  constructor(ssn, salary) {<br>    this.ssn = ssn;<br>    this.salary = salary;<br>  }</p><p>  // …<br>}</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试比生产更重要。如果你不进行测试，或者测试的量不够，那你就不能肯定你写的代码不会造成破坏。测试数量依靠你的开发团队来决定，但 100% 覆盖率(所有语句和分支)能让你拥有巨大的信心，也能使程序员们安心。也就是说，你需要一个不错的测试框架，还需要一个<a href="http://gotwarlost.github.io/istanbul/" target="_blank" rel="noopener">好的覆盖检查工具</a>.</p><p>没有什么理由可以让你不写测试。这里有 <a href="http://jstherightway.org/#testing-tools" target="_blank" rel="noopener">大量不错的 JS 测试框架</a>，可以去找个你们团队喜欢的来用。如果你找一个适合在你的团队中使用的工作，就把为每个新产生的特性/方法添加测试作为目标。如果你喜欢测试驱动开发(TDD)的方法，非常好，但要注意在让你的测试覆盖所有特性，或者重构过的代码。</p><h3 id="每次测试一个概念"><a href="#每次测试一个概念" class="headerlink" title="每次测试一个概念"></a>每次测试一个概念</h3><p>不好:</p><p>const assert = require(‘assert’);</p><p>describe(‘MakeMomentJSGreatAgain’, function() {<br>  it(‘handles date boundaries’, function() {<br>    let date;</p><pre><code>date = new MakeMomentJSGreatAgain(&apos;1/1/2015&apos;);date.addDays(30);date.shouldEqual(&apos;1/31/2015&apos;);date = new MakeMomentJSGreatAgain(&apos;2/1/2016&apos;);date.addDays(28);assert.equal(&apos;02/29/2016&apos;, date);date = new MakeMomentJSGreatAgain(&apos;2/1/2015&apos;);date.addDays(28);assert.equal(&apos;03/01/2015&apos;, date);</code></pre><p>  });<br>});</p><p>好:</p><p>const assert = require(‘assert’);</p><p>describe(‘MakeMomentJSGreatAgain’, function() {<br>  it(‘handles 30-day months’, function() {<br>    let date = new MakeMomentJSGreatAgain(‘1/1/2015’);<br>    date.addDays(30);<br>    date.shouldEqual(‘1/31/2015’);<br>  });</p><p>  it(‘handles leap year’, function() {<br>    let date = new MakeMomentJSGreatAgain(‘2/1/2016’);<br>    date.addDays(28);<br>    assert.equal(‘02/29/2016’, date);<br>  });</p><p>  it(‘handles non-leap year’, function() {<br>    let date = new MakeMomentJSGreatAgain(‘2/1/2015’);<br>    date.addDays(28);<br>    assert.equal(‘03/01/2015’, date);<br>  });<br>});</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="使用-Promise-而不是回调"><a href="#使用-Promise-而不是回调" class="headerlink" title="使用 Promise 而不是回调"></a>使用 Promise 而不是回调</h3><p>回调并不整洁，它会导致过多的嵌套。ES6 的 Promise 是个内置的全局类型。使用它！</p><p>不好:</p><p>require(‘request’).get(‘<a href="https://en.wikipedia.org/wiki/Robert\_Cecil\_Martin&#39;" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Robert\_Cecil\_Martin&#39;</a>, function(err, response) {<br>  if (err) {<br>    console.error(err);<br>  }<br>  else {<br>    require(‘fs’).writeFile(‘article.html’, response.body, function(err) {<br>      if (err) {<br>        console.error(err);<br>      } else {<br>        console.log(‘File written’);<br>      }<br>    })<br>  }<br>})</p><p>好:</p><p>require(‘request-promise’).get(‘<a href="https://en.wikipedia.org/wiki/Robert\_Cecil\_Martin&#39;" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Robert\_Cecil\_Martin&#39;</a>)<br>  .then(function(response) {<br>    return require(‘fs-promise’).writeFile(‘article.html’, response);<br>  })<br>  .then(function() {<br>    console.log(‘File written’);<br>  })<br>  .catch(function(err) {<br>    console.error(err);<br>  })</p><h3 id="async-await-比-Promise-还整洁"><a href="#async-await-比-Promise-还整洁" class="headerlink" title="async/await 比 Promise 还整洁"></a>async/await 比 Promise 还整洁</h3><p>与回调相当，Promise 已经相当整洁了，但 ES7 带来了更整洁的解决方案 —— async 和 await。你要做的事情就是在一个函数前加上 <code>async</code> 关键字，然后写下命令形式的逻辑，而不再需要 <code>then</code> 链。现在可以使用这个 ES7 特性带来的便利！</p><p>不好:</p><p>require(‘request-promise’).get(‘<a href="https://en.wikipedia.org/wiki/Robert\_Cecil\_Martin&#39;" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Robert\_Cecil\_Martin&#39;</a>)<br>  .then(function(response) {<br>    return require(‘fs-promise’).writeFile(‘article.html’, response);<br>  })<br>  .then(function() {<br>    console.log(‘File written’);<br>  })<br>  .catch(function(err) {<br>    console.error(err);<br>  })</p><p>好:</p><p>async function getCleanCodeArticle() {<br>  try {<br>    var request = await require(‘request-promise’)<br>    var response = await request.get(‘<a href="https://en.wikipedia.org/wiki/Robert\_Cecil\_Martin&#39;)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Robert\_Cecil\_Martin&#39;)</a>;<br>    var fileHandle = await require(‘fs-promise’);</p><pre><code>await fileHandle.writeFile(&apos;article.html&apos;, response);console.log(&apos;File written&apos;);</code></pre><p>  } catch(err) {<br>      console.log(err);<br>    }<br>  }</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>抛出错误是件好事！这表示运行时已经成功检测到程序出错了，它停止当前调用框上的函数执行，并中止进程(在 Node 中)，最后在控制台通知你，并输出栈跟踪信息。</p><h3 id="不要忽略捕捉到的错误"><a href="#不要忽略捕捉到的错误" class="headerlink" title="不要忽略捕捉到的错误"></a>不要忽略捕捉到的错误</h3><p>捕捉到错误却什么也不错，你就失去了纠正错误的机会。多数情况下把错误记录到控制台(<code>console.log</code>)也不比忽略它好多少，因为在少量的控制台信息中很难发现这一条。如果尝试在 <code>try/catch</code> 中封装代码，就意味着你知道这里可能发生错，你应该在错误发生的时候有应对的计划、或者处理办法。</p><p>不好:</p><p>try {<br>  functionThatMightThrow();<br>} catch (error) {<br>  console.log(error);<br>}</p><p>好:</p><p>try {<br>  functionThatMightThrow();<br>} catch (error) {<br>  // 选择之一(比 console.log 更闹心)：<br>  console.error(error);<br>  // 另一个选择：<br>  notifyUserOfError(error);<br>  // 另一个选择：<br>  reportErrorToService(error);<br>  // 或者所有上述三种选择！<br>}</p><h3 id="不要忽视被拒绝的Promise"><a href="#不要忽视被拒绝的Promise" class="headerlink" title="不要忽视被拒绝的Promise"></a>不要忽视被拒绝的Promise</h3><p>这一条与不要忽略从 <code>try/catch</code> 捕捉到的错误有相同的原因。</p><p>不好:</p><p>getdata()<br>.then(data =&gt; {<br>  functionThatMightThrow(data);<br>})<br>.catch(error =&gt; {<br>  console.log(error);<br>});</p><p>好:</p><p>getdata()<br>.then(data =&gt; {<br>  functionThatMightThrow(data);<br>})<br>.catch(error =&gt; {<br>  // 选择之一(比 console.log 更闹心)：<br>  console.error(error);<br>  // 另一个选择：<br>  notifyUserOfError(error);<br>  // 另一个选择：<br>  reportErrorToService(error);<br>  // 或者所有上述三种选择！<br>});</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>格式是个很主观的东西，像这里提到的许多规则一，你不必完全遵循。要点不在于争论格式。<a href="http://standardjs.com/rules.html" target="_blank" rel="noopener">大量工具</a> 可以自动处理优化格式。用一个！让工程师争论格式问题简直就是在浪费时间和金钱。</p><p>对于那些不能自动处理的格式(可以自动处理的包括缩进、Tab或空格、双引号或单引用等)，就看看这里的指导。</p><h3 id="使用一致的大小写"><a href="#使用一致的大小写" class="headerlink" title="使用一致的大小写"></a>使用一致的大小写</h3><p>JavaScript 是无类型的，所以大小写可以帮助你了解变量、函数等。这些规则具有较强的主观性，所以你的团队应该选择需要的。重点不在于你选择了什么，而在于要始终保持一致。</p><p>不好:</p><p>var DAYS_IN_WEEK = 7;<br>var daysInMonth = 30;</p><p>var songs = [‘Back In Black’, ‘Stairway to Heaven’, ‘Hey Jude’];<br>var Artists = [‘ACDC’, ‘Led Zeppelin’, ‘The Beatles’];</p><p>function eraseDatabase() {}<br>function restore_database() {}</p><p>class animal {}<br>class Alpaca {}</p><p>好:</p><p>var DAYS_IN_WEEK = 7;<br>var DAYS_IN_MONTH = 30;</p><p>var songs = [‘Back In Black’, ‘Stairway to Heaven’, ‘Hey Jude’];<br>var artists = [‘ACDC’, ‘Led Zeppelin’, ‘The Beatles’];</p><p>function eraseDatabase() {}<br>function restoreDatabase() {}</p><p>class Animal {}<br>class Alpaca {}</p><h3 id="函数调用者和被调用者应该尽可能放在一起"><a href="#函数调用者和被调用者应该尽可能放在一起" class="headerlink" title="函数调用者和被调用者应该尽可能放在一起"></a>函数调用者和被调用者应该尽可能放在一起</h3><p>如果一个函数调用另一个函数，那应该让他们在源文件中的位置非常接近。理想情况下应该把调用者放在被调用者的正上方，这会让你的代码更易读，因为我们都习惯从上往下读代码，就像读报纸那样。</p><p>不好:</p><p>class PerformanceReview {<br>  constructor(employee) {<br>    this.employee = employee;<br>  }</p><p>  lookupPeers() {<br>    return db.lookup(this.employee, ‘peers’);<br>  }</p><p>  lookupMananger() {<br>    return db.lookup(this.employee, ‘manager’);<br>  }</p><p>  getPeerReviews() {<br>    let peers = this.lookupPeers();<br>    // …<br>  }</p><p>  perfReview() {<br>      getPeerReviews();<br>      getManagerReview();<br>      getSelfReview();<br>  }</p><p>  getManagerReview() {<br>    let manager = this.lookupManager();<br>  }</p><p>  getSelfReview() {<br>    // …<br>  }<br>}</p><p>let review = new PerformanceReview(user);<br>review.perfReview();</p><p>好:</p><p>class PerformanceReview {<br>  constructor(employee) {<br>    this.employee = employee;<br>  }</p><p>  perfReview() {<br>      getPeerReviews();<br>      getManagerReview();<br>      getSelfReview();<br>  }</p><p>  getPeerReviews() {<br>    let peers = this.lookupPeers();<br>    // …<br>  }</p><p>  lookupPeers() {<br>    return db.lookup(this.employee, ‘peers’);<br>  }</p><p>  getManagerReview() {<br>    let manager = this.lookupManager();<br>  }</p><p>  lookupMananger() {<br>    return db.lookup(this.employee, ‘manager’);<br>  }</p><p>  getSelfReview() {<br>    // …<br>  }<br>}</p><p>let review = new PerformanceReview(employee);<br>review.perfReview();</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="只注释业务逻辑复杂的内容"><a href="#只注释业务逻辑复杂的内容" class="headerlink" title="只注释业务逻辑复杂的内容"></a>只注释业务逻辑复杂的内容</h3><p>注释是用来解释代码的，而不是必须的。好的代码应该 自注释。</p><p>不好:</p><p>function hashIt(data) {<br>  // Hash 码<br>  var hash = 0;</p><p>  // 字符串长度<br>  var length = data.length;</p><p>  // 遍历数据中所有字符<br>  for (var i = 0; i &lt; length; i++) {<br>    // 获取字符编码<br>    var char = data.charCodeAt(i);<br>    // 生成 Hash<br>    hash = ((hash &lt;&lt; 5) - hash) + char;<br>    // 转换为32位整数<br>    hash = hash &amp; hash;<br>  }<br>}</p><p>好:</p><p>function hashIt(data) {<br>  var hash = 0;<br>  var length = data.length;</p><p>  for (var i = 0; i &lt; length; i++) {<br>    var char = data.charCodeAt(i);<br>    hash = ((hash &lt;&lt; 5) - hash) + char;</p><pre><code>// 转换为32位整数hash = hash &amp; hash;</code></pre><p>  }<br>}</p><h3 id="不要把注释掉的代码留在代码库中"><a href="#不要把注释掉的代码留在代码库中" class="headerlink" title="不要把注释掉的代码留在代码库中"></a>不要把注释掉的代码留在代码库中</h3><p>版本控制存在的原因就是保存你的历史代码。</p><p>不好:</p><p>doStuff();<br>// doOtherStuff();<br>// doSomeMoreStuff();<br>// doSoMuchStuff();</p><p>好:</p><p>doStuff();</p><h3 id="不需要日志式的注释"><a href="#不需要日志式的注释" class="headerlink" title="不需要日志式的注释"></a>不需要日志式的注释</h3><p>记住，使用版本控制！没用的代码、注释掉的代码，尤其是日志式的注释。用 <code>git log</code> 来获取历史信息！</p><p>不好:</p><p>/**<br> * 2016-12-20: Removed monads, didn’t understand them (RM)<br> * 2016-10-01: Improved using special monads (JP)<br> * 2016-02-03: Removed type-checking (LI)<br> * 2015-03-14: Added combine with type-checking (JR)<br> */<br>function combine(a, b) {<br>  return a + b;<br>}</p><p>好:</p><p>function combine(a, b) {<br>  return a + b;<br>}</p><h3 id="避免位置标记"><a href="#避免位置标记" class="headerlink" title="避免位置标记"></a>避免位置标记</h3><p>位置标记通常只会添加垃圾信息。通过对函数或变量名以及适当的缩进就能为代码带来良好的可视化结构。</p><p>不好:</p><p>////////////////////////////////////////////////////////////////////////////////<br>// Scope Model Instantiation<br>////////////////////////////////////////////////////////////////////////////////<br>let $scope.model = {<br>  menu: ‘foo’,<br>  nav: ‘bar’<br>};</p><p>////////////////////////////////////////////////////////////////////////////////<br>// Action setup<br>////////////////////////////////////////////////////////////////////////////////<br>let actions = function() {<br>  // …<br>}</p><p>好:</p><p>let $scope.model = {<br>  menu: ‘foo’,<br>  nav: ‘bar’<br>};</p><p>let actions = function() {<br>  // …<br>}</p><h3 id="避免在源文件中添加版权注释"><a href="#避免在源文件中添加版权注释" class="headerlink" title="避免在源文件中添加版权注释"></a>避免在源文件中添加版权注释</h3><p>这是代码文件树顶层的 <code>LICENSE</code> 文件应该干的事情。</p><p>不好:</p><p>/*<br>The MIT License (MIT)</p><p>Copyright (c) 2016 Ryan McDermott</p><p>Permission is hereby granted, free of charge, to any person obtaining a copy<br>of this software and associated documentation files (the “Software”), to deal<br>in the Software without restriction, including without limitation the rights<br>to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br>copies of the Software, and to permit persons to whom the Software is<br>furnished to do so, subject to the following conditions:</p><p>The above copyright notice and this permission notice shall be included in all<br>copies or substantial portions of the Software.</p><p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br>FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br>AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br>LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br>OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE<br>SOFTWARE<br>*/</p><p>function calculateBill() {<br>  // …<br>}</p><p>好:</p><p>function calculateBill() {<br>  // …<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;# &lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#概述&quot;&gt;概述&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#变量&quot;
      
    
    </summary>
    
      <category term="学习资料" scheme="https://sensitivemix.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
      <category term="Tutorial" scheme="https://sensitivemix.github.io/tags/Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 状态码整理</title>
    <link href="https://sensitivemix.github.io/2018/12/01/HTTP-%E7%8A%B6%E6%80%81%E7%A0%81%E6%95%B4%E7%90%86/"/>
    <id>https://sensitivemix.github.io/2018/12/01/HTTP-状态码整理/</id>
    <published>2018-12-01T06:30:51.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在浏览网页或是在查看服务器日志时，常会遇到3位数字的状态码，这3位数字是什么意思呢?其实，这3位数字是HTTP状态码，用来表示网页服务器HTTP响应状态，简言之就是Web服务器用来告诉客户端发生了什么事。</p><p>1xx：信息</p><p>　　1XX类型的状态码是临时响应，代表着请求已经被接受，但需要继续处理，值得注意的是，由于HTTP/1.0 协议中并没有定义1XX状态码，除非在试验条件下，服务器是禁止向客户端发送1XX响应的。</p><p>　　100 Continue — 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。</p><p>　　101 Switching Protocols — 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。</p><p>　　102 Processing — 由WebDAV(RFC 2518)扩展的状态码，代表处理将被继续执行。</p><p>2xx：成功</p><p>　　2XX类型的状态码代表着请求已经被服务器接收、理解、并接受</p><p>　　200 OK：请求成功(其后是对GET和POST请求的应答文档。)</p><p>　　201 Created — 请求被创建完成，同时新的资源被创建。</p><p>　　202 Accepted — 供处理的请求已被接受，但是处理未完成。</p><p>　　203 Non-authoritative Information — 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。</p><p>　　204 No Content — 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</p><p>　　205 Reset Content — 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。</p><p>　　206 Partial Content — 客户发送了一个带有Range头的GET请求，服务器完成了它。</p><p>　　207 Multi-Status — 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p><p>3xx: 重定向</p><p>　　3XX这类状态码代表着客户端需要采取进一步的操作才能完成请求，通常，这些状态码是用来重定向的，按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。</p><p>　　300 Multiple Choices — 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。</p><p>　　301 Moved Permanently — 所请求的页面已经转移至新的url。</p><p>　　302 Found — 所请求的页面已经临时转移至新的url。</p><p>　　303 See Other — 所请求的页面可在别的url下被找到。</p><p>　　304 Not Modified — 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求(一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档)。服务器告诉客户，原来缓冲的文档还可以继续使用。</p><p>　　305 Use Proxy — 客户请求的文档应该通过Location头所指明的代理服务器提取。</p><p>　　306 Unused — 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。</p><p>　　307 Temporary Redirect — 被请求的页面已经临时移至新的url。</p><p>4xx：客户端错误</p><p>　　4XX类型的状态码代表着客户端可能发生了错误，阻碍了服务器的处理，</p><p>　　400 Bad Request — 服务器未能理解请求或是请求参数有误。</p><p>　　401 Unauthorized — 被请求的页面需要用户名和密码。</p><p>　　402 Payment Required — 此代码尚无法使用(为了将来可能的需求而预留的。)</p><p>　　403 Forbidden — 对被请求页面的访问被禁止。</p><p>　　404 Not Found — 服务器无法找到被请求的页面。</p><p>　　405 Method Not Allowed — 请求中指定的方法不被允许。</p><p>　　406 Not Acceptable — 服务器生成的响应无法被客户端所接受。</p><p>　　407 Proxy Authentication Required — 用户必须首先使用代理服务器进行验证，这样请求才会被处理。</p><p>　　408 Request Timeout — 请求超出了服务器的等待时间。</p><p>　　409 Conflict — 由于冲突，请求无法被完成。</p><p>　　410 Gone — 被请求的页面不可用。</p><p>　　411 Length Required”Content-Length — “ 未被定义。如果无此内容，服务器不会接受请求。</p><p>　　412 Precondition Failed — 请求中的前提条件被服务器评估为失败。</p><p>　　413 Request Entity Too Large — 由于所请求的实体的太大，服务器不会接受请求。</p><p>　　414 Request-url Too Long — 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。</p><p>　　415 Unsupported Media Type — 由于媒介类型不被支持，服务器不会接受请求。</p><p>　　416 — 服务器不能满足客户在请求中指定的Range头。</p><p>　　417 Expectation Failed</p><p>5xx： 服务器错误</p><p>　　这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。</p><p>　　500 Internal Server Error — 请求未完成。服务器遇到不可预知的情况。</p><p>　　501 Not Implemented — 请求未完成。服务器不支持所请求的功能。</p><p>　　502 Bad Gateway — 请求未完成。服务器从上游服务器收到一个无效的响应。</p><p>　　503 Service Unavailable — 请求未完成。服务器临时过载或当机。</p><p>　　504 Gateway Timeout — 网关超时。</p><p>　　505 HTTP Version Not Supported — 服务器不支持请求中指明的HTTP协议版本。</p><p>　　http协议响应状态码看起来很多，但若不是需要做AJAX，REST,网络爬虫，机器人等程序，我们只需要了解常见的200、302.304.404、503这几个状态码就好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们在浏览网页或是在查看服务器日志时，常会遇到3位数字的状态码，这3位数字是什么意思呢?其实，这3位数字是HTTP状态码，用来表示网页服务器HTTP响应状态，简言之就是Web服务器用来告诉客户端发生了什么事。&lt;/p&gt;
&lt;p&gt;1xx：信息&lt;/p&gt;
&lt;p&gt;　　1XX类型的状态
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://sensitivemix.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http" scheme="https://sensitivemix.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>彻底搞懂 Javascript 执行机制</title>
    <link href="https://sensitivemix.github.io/2018/12/01/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-Javascript-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>https://sensitivemix.github.io/2018/12/01/彻底搞懂-Javascript-执行机制/</id>
    <published>2018-12-01T06:28:09.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这一次，彻底弄懂-JavaScript-执行机制"><a href="#这一次，彻底弄懂-JavaScript-执行机制" class="headerlink" title="这一次，彻底弄懂 JavaScript 执行机制"></a>这一次，彻底弄懂 JavaScript 执行机制</h1><p>本文的目的就是要保证你彻底弄懂javascript的执行机制，如果读完本文还不懂，可以揍我。</p><p>不论你是javascript新手还是老鸟，不论是面试求职，还是日常开发工作，我们经常会遇到这样的情况：给定的几行代码，我们需要知道其输出内容和顺序。因为javascript是一门单线程语言，所以我们可以得出结论：</p><ul><li>javascript是按照语句出现的顺序执行的</li></ul><p>看到这里读者要打人了：我难道不知道js是一行一行执行的？还用你说？稍安勿躁，正因为js是一行一行执行的，所以我们以为js都是这样的：</p><p>let a = ‘1’;console.log(a);</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/20/15fd87f7221d0dbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>然而实际上js是这样的：</p><p>setTimeout(function(){    console.log(‘定时器开始啦’)});<br>new Promise(function(resolve){    console.log(‘马上执行for循环啦’);    for(var i = 0; i &lt; 10000; i++){        i == 99 &amp;&amp; resolve();    }}).then(function(){    console.log(‘执行then函数啦’)});</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/20/15fd87d38acc4905?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>依照js是按照语句出现的顺序执行这个理念，我自信的写下输出结果：</p><p>//“定时器开始啦”//“马上执行for循环啦”//“执行then函数啦”//“代码执行结束”</p><p>去chrome上验证下，结果完全不对，瞬间懵了，说好的一行一行执行的呢？</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/20/15fd8840f3c3f109?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>我们真的要彻底弄明白javascript的执行机制了。</p><h3 id="1-关于javascript"><a href="#1-关于javascript" class="headerlink" title="1.关于javascript"></a>1.关于javascript</h3><p>javascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！</p><h3 id="2-javascript事件循环"><a href="#2-javascript事件循环" class="headerlink" title="2.javascript事件循环"></a>2.javascript事件循环</h3><p>既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：</p><ul><li>同步任务</li><li>异步任务</li></ul><p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：</p><p><img src="https://tcs-ga.teambition.net/thumbnail/1111cb6ce848e9b5805715a9f8b19c200c4b/w/799/h/668" alt="Screenshot-0.png">  </p><p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdd88994142347?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>导图要表达的内容用文字来表述的话：</p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><p>我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><p>说了这么多文字，不如直接一段代码更直白：</p><p>let data = [];<br>$.ajax({<br>    url:<a href="http://www.javascript.com" target="_blank" rel="noopener">www.javascript.com</a>,<br>    data:data,<br>    success:() =&gt; {<br>        console.log(‘发送成功!’);<br>    }<br>})<br>console.log(‘代码执行结束’);</p><p>上面是一段简易的<code>ajax</code>请求代码：</p><ul><li>ajax进入Event Table，注册回调函数<code>success</code>。</li><li>执行<code>console.log(&#39;代码执行结束&#39;)</code>。</li><li>ajax事件完成，回调函数<code>success</code>进入Event Queue。</li><li>主线程从Event Queue读取回调函数<code>success</code>并执行。</li></ul><p>相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。</p><h3 id="3-又爱又恨的setTimeout"><a href="#3-又爱又恨的setTimeout" class="headerlink" title="3.又爱又恨的setTimeout"></a>3.又爱又恨的setTimeout</h3><p>大名鼎鼎的<code>setTimeout</code>无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：</p><p>setTimeout(() =&gt; {<br>    console.log(‘延时3秒’);<br>},3000)</p><p>渐渐的<code>setTimeout</code>用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？</p><p>先看一个例子：</p><p>setTimeout(() =&gt; {<br>    task();<br>},3000)<br>console.log(‘执行console’);</p><p>根据前面我们的结论，<code>setTimeout</code>是异步的，应该先执行<code>console.log</code>这个同步任务，所以我们的结论是：</p><p>//执行console<br>//task()</p><p>去验证一下，结果正确！<br>然后我们修改一下前面的代码：</p><p>setTimeout(() =&gt; {<br>    task()<br>},3000)</p><p>sleep(10000000)</p><p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行<code>task()</code>需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？</p><p>这时候我们需要重新理解<code>setTimeout</code>的定义。我们先说上述代码是怎么执行的：</p><ul><li><code>task()</code>进入Event Table并注册,计时开始。</li><li>执行<code>sleep</code>函数，很慢，非常慢，计时仍在继续。</li><li>3秒到了，计时事件<code>timeout</code>完成，<code>task()</code>进入Event Queue，但是<code>sleep</code>也太慢了吧，还没执行完，只好等着。</li><li><code>sleep</code>终于执行完了，<code>task()</code>终于从Event Queue进入了主线程执行。</li></ul><p>上述的流程走完，我们知道<code>setTimeout</code>这个函数，是经过指定时间后，把要执行的任务(本例中为<code>task()</code>)加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p><p>我们还经常遇到<code>setTimeout(fn,0)</code>这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？</p><p>答案是不会的，<code>setTimeout(fn,0)</code>的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：</p><p>//代码1<br>console.log(‘先执行这里’);<br>setTimeout(() =&gt; {<br>    console.log(‘执行啦’)<br>},0);</p><p>//代码2<br>console.log(‘先执行这里’);<br>setTimeout(() =&gt; {<br>    console.log(‘执行啦’)<br>},3000);</p><p>代码1的输出结果是：</p><p>//先执行这里<br>//执行啦</p><p>代码2的输出结果是：</p><p>//先执行这里<br>// … 3s later<br>// 执行啦</p><p>关于<code>setTimeout</code>要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。</p><h3 id="4-又恨又爱的setInterval"><a href="#4-又恨又爱的setInterval" class="headerlink" title="4.又恨又爱的setInterval"></a>4.又恨又爱的setInterval</h3><p>上面说完了<code>setTimeout</code>，当然不能错过它的孪生兄弟<code>setInterval</code>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<code>setInterval</code>会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p><p>唯一需要注意的一点是，对于<code>setInterval(fn,ms)</code>来说，我们已经知道不是每过<code>ms</code>秒会执行一次<code>fn</code>，而是每过<code>ms</code>秒，会有<code>fn</code>进入Event Queue。一旦<code>setInterval</code>的回调函数<code>fn</code>执行时间超过了延迟时间<code>ms</code>，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。</p><h3 id="5-Promise与process-nextTick-callback"><a href="#5-Promise与process-nextTick-callback" class="headerlink" title="5.Promise与process.nextTick(callback)"></a>5.Promise与process.nextTick(callback)</h3><p>传统的定时器我们已经研究过了，接着我们探究<code>Promise</code>与<code>process.nextTick(callback)</code>的表现。</p><p><code>Promise</code>的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的<a href="https://link.juejin.im/?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise" target="_blank" rel="noopener">Promise</a>。而<code>process.nextTick(callback)</code>类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。</p><p>我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p><ul><li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li><li>micro-task(微任务)：Promise，process.nextTick</li></ul><p>不同类型的任务会进入对应的Event Queue，比如<code>setTimeout</code>和<code>setInterval</code>会进入相同的Event Queue。</p><p>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明：</p><p>setTimeout(function() {<br>    console.log(‘setTimeout’);<br>})</p><p>new Promise(function(resolve) {<br>    console.log(‘promise’);<br>}).then(function() {<br>    console.log(‘then’);<br>})</p><p>console.log(‘console’);</p><ul><li>这段代码作为宏任务，进入主线程。</li><li>先遇到<code>setTimeout</code>，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)</li><li>接下来遇到了<code>Promise</code>，<code>new Promise</code>立即执行，<code>then</code>函数分发到微任务Event Queue。</li><li>遇到<code>console.log()</code>，立即执行。</li><li>好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了<code>then</code>在微任务Event Queue里面，执行。</li><li>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中<code>setTimeout</code>对应的回调函数，立即执行。</li><li>结束。</li></ul><p>事件循环，宏任务，微任务的关系如图所示：</p><p><img src="https://tcs-ga.teambition.net/thumbnail/1111b774ba9651d33b95de3cf09cc6075e71/w/800/h/670" alt="Screenshot-1.png">  </p><p>我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：</p><p>console.log(‘1’);</p><p>setTimeout(function() {<br>    console.log(‘2’);<br>    process.nextTick(function() {<br>        console.log(‘3’);<br>    })<br>    new Promise(function(resolve) {<br>        console.log(‘4’);<br>        resolve();<br>    }).then(function() {<br>        console.log(‘5’)<br>    })<br>})<br>process.nextTick(function() {<br>    console.log(‘6’);<br>})<br>new Promise(function(resolve) {<br>    console.log(‘7’);<br>    resolve();<br>}).then(function() {<br>    console.log(‘8’)<br>})</p><p>setTimeout(function() {<br>    console.log(‘9’);<br>    process.nextTick(function() {<br>        console.log(‘10’);<br>    })<br>    new Promise(function(resolve) {<br>        console.log(‘11’);<br>        resolve();<br>    }).then(function() {<br>        console.log(‘12’)<br>    })<br>})</p><p>第一轮事件循环流程分析如下：</p><ul><li>整体script作为第一个宏任务进入主线程，遇到<code>console.log</code>，输出1。</li><li>遇到<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。我们暂且记为<code>setTimeout1</code>。</li><li>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。我们记为<code>process1</code>。</li><li>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出7。<code>then</code>被分发到微任务Event Queue中。我们记为<code>then1</code>。</li><li>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，我们记为<code>setTimeout2</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout1</td><td>process1</td></tr><tr><td>setTimeout2</td><td>then1</td></tr></tbody></table><ul><li><p>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</p></li><li><p>我们发现了<code>process1</code>和<code>then1</code>两个微任务。</p></li><li><p>执行<code>process1</code>,输出6。</p></li><li>执行<code>then1</code>，输出8。</li></ul><p>好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从<code>setTimeout1</code>宏任务开始：</p><ul><li>首先输出2。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为<code>process2</code>。<code>new Promise</code>立即执行输出4，<code>then</code>也分发到微任务Event Queue中，记为<code>then2</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout2</td><td>process2</td></tr><tr><td></td><td>then2</td></tr></tbody></table><ul><li>第二轮事件循环宏任务结束，我们发现有<code>process2</code>和<code>then2</code>两个微任务可以执行。</li><li>输出3。</li><li>输出5。</li><li>第二轮事件循环结束，第二轮输出2，4，3，5。</li><li>第三轮事件循环开始，此时只剩setTimeout2了，执行。</li><li>直接输出9。</li><li>将<code>process.nextTick()</code>分发到微任务Event Queue中。记为<code>process3</code>。</li><li>直接执行<code>new Promise</code>，输出11。</li><li>将<code>then</code>分发到微任务Event Queue中，记为<code>then3</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td></td><td>process3</td></tr><tr><td></td><td>then3</td></tr></tbody></table><ul><li>第三轮事件循环宏任务执行结束，执行两个微任务<code>process3</code>和<code>then3</code>。</li><li>输出10。</li><li>输出12。</li><li>第三轮事件循环结束，第三轮输出9，11，10，12。</li></ul><p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。<br>(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p><h3 id="6-写在最后"><a href="#6-写在最后" class="headerlink" title="6.写在最后"></a>6.写在最后</h3><h4 id="1-js的异步"><a href="#1-js的异步" class="headerlink" title="(1)js的异步"></a>(1)js的异步</h4><p>我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。</p><h4 id="2-事件循环Event-Loop"><a href="#2-事件循环Event-Loop" class="headerlink" title="(2)事件循环Event Loop"></a>(2)事件循环Event Loop</h4><p>事件循环是js实现异步的一种方法，也是js的执行机制。</p><h4 id="3-javascript的执行和运行"><a href="#3-javascript的执行和运行" class="headerlink" title="(3)javascript的执行和运行"></a>(3)javascript的执行和运行</h4><p>执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。</p><h4 id="4-setImmediate"><a href="#4-setImmediate" class="headerlink" title="(4)setImmediate"></a>(4)setImmediate</h4><p>微任务和宏任务还有很多种类，比如<code>setImmediate</code>等等，执行都是有共同点的，有兴趣的同学可以自行了解。</p><h4 id="5-最后的最后"><a href="#5-最后的最后" class="headerlink" title="(5)最后的最后"></a>(5)最后的最后</h4><ul><li>javascript是一门单线程语言</li><li>Event Loop是javascript的执行机制</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;这一次，彻底弄懂-JavaScript-执行机制&quot;&gt;&lt;a href=&quot;#这一次，彻底弄懂-JavaScript-执行机制&quot; class=&quot;headerlink&quot; title=&quot;这一次，彻底弄懂 JavaScript 执行机制&quot;&gt;&lt;/a&gt;这一次，彻底弄懂 JavaS
      
    
    </summary>
    
      <category term="开发" scheme="https://sensitivemix.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Node.js" scheme="https://sensitivemix.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>浅析 Node.js Event Loop</title>
    <link href="https://sensitivemix.github.io/2018/12/01/%E6%B5%85%E6%9E%90-Node-js-Event-Loop/"/>
    <id>https://sensitivemix.github.io/2018/12/01/浅析-Node-js-Event-Loop/</id>
    <published>2018-12-01T06:25:29.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>要了解浏览器的事件循环，我们首先要掌握 javascript 是单线程，所有的任务都是在一条线程上面去执行，只有等上一个任务执行好了才会继续执行下一个任务。然后我们需要了解任务的概念，javaScript 可以分为两种任务，同步任务和异步任务，同步任务会在主线程上面执行，形成一条执行栈。异步任务会在主线程之外的任务队列中执行，每当异步任务支持完成之后，就会在任务队列里面插入一个事件。上面我们说到了任务栈和任务队列，我们需要掌握栈和队列的基本区别，栈是由系统分配内存，栈的特点是先进后出，而队列的特点是先进先出。了解了栈和队列之后，我们需要了解宏任务和微任务，什么是宏任务呢？比如 setTimeout, setInterval,setImmediate 这些都属于宏任务；什么是微任务呢？微任务是指进行系统 I/O 操作的一些事件，比如说 Process.nextTick, Promise.then 这些属于微任务。浏览器是如何运行的呢，首先会执行栈里面的同步代码，比如说正常的变成复制，循环，方法或者类的实例化，然后会优先执行微任务，最后才会执行宏任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">     console.log(4)</span><br><span class="line">&#125;,0);</span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">     console.log(1)</span><br><span class="line">     for( var i=0 ; i&lt;10000 ; i++ ) &#123;</span><br><span class="line">         i==9999 &amp;&amp; resolve()</span><br><span class="line">     &#125;</span><br><span class="line">      console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line">.then(function()&#123;</span><br><span class="line">     console.log(5)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(3);</span><br></pre></td></tr></table></figure><p>1,2,3,5,4</p><h3 id="Node-js-中的-Event-loop"><a href="#Node-js-中的-Event-loop" class="headerlink" title="Node.js 中的 Event loop"></a>Node.js 中的 Event loop</h3><p>我们写的 Javascript 代码首先交给 V8 引擎去处理<br>代码中调用 Node API<br>Node 会交给 Libuv 去处理，通过阻塞 I/O和多线程实现了异步 I/O<br>通过事件驱动的形式放置在事件队列中去，最终交付给我们的应用<br>执行顺序如下：首先会执行主线程中的同步任务，然后寻找是否存在微任务，如果存在则执行微任务，不存在则寻找 timers 中的宏任务放入至事件队列，如果后面存在微任务不执行，继续寻找是否存在宏任务，一次全部执行完宏任务之后，然后再执行微任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;要了解浏览器的事件循环，我们首先要掌握 javascript 是单线程，所有的任务都是在一条线程上面去执行，只有等上一个任务执行好了才会继续
      
    
    </summary>
    
      <category term="开发" scheme="https://sensitivemix.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Node.js" scheme="https://sensitivemix.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>InfluxDB 学习指南</title>
    <link href="https://sensitivemix.github.io/2018/12/01/InfluxDB-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <id>https://sensitivemix.github.io/2018/12/01/InfluxDB-学习指南/</id>
    <published>2018-12-01T06:23:15.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>influxdb是目前比较流行的时间序列数据库。</p><ul><li>何谓时间序列数据库？<br>什么是时间序列数据库，最简单的定义就是数据格式里包含Timestamp字段的数据，比如某一时间环境的温度，CPU的使用率等。但是，有什么数据不包含Timestamp呢？几乎所有的数据其实都可以打上一个Timestamp字段。时间序列数据的更重要的一个属性是如何去查询它，包括数据的过滤，计算等等。</li></ul><h4 id="Influxdb"><a href="#Influxdb" class="headerlink" title="Influxdb"></a>Influxdb</h4><p>Influxdb是一个开源的分布式时序、时间和指标数据库，使用go语言编写，无需外部依赖。<br>它有三大特性：</p><ol><li><p>时序性（Time Series）：与时间相关的函数的灵活使用（诸如最大、最小、求和等）；</p></li><li><p>度量（Metrics）：对实时大量数据进行计算；</p></li><li><p>事件（Event）：支持任意的事件数据，换句话说，任意事件的数据我们都可以做操作。</p></li></ol><p>同时，它有以下几大特点：</p><ul><li><p>schemaless(无结构)，可以是任意数量的列；</p></li><li><p>min, max, sum, count, mean, median 一系列函数，方便统计；</p></li><li><p>Native HTTP API, 内置http支持，使用http读写；</p></li><li><p>Powerful Query Language 类似sql；</p></li><li><p>Built-in Explorer 自带管理工具。</p></li></ul><h3 id="Influxdb安装"><a href="#Influxdb安装" class="headerlink" title="Influxdb安装"></a>Influxdb安装</h3><hr><blockquote><p>注：本文使用的influxdb version是1.0.2</p></blockquote><p>在讲解具体的安装步骤之前，先说说influxdb的两个http端口：8083和8086</p><ul><li><p>port 8083：管理页面端口，访问localhost:8083可以进入你本机的influxdb管理页面；</p></li><li><p>port 8086：http连接influxdb client端口，一般使用该端口往本机的influxdb读写数据。</p></li></ul><p><strong>OS X</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install influxdb</span><br></pre></td></tr></table></figure><p><strong>Docker Image</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull influxdb</span><br></pre></td></tr></table></figure><p><strong>Ubuntu &amp; Debian</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb_1.0.2_amd64.deb</span><br><span class="line">sudo dpkg -i influxdb_1.0.2_amd64.deb</span><br></pre></td></tr></table></figure><p><strong>RedHat &amp; CentOS</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb-1.0.2.x86_64.rpm</span><br><span class="line">sudo yum localinstall influxdb-1.0.2.x86_64.rpm</span><br></pre></td></tr></table></figure><p><strong>Standalone Linux Binaries (64-bit)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb-1.0.2_linux_amd64.tar.gz  </span><br><span class="line">tar xvfz influxdb-1.0.2_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p><strong>Standalone Linux Binaries (32-bit)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb-1.0.2_linux_i386.tar.gz</span><br><span class="line">tar xvfz influxdb-1.0.2_linux_i386.tar.gz</span><br></pre></td></tr></table></figure><p><strong>Standalone Linux Binaries (ARM)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb-1.0.2_linux_armhf.tar.gz</span><br><span class="line">tar xvfz influxdb-1.0.2_linux_armhf.tar.gz</span><br></pre></td></tr></table></figure><p><strong>How to start？</strong><br>安装完之后，如何启动呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service influxdb start</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services start influxdb (OSX 启动 influxdb)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services stop influxdb (OSX 关闭 influxdb)</span><br></pre></td></tr></table></figure><p>到这里influxdb安装启动完成，可以访问influxdb管理页面：<a href="http://localhost:8083" target="_blank" rel="noopener">本地管理页面</a>，该版本没有登录用户及密码，可以自行设置读写的用户名和密码。</p><p><strong>如何在命令行使用</strong><br>安装完毕之后，如何在命令行使用呢？</p><p><img src="http://upload-images.jianshu.io/upload_images/3994601-9cc22a93bb379d76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>influxdb在命令行中使用</p><h3 id="influxdb基本操作"><a href="#influxdb基本操作" class="headerlink" title="influxdb基本操作"></a>influxdb基本操作</h3><hr><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><p>在具体的讲解influxdb的相关操作之前先说说influxdb的一些专有名词，这些名词代表什么。</p><h5 id="influxdb相关名词"><a href="#influxdb相关名词" class="headerlink" title="influxdb相关名词"></a>influxdb相关名词</h5><ul><li><p>database：数据库；</p></li><li><p>measurement：数据库中的表；</p></li><li><p>points：表里面的一行数据。</p></li></ul><h5 id="influxDB中独有的一些概念"><a href="#influxDB中独有的一些概念" class="headerlink" title="influxDB中独有的一些概念"></a>influxDB中独有的一些概念</h5><p>Point由<strong>时间戳</strong>（time）、<strong>数据</strong>（field）和<strong>标签</strong>（tags）组成。</p><ul><li><p>time：每条数据记录的时间，也是数据库自动生成的主索引；</p></li><li><p>fields：各种记录的值；</p></li><li><p>tags：各种有索引的属性。</p></li></ul><p>还有一个重要的名词：<strong>series</strong><br>所有在数据库中的数据，都需要通过图表来表示，series表示这个表里面的所有的数据可以在图标上画成几条线（注：线条的个数由tags排列组合计算出来）<br>举个简单的小栗子：<br>有如下数据：  </p><p><img src="http://upload-images.jianshu.io/upload_images/3994601-f528ff65d64cf860.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>error_time</p><p>它的series为：</p><p><img src="http://upload-images.jianshu.io/upload_images/3994601-cb52cbd8bf20d41b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>error_time_series</p><h4 id="influxdb基本操作-1"><a href="#influxdb基本操作-1" class="headerlink" title="influxdb基本操作"></a>influxdb基本操作</h4><ul><li><p><strong>数据库与表的操作</strong><br>可以直接在web管理页面做操作，当然也可以命令行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#创建数据库</span><br><span class="line">create database &quot;db_name&quot;</span><br><span class="line">#显示所有的数据库</span><br><span class="line">show databases</span><br><span class="line">#删除数据库</span><br><span class="line">drop database &quot;db_name&quot;</span><br><span class="line">#使用数据库</span><br><span class="line">use db_name</span><br><span class="line">#显示该数据库中所有的表</span><br><span class="line">show measurements</span><br><span class="line">#创建表，直接在插入数据的时候指定表名</span><br><span class="line">insert test,host=127.0.0.1,monitor_name=test count=1</span><br><span class="line">#删除表</span><br><span class="line">drop measurement &quot;measurement_name&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>增</strong><br>向数据库中插入数据。</p><ul><li><p>通过命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use testDb</span><br><span class="line">insert test,host=127.0.0.1,monitor_name=test count=1</span><br></pre></td></tr></table></figure></li><li><p>通过http接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XPOST &apos;http://127.0.0.1:8086/write?db=testDb&apos; --data-binary &apos;test,host=127.0.0.1,monitor_name=test count=1&apos;</span><br></pre></td></tr></table></figure></li></ul><p>读者看到这里可能会观察到插入的数据的格式貌似比较奇怪，这是因为influxDB存储数据采用的是Line Protocol格式。那么何谓Line Protoco格式？</p><p><strong>Line Protocol格式：</strong>写入数据库的Point的固定格式。<br>在上面的两种插入数据的方法中都有这样的一部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test,host=127.0.0.1,monitor_name=test count=1</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li><p>test：表名；</p></li><li><p>host=127.0.0.1,monitor_name=test：tag；</p></li><li><p>count=1：field</p></li></ol><p>想对此格式有详细的了解参见<a href="https://docs.influxdata.com/influxdb/v0.10/write_protocols/line/" target="_blank" rel="noopener">官方文档</a></p></li><li><p><strong>查</strong><br>查询数据库中的数据。</p><ul><li><p>通过命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test order by time desc</span><br></pre></td></tr></table></figure></li><li><p>通过http接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G &apos;http://localhost:8086/query?pretty=true&apos; --data-urlencode &quot;db=testDb&quot; --data-urlencode &quot;q=select * from test order by time desc&quot;</span><br></pre></td></tr></table></figure></li></ul><p>influxDB是支持类sql语句的，具体的查询语法都差不多，这里就不再做详细的赘述了。</p></li><li><p><strong>数据保存策略（Retention Policies）</strong><br>influxDB是没有提供直接删除数据记录的方法，但是提供数据保存策略，主要用于指定数据保留时间，超过指定时间，就删除这部分数据。</p><ul><li><p>查看当前数据库Retention Policies</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show retention policies on &quot;db_name&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>![](http://upload-images.jianshu.io/upload_images/3994601-4dbf9942cc0f671a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</code></pre><p>retention_policies</p><pre><code>*   创建新的Retention Policies    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create retention policy &quot;rp_name&quot; on &quot;db_name&quot; duration 3w replication 1 default</span><br></pre></td></tr></table></figure>    *   rp_name：策略名；    *   db_name：具体的数据库名；    *   3w：保存3周，3周之前的数据将被删除，influxdb具有各种事件参数，比如：h（小时），d（天），w（星期）；    *   replication 1：副本个数，一般为1就可以了；    *   default：设置为默认策略*   修改Retention Policies    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter retention policy &quot;rp_name&quot; on &quot;db_name&quot; duration 30d default</span><br></pre></td></tr></table></figure>*   删除Retention Policies    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop retention policy &quot;rp_name&quot;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p><strong>连续查询（Continous Queries）</strong><br>当数据超过保存策略里指定的时间之后就会被删除，但是这时候可能并不想数据被完全删掉，怎么办？<br>influxdb提供了联系查询，可以做数据统计采样。</p><ul><li><p>查看数据库的Continous Queries</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show continuous queries</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>![](http://upload-images.jianshu.io/upload_images/3994601-d0d2b55ee261869d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</code></pre><p>continuous_queries.</p><pre><code>*   创建新的Continous Queries    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create continous query cq_name on db_name begin select sum(count) into new_table_name from table_name group by time(30m) end</span><br></pre></td></tr></table></figure>    *   cq_name：连续查询名字；    *   db_name：数据库名字；    *   sum(count)：计算总和；    *   table_name：当前表名；    *   new_table_name：存新的数据的表名；    *   30m：时间间隔为30分钟*   删除Continous Queries    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop continous query cp_name on db_name</span><br></pre></td></tr></table></figure></code></pre><ul><li><p><strong>用户管理</strong><br>可以直接在web管理页面做操作，也可以命令行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#显示用户  </span><br><span class="line">show users</span><br><span class="line">#创建用户</span><br><span class="line">create user &quot;username&quot; with password &apos;password&apos;</span><br><span class="line">#创建管理员权限用户create user &quot;username&quot; with password &apos;password&apos; with all privileges</span><br><span class="line">#删除用户</span><br><span class="line">drop user &quot;username&quot;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;influxdb是目前比较流行的时间序列数据库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;何谓时间序列数据库？&lt;br&gt;什么是时间序列数据库，最简
      
    
    </summary>
    
      <category term="开发" scheme="https://sensitivemix.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="InfluxDB" scheme="https://sensitivemix.github.io/tags/InfluxDB/"/>
    
      <category term="Database" scheme="https://sensitivemix.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>mongoDB 执行计划分析</title>
    <link href="https://sensitivemix.github.io/2018/11/27/mongoDB-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90/"/>
    <id>https://sensitivemix.github.io/2018/11/27/mongoDB-执行计划分析/</id>
    <published>2018-11-27T15:31:32.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>客户端如何快捷过滤 API 响应</title>
    <link href="https://sensitivemix.github.io/2018/11/09/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E5%BF%AB%E6%8D%B7%E8%BF%87%E6%BB%A4-API-%E5%93%8D%E5%BA%94/"/>
    <id>https://sensitivemix.github.io/2018/11/09/客户端如何快捷过滤-API-响应/</id>
    <published>2018-11-09T07:10:57.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要过滤"><a href="#为什么要过滤" class="headerlink" title="为什么要过滤"></a>为什么要过滤</h2><ul><li>需求变更频繁，API 无法每次都根据需求更新</li><li>适应多端，各端需要的响应返回都不一样，不可能为每个端定制 API 返回</li><li>优化 API 响应时间，避免不必要的 Format 查询操作 </li><li>复杂冗余的 API 响应</li></ul><p>获取客户列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;extra&quot;:&#123;</span><br><span class="line">      &quot;orgCounts&quot;:1,</span><br><span class="line">      &quot;showHidden&quot;:true</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;organizations&quot;:[</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_id&quot;:&quot;5be51350f93a32ade0e2e257&quot;,</span><br><span class="line">         &quot;updateTime&quot;:&quot;2018-11-09T04:55:45.203Z&quot;,</span><br><span class="line">         &quot;name&quot;:&quot;蜀国&quot;,</span><br><span class="line">         &quot;_workspaceId&quot;:&quot;5bd87ecba00f2b0001921b27&quot;,</span><br><span class="line">         &quot;fields&quot;:[</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         ],</span><br><span class="line">         &quot;undoneActivities&quot;:0,</span><br><span class="line">         &quot;doneActivities&quot;:0,</span><br><span class="line">         &quot;totalActivities&quot;:0,</span><br><span class="line">         &quot;nextActivityDate&quot;:null,</span><br><span class="line">         &quot;lastActivityDate&quot;:null,</span><br><span class="line">         &quot;isPublic&quot;:false,</span><br><span class="line">         &quot;isArchive&quot;:false,</span><br><span class="line">         &quot;lostDeals&quot;:0,</span><br><span class="line">         &quot;wonDeals&quot;:0,</span><br><span class="line">         &quot;closedDeals&quot;:0,</span><br><span class="line">         &quot;openDeals&quot;:0,</span><br><span class="line">         &quot;numberOfEmployees&quot;:&quot;&quot;,</span><br><span class="line">         &quot;quality&quot;:null,</span><br><span class="line">         &quot;status&quot;:&#123;</span><br><span class="line">            &quot;_fixedFieldId&quot;:&quot;5bd87ed761c2bf77fde85a2c&quot;,</span><br><span class="line">            &quot;value&quot;:&quot;5bd87ed7d2e7854a5278b24a&quot;,</span><br><span class="line">            &quot;choices&quot;:[</span><br><span class="line">               &#123;</span><br><span class="line">                  &quot;pos&quot;:65536,</span><br><span class="line">                  &quot;value&quot;:&quot;试用&quot;,</span><br><span class="line">                  &quot;_id&quot;:&quot;5bd87ed7d2e7854a5278b24a&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               &#123;</span><br><span class="line">                  &quot;pos&quot;:131072,</span><br><span class="line">                  &quot;value&quot;:&quot;Onboarding&quot;,</span><br><span class="line">                  &quot;_id&quot;:&quot;5bd87ed7d2e7854a5278b249&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               &#123;</span><br><span class="line">                  &quot;pos&quot;:196608,</span><br><span class="line">                  &quot;value&quot;:&quot;Retention&quot;,</span><br><span class="line">                  &quot;_id&quot;:&quot;5bd87ed7d2e7854a5278b248&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               &#123;</span><br><span class="line">                  &quot;pos&quot;:262144,</span><br><span class="line">                  &quot;value&quot;:&quot;Renew&quot;,</span><br><span class="line">                  &quot;_id&quot;:&quot;5bd87ed7d2e7854a5278b247&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               &#123;</span><br><span class="line">                  &quot;pos&quot;:327680,</span><br><span class="line">                  &quot;value&quot;:&quot;流失&quot;,</span><br><span class="line">                  &quot;_id&quot;:&quot;5bd87ed7d2e7854a5278b246&quot;</span><br><span class="line">               &#125;</span><br><span class="line">            ]</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;area&quot;:&quot;&quot;,</span><br><span class="line">         &quot;city&quot;:&quot;&quot;,</span><br><span class="line">         &quot;avatarUrl&quot;:&quot;http://tcs.project.ci/thumbnail/010x5741bc1bce56f84c34f4b9855ce079b3/w/200/h/200&quot;,</span><br><span class="line">         &quot;province&quot;:&quot;&quot;,</span><br><span class="line">         &quot;industry&quot;:&quot;&quot;,</span><br><span class="line">         &quot;country&quot;:&quot;&quot;,</span><br><span class="line">         &quot;address&quot;:&quot;&quot;,</span><br><span class="line">         &quot;allocateTime&quot;:&quot;2018-11-09T04:55:44.674Z&quot;,</span><br><span class="line">         &quot;updateNoteTime&quot;:null,</span><br><span class="line">         &quot;createdTime&quot;:&quot;2018-11-09T04:55:44.674Z&quot;,</span><br><span class="line">         &quot;people&quot;:0,</span><br><span class="line">         &quot;note&quot;:&quot;&quot;,</span><br><span class="line">         &quot;products&quot;:[</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         ],</span><br><span class="line">         &quot;creator&quot;:&#123;</span><br><span class="line">            &quot;_id&quot;:&quot;599e33ce7c814524278308c2&quot;,</span><br><span class="line">            &quot;name&quot;:&quot;jack&quot;</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;owner&quot;:&#123;</span><br><span class="line">            &quot;_id&quot;:&quot;599e33ce7c814524278308c2&quot;,</span><br><span class="line">            &quot;name&quot;:&quot;jack&quot;</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;__v&quot;:0</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="如何自定义-API-响应"><a href="#如何自定义-API-响应" class="headerlink" title="如何自定义 API 响应"></a>如何自定义 API 响应</h2><p><a href="https://developers.google.com/slides/how-tos/field-masks" target="_blank" rel="noopener">Field-Masks (字段掩码)</a></p><ul><li>使用字段掩码进行读取<br>| 例子   | 影响   |<br>|:—-|<br>| items   | 返回items数组中的所有元素，包括每个元素中的所有字段，但不包含其他字段。 |<br>| etag,items   | 返回etagitems数组中的字段和所有元素。   |<br>| items/title   | 仅返回titleitems数组中所有元素的字段。每当返回嵌套字段时，响应都包含封闭的父对象。除非明确选择父字段，否则父字段不包括任何其他子字段。 |<br>| context/facets/label   | 仅返回数组的label所有成员的字段，该facets数组本身嵌套在context对象下。   |<br>| items/pagemap/*/title   | 对于items数组中的每个元素，仅返回作为子项title的所有对象的字段（如果存在）pagemap。   | </li></ul><ul><li>使用字段掩码进行更新<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST https://slides.googleapis.com/v1/presentations/presentationId:batchUpdate</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;requests&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;updateShapeProperties&quot;: &#123;</span><br><span class="line">        &quot;objectId&quot;: elementId,</span><br><span class="line">        &quot;shapeProperties&quot;: &#123;</span><br><span class="line">          &quot;shapeBackgroundFill&quot;: &#123;</span><br><span class="line">            &quot;solidFill&quot;: &#123;</span><br><span class="line">              &quot;color&quot;: &#123;</span><br><span class="line">                &quot;themeColor&quot;: &quot;DARK1&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;fields&quot;: &quot;shapeBackgroundFill.solidFill.color,outline&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何应用中至项目"><a href="#如何应用中至项目" class="headerlink" title="如何应用中至项目"></a>如何应用中至项目</h2><ul><li>基础轮子：<a href="https://github.com/nemtsov/json-mask" target="_blank" rel="noopener">JSON-MASK</a></li><li>KOA2.X:  <a href="https://github.com/nemtsov/koa-json-mask" target="_blank" rel="noopener">koa-json-mask</a></li><li>KOA1.X:  <a href="https://github.com/sensitivemix/koa1-json-mask" target="_blank" rel="noopener">koa1-json-mask</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要过滤&quot;&gt;&lt;a href=&quot;#为什么要过滤&quot; class=&quot;headerlink&quot; title=&quot;为什么要过滤&quot;&gt;&lt;/a&gt;为什么要过滤&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;需求变更频繁，API 无法每次都根据需求更新&lt;/li&gt;
&lt;li&gt;适应多端，各端需要的响应返回都不
      
    
    </summary>
    
      <category term="开发" scheme="https://sensitivemix.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Frontend" scheme="https://sensitivemix.github.io/tags/Frontend/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 应用最佳实践</title>
    <link href="https://sensitivemix.github.io/2018/09/03/Node-js-%E5%BA%94%E7%94%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://sensitivemix.github.io/2018/09/03/Node-js-应用最佳实践/</id>
    <published>2018-09-03T07:01:29.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于 <a href="https://github.com/expressjs/express" target="_blank" rel="noopener">Express</a> 实践，Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。</p></blockquote><ol><li>项目结构实践<h2 id="1-1-组件式构建你的解决方案-The-Future"><a href="#1-1-组件式构建你的解决方案-The-Future" class="headerlink" title="1.1 组件式构建你的解决方案 (The Future)"></a>1.1 组件式构建你的解决方案 (The Future)</h2>定义：大型项目的最坏的隐患就是维护一个庞大的，含有几百个依赖的代码库 - 当开发人员准备整合新的需求的时候，这样一个庞然大物势必减缓了开发效率。反之，把您的代码拆分成组件，每一个组件有它自己的文件夹和代码库，并且确保每一个组件小而简单。</li></ol><p>否则: 当编写新需求的开发人员逐步意识到他所做改变的影响，并担心会破坏其他的依赖模块 - 部署会变得更慢，风险更大。当所有业务逻辑没有被分开，这也会被认为很难扩展</p><h3 id="1-1-1-Bad-Group-your-files-by-technical-role"><a href="#1-1-1-Bad-Group-your-files-by-technical-role" class="headerlink" title="1.1.1 Bad: Group your files by technical role"></a>1.1.1 Bad: Group your files by technical role</h3><p><img src="https://github.com/i0natan/nodebestpractices/raw/master/assets/images/structurebyroles.PNG" alt="图片"></p><h3 id="1-1-2-Good-Structure-your-solution-by-self-contained-components"><a href="#1-1-2-Good-Structure-your-solution-by-self-contained-components" class="headerlink" title="1.1.2 Good: Structure your solution by self-contained components"></a>1.1.2 Good: Structure your solution by self-contained components</h3><p><img src="https://github.com/i0natan/nodebestpractices/raw/master/assets/images/structurebycomponents.PNG" alt="图片"></p><h2 id="1-2-分层设计组件，保持项目结构在特定的区域"><a href="#1-2-分层设计组件，保持项目结构在特定的区域" class="headerlink" title="1.2 分层设计组件，保持项目结构在特定的区域"></a>1.2 分层设计组件，保持项目结构在特定的区域</h2><p>定义: 每一个组件都应该包含「层级」 - 一个专注的用于接入网络，逻辑，数据的概念。这样不仅获得一个清晰的分离考量，而且使仿真（mock-server）和测试系统变得异常容易。尽管这是一个普通的模式，但接口开发者易于混淆层级关系，比如把网络层的对象（req, res）传给业务逻辑和数据层 - 这会令您的应用彼此依赖，并且只能通过Express使用。</p><p>否则: 对于混淆了网络层和其它层的应用，将不易于测试，执行 CRON 的任务，其它非-Express 的调用者无法使用</p><p><img src="https://github.com/i0natan/nodebestpractices/raw/master/assets/images/structurebycomponents.PNG" alt="图片"></p><blockquote><p>对比逻辑分层重要性</p></blockquote><p><img src="https://github.com/i0natan/nodebestpractices/blob/master/assets/images/keepexpressinweb.gif?raw=true" alt="图片"></p><h2 id="1-3-封装公共模块成为NPM的包"><a href="#1-3-封装公共模块成为NPM的包" class="headerlink" title="1.3 封装公共模块成为NPM的包"></a>1.3 封装公共模块成为NPM的包</h2><p>定义: 由大量代码构成的一个大型应用中，贯彻全局的，比如日志，加密和其它类似的公共组件，应该进行封装，并暴露成一个私有的NPM包。这将使其在更多的代码库和项目中被使用变成了可能。</p><p>否则: 您将不得不重造部署和依赖的轮子</p><h3 id="在环境和组件中共享你自己的公用实用工具"><a href="#在环境和组件中共享你自己的公用实用工具" class="headerlink" title="在环境和组件中共享你自己的公用实用工具"></a>在环境和组件中共享你自己的公用实用工具</h3><p><img src="https://github.com/i0natan/nodebestpractices/raw/master/assets/images/Privatenpm.png" alt="图片"></p><h2 id="1-4-分离-Express-‘app’-and-‘server’"><a href="#1-4-分离-Express-‘app’-and-‘server’" class="headerlink" title="1.4 分离 Express ‘app’ and ‘server’"></a>1.4 分离 Express ‘app’ and ‘server’</h2><p>定义: 避免定义整个 <a href="https://expressjs.com/" target="_blank" rel="noopener">Express</a> 应用在一个单独的大文件里， 这是一个不好的习惯 - 分离您的 「Express」 定义至少在两个文件中： API声明(app.js) 和 网络相关(WWW)。对于更好的结构，是把你的API声明放在组件中。</p><p>否则: 您的 API 将只能通过 HTTP 的调用进行测试（慢，并且很难产生测试覆盖报告）。维护一个有着上百行代码的文件也不是一个令人开心的事情。</p><h3 id="一段解释"><a href="#一段解释" class="headerlink" title="一段解释"></a>一段解释</h3><p>最新的 Express 生成器有一个值得保留的伟大实践–API声明与网络相关配置（端口、协议等）是分开的。这样就可以在不执行网络调用的情况下对API进行在线测试，它所带来的好处是：快速执行测试操作和获取代码覆盖率。它还允许在灵活多样的网络条件下部署相同的API。额外好处：更好的关注点分离和更清晰的代码结构。</p><h3 id="代码示例：API声明应该在-app-js-文件里面"><a href="#代码示例：API声明应该在-app-js-文件里面" class="headerlink" title="代码示例：API声明应该在 app.js 文件里面"></a>代码示例：API声明应该在 app.js 文件里面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var app = express();</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(&quot;/api/events&quot;, events.API);</span><br><span class="line">app.use(&quot;/api/forms&quot;, forms);</span><br></pre></td></tr></table></figure><p>### </p><h3 id="代码示例-服务器网络声明，应该在-bin-www-文件里面"><a href="#代码示例-服务器网络声明，应该在-bin-www-文件里面" class="headerlink" title="代码示例: 服务器网络声明，应该在 /bin/www 文件里面"></a>代码示例: 服务器网络声明，应该在 /bin/www 文件里面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var app = require(&apos;../app&apos;);</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Get port from environment and store in Express.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">var port = normalizePort(process.env.PORT || &apos;3000&apos;);</span><br><span class="line">app.set(&apos;port&apos;, port);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Create HTTP server.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">var server = http.createServer(app);</span><br></pre></td></tr></table></figure><p>### </p><h3 id="示例代码-使用超快的流行的测试包在线测试你的代码"><a href="#示例代码-使用超快的流行的测试包在线测试你的代码" class="headerlink" title="示例代码: 使用超快的流行的测试包在线测试你的代码"></a>示例代码: 使用超快的流行的测试包在线测试你的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.get(&apos;/user&apos;, function(req, res) &#123;</span><br><span class="line">  res.status(200).json(&#123; name: &apos;tobi&apos; &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">request(app)</span><br><span class="line">  .get(&apos;/user&apos;)</span><br><span class="line">  .expect(&apos;Content-Type&apos;, /json/)</span><br><span class="line">  .expect(&apos;Content-Length&apos;, &apos;15&apos;)</span><br><span class="line">  .expect(200)</span><br><span class="line">  .end(function(err, res) &#123;</span><br><span class="line">    if (err) throw err;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="1-5-使用易于设置环境变量，安全和分级的配置"><a href="#1-5-使用易于设置环境变量，安全和分级的配置" class="headerlink" title="1.5 使用易于设置环境变量，安全和分级的配置"></a>1.5 使用易于设置环境变量，安全和分级的配置</h2><p>定义: 一个完美无瑕的配置安装应该确保 (a) 元素可以从文件中，也可以从环境变量中读取 (b) 密码排除在提交的代码之外 (c) 为了易于检索，配置是分级的。仅有几个包可以满足这样的条件，比如<a href="https://www.npmjs.com/package/rc" target="_blank" rel="noopener">rc</a>, <a href="https://www.npmjs.com/package/nconf" target="_blank" rel="noopener">nconf</a> 和 <a href="https://www.npmjs.com/package/config" target="_blank" rel="noopener">config</a>。</p><p>否则: 不能满足任意的配置要求将会使开发，运维团队，或者两者，易于陷入泥潭。</p><h3 id="一段解释-1"><a href="#一段解释-1" class="headerlink" title="一段解释"></a>一段解释</h3><p>当我们处理配置参数时，常常会很慢并且很烦躁：<br>（1）当需要注入100个keys(而不是只在配置文件中提交它们)时，使用进程环境变量设置所有的keys变得非常繁琐，但是当处理只有devops管理权限的文件时，不改变代码行为就不不会变。一个可靠的配置解决方案必须结合配置文件和进程变量覆盖。</p><p>（2）枚举一个普通JSON的所有keys时，当目录变得非常庞杂的时候，查找修改条目困难。几乎没有配置库允许将配置存储在多个文件中，运行时将所有文件联合起来。分成几个部分的分层JSON文件能够克服这个问题。请参照下面示例。</p><p>（3）不推荐存储像密码数据这样的敏感信息，但是又没有快速便捷的方法解决这个难题。一些配置库允许文件加密，其他库在Git提交时加密目录，或者不存储这些目录的真实值，在通过环境变量部署期间枚举真实值。</p><p>（4）一些高级配置场景需要通过命令行（vargs）注入配置值，或者像Redis一样通过集中缓存同步配置信息，所以不同的服务器不会保存不同的数据。<br>一些配置库可以免费提供这些功能的大部分功能，请查看NPM库（<a href="https://www.npmjs.com/package/nconf" target="_blank" rel="noopener">nconf</a> 和 <a href="https://www.npmjs.com/package/config" target="_blank" rel="noopener">config</a>）这些库可以满足这些要求中的许多要求。</p><h3 id="代码示例-–-分层配置有助于查找条目和维护庞大的配置文件"><a href="#代码示例-–-分层配置有助于查找条目和维护庞大的配置文件" class="headerlink" title="代码示例 – 分层配置有助于查找条目和维护庞大的配置文件"></a>代码示例 – 分层配置有助于查找条目和维护庞大的配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Customer module configs </span><br><span class="line">  &quot;Customer&quot;: &#123;</span><br><span class="line">    &quot;dbConfig&quot;: &#123;</span><br><span class="line">      &quot;host&quot;: &quot;localhost&quot;,</span><br><span class="line">      &quot;port&quot;: 5984,</span><br><span class="line">      &quot;dbName&quot;: &quot;customers&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;credit&quot;: &#123;</span><br><span class="line">      &quot;initialLimit&quot;: 100,</span><br><span class="line">      // Set low for development </span><br><span class="line">      &quot;initialDays&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>异常处理实践<h2 id="2-1-使用-Async-Await-和-promises-用于异步错误处理"><a href="#2-1-使用-Async-Await-和-promises-用于异步错误处理" class="headerlink" title="2.1 使用 Async-Await 和 promises 用于异步错误处理"></a>2.1 使用 Async-Await 和 promises 用于异步错误处理</h2>定义: 使用回调的方式处理异步错误可能是导致灾难的最快的方式(a.k.a the pyramid of doom)。对您的代码来说，最好的礼物就是使用规范的 promise 库、 async-await 来替代，这会使其像 try-catch 一样更加简洁，具有熟悉的代码结构。</li></ol><p>否则: Node.js回调特性, function(err, response), 是导致不可维护代码的一个必然的方式。究其原因，是由于混合了随意的错误处理代码，臃肿的内嵌，蹩脚的代码模式。</p><h3 id="代码示例-–-使用promise捕获错误"><a href="#代码示例-–-使用promise捕获错误" class="headerlink" title="代码示例 – 使用promise捕获错误"></a>代码示例 – 使用promise捕获错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doWork()</span><br><span class="line"> .then(doWork)</span><br><span class="line"> .then(doOtherWork)</span><br><span class="line"> .then((result) =&gt; doWork)</span><br><span class="line"> .catch((error) =&gt; &#123;throw error;&#125;)</span><br><span class="line"> .then(verify);</span><br></pre></td></tr></table></figure><p>### </p><h3 id="代码示例-反模式-–-回调方式的错误处理"><a href="#代码示例-反模式-–-回调方式的错误处理" class="headerlink" title="代码示例 反模式 – 回调方式的错误处理"></a>代码示例 反模式 – 回调方式的错误处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getData(someParameter, function(err, result)&#123;</span><br><span class="line">    if(err != null)</span><br><span class="line">      //做一些事情类似于调用给定的回调函数并传递错误</span><br><span class="line">      getMoreData(a, function(err, result)&#123;</span><br><span class="line">        if(err != null)</span><br><span class="line">          //做一些事情类似于调用给定的回调函数并传递错误</span><br><span class="line">          getMoreData(b, function(c)&#123; </span><br><span class="line">            getMoreData(d, function(e)&#123; </span><br><span class="line">              if(err != null)</span><br><span class="line">                //你有什么想法? </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-2-仅使用内建的错误对象"><a href="#2-2-仅使用内建的错误对象" class="headerlink" title="2.2 仅使用内建的错误对象"></a>2.2 仅使用内建的错误对象</h2><p>定义: 很多人抛出异常使用字符串类型或一些自定义类型 - 这会导致错误处理逻辑和模块间的调用复杂化。是否您reject一个promise，抛出异常或发出(emit)错误 - 使用内建的错误对象将会增加设计一致性，并防止信息的丢失。</p><p>否则: 调用某些模块，将不确定哪种错误类型会返回 - 这将会使恰当的错误处理更加困难。更坏的情况是，使用特定的类型描述错误，会导致重要的错误信息缺失，比如 stack trace！</p><h3 id="代码示例-–-正确处理它"><a href="#代码示例-–-正确处理它" class="headerlink" title="代码示例 – 正确处理它"></a>代码示例 – 正确处理它</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//从典型函数抛出错误, 无论是同步还是异步</span><br><span class="line"> if(!productToAdd)</span><br><span class="line"> throw new Error(&quot;How can I add new product when no value provided?&quot;);</span><br><span class="line"> </span><br><span class="line">//从EventEmitter抛出错误</span><br><span class="line">const myEmitter = new MyEmitter();</span><br><span class="line">myEmitter.emit(&apos;error&apos;, new Error(&apos;whoops!&apos;));</span><br><span class="line"> </span><br><span class="line">//从promise抛出错误</span><br><span class="line"> return new promise(function (resolve, reject) &#123;</span><br><span class="line">Return DAL.getProduct(productToAdd.id).then((existingProduct) =&gt; &#123;</span><br><span class="line"> if(existingProduct != null)</span><br><span class="line"> reject(new Error(&quot;Why fooling us and trying to add an existing product?&quot;));</span><br></pre></td></tr></table></figure><p>### </p><h3 id="代码示例-–-反模式"><a href="#代码示例-–-反模式" class="headerlink" title="代码示例 – 反模式"></a>代码示例 – 反模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//抛出字符串错误缺少任何stack trace信息和其他重要属性</span><br><span class="line">if(!productToAdd)</span><br><span class="line">    throw (&quot;How can I add new product when no value provided?&quot;);</span><br></pre></td></tr></table></figure><p>### </p><h3 id="代码示例-–-更好处理它"><a href="#代码示例-–-更好处理它" class="headerlink" title="代码示例 – 更好处理它"></a>代码示例 – 更好处理它</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//从node错误派生的集中错误对象</span><br><span class="line">function appError(name, httpCode, description, isOperational) &#123;</span><br><span class="line">    Error.call(this);</span><br><span class="line">    Error.captureStackTrace(this);</span><br><span class="line">    this.name = name;</span><br><span class="line">    //...在这赋值其它属性</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">appError.prototype.__proto__ = Error.prototype;</span><br><span class="line"></span><br><span class="line">module.exports.appError = appError;</span><br><span class="line"> </span><br><span class="line">//客户端抛出一个错误</span><br><span class="line">if(user == null)</span><br><span class="line">  throw new appError(commonErrors.resourceNotFound, commonHTTPErrors.notFound, &quot;further explanation&quot;, true)</span><br></pre></td></tr></table></figure><h2 id="2-3-区分运行错误和程序设计错误"><a href="#2-3-区分运行错误和程序设计错误" class="headerlink" title="2.3 区分运行错误和程序设计错误"></a>2.3 区分运行错误和程序设计错误</h2><p>定义: 运行错误（例如, API接受到一个无效的输入）指的是一些已知场景下的错误，这类错误的影响已经完全被理解，并能被考虑周全的处理掉。同时，程序设计错误（例如，尝试读取未定义的变量）指的是未知的编码问题，影响到应用得当的重启。</p><p>否则: 当一个错误产生的时候，您总是得重启应用，但为什么要让 ~5000 个在线用户不能访问，仅仅是因为一个细微的，可以预测的，运行时错误？相反的方案，也不完美 – 当未知的问题（程序问题）产生的时候，使应用依旧可以访问，可能导致不可预测行为。区分两者会使处理更有技巧，并在给定的上下文下给出一个平衡的对策。</p><h3 id="一段解释-2"><a href="#一段解释-2" class="headerlink" title="一段解释"></a>一段解释</h3><p>区分以下两种错误类型将最大限度地减少应用程序停机时间并帮助避免出现荒唐的错误: 操作型错误指的是您了解发生了什么情况及其影响的情形 – 例如, 由于连接问题而导致对某些 HTTP 服务的查询失败问题。另一方面, 程序型错误指的是您不知道原因, 有时是错误不知道来自何处的情况 – 可能是一些代码试图读取未定义的值或 DB 连接池内存泄漏。操作型错误相对容易处理 – 通常记录错误就足够了。当程序型错误出现，事情变得难以应付, 应用程序可能处于不一致状态, 你可以做的，没有什么比优雅的重新启动更好了。</p><h3 id="代码示例-–-将错误标记为可操作-受信任"><a href="#代码示例-–-将错误标记为可操作-受信任" class="headerlink" title="代码示例 – 将错误标记为可操作 (受信任)"></a>代码示例 – 将错误标记为可操作 (受信任)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//将错误标记为可操作 </span><br><span class="line">var myError = new Error(&quot;How can I add new product when no value provided?&quot;);</span><br><span class="line">myError.isOperational = true;</span><br><span class="line"> </span><br><span class="line">//或者, 如果您使用的是一些集中式错误工厂 (请参见项目符号中的示例&quot;仅使用内置错误对象&quot;)</span><br><span class="line">function appError(commonType, description, isOperational) &#123;</span><br><span class="line">    Error.call(this);</span><br><span class="line">    Error.captureStackTrace(this);</span><br><span class="line">    this.commonType = commonType;</span><br><span class="line">    this.description = description;</span><br><span class="line">    this.isOperational = isOperational;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">throw new appError(errorManagement.commonErrors.InvalidInput, &quot;Describe here what happened&quot;, true);</span><br></pre></td></tr></table></figure><p>## </p><h2 id="2-4-集中处理错误，不要在-Express-中间件中处理错误"><a href="#2-4-集中处理错误，不要在-Express-中间件中处理错误" class="headerlink" title="2.4 集中处理错误，不要在 Express 中间件中处理错误"></a>2.4 集中处理错误，不要在 Express 中间件中处理错误</h2><p>定义: 错误处理逻辑，比如给管理员发送邮件，日志应该封装在一个特定的，集中的对象当中，这样当错误产生的时候，所有的终端（例如 Express中间件，cron 任务，单元测试）都可以调用。</p><p>否则: 错误处理的逻辑不放在一起将会导致代码重复和非常可能不恰当的错误处理。</p><h3 id="一段解释-3"><a href="#一段解释-3" class="headerlink" title="一段解释"></a>一段解释</h3><p>如果没有一个专用的错误处理对象，那么由于操作不当，在雷达下重要错误被隐藏的可能性就会更大。错误处理对象负责使错误可见，例如通过写入一个格式化良好的logger，通过电子邮件将事件发送到某个监控产品或管理员。一个典型的错误处理流程可能是：一些模块抛出一个错误 -&gt; API路由器捕获错误 -&gt; 它传播错误给负责捕获错误的中间件（如Express，KOA）-&gt; 集中式错误处理程序被调用 -&gt; 中间件正在被告之这个错误是否是一个不可信的错误（不是操作型错误），这样可以优雅的重新启动应用程序。注意，在Express中间件中处理错误是一种常见但又错误的做法，这样做不会覆盖在非Web接口中抛出的错误。</p><h3 id="代码示例-–-一个典型错误流"><a href="#代码示例-–-一个典型错误流" class="headerlink" title="代码示例 – 一个典型错误流"></a>代码示例 – 一个典型错误流</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//DAL层, 在这里我们不处理错误</span><br><span class="line">DB.addDocument(newCustomer, (error, result) =&gt; &#123;</span><br><span class="line">    if (error)</span><br><span class="line">        throw new Error(&quot;Great error explanation comes here&quot;, other useful parameters)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">//API路由代码, 我们同时捕获异步和同步错误，并转到中间件</span><br><span class="line">try &#123;</span><br><span class="line">    customerService.addNew(req.body).then(function (result) &#123;</span><br><span class="line">        res.status(200).json(result);</span><br><span class="line">    &#125;).catch((error) =&gt; &#123;</span><br><span class="line">        next(error)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">catch (error) &#123;</span><br><span class="line">    next(error);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//错误处理中间件，我们委托集中式错误处理程序处理错误</span><br><span class="line">app.use(function (err, req, res, next) &#123;</span><br><span class="line">    errorHandler.handleError(err).then((isOperationalError) =&gt; &#123;</span><br><span class="line">        if (!isOperationalError)</span><br><span class="line">            next(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>### </p><h3 id="代码示例-–-在一个专门的对象里面处理错误"><a href="#代码示例-–-在一个专门的对象里面处理错误" class="headerlink" title="代码示例 – 在一个专门的对象里面处理错误"></a>代码示例 – 在一个专门的对象里面处理错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports.handler = new errorHandler();</span><br><span class="line"> </span><br><span class="line">function errorHandler()&#123;</span><br><span class="line">    this.handleError = function (error) &#123;</span><br><span class="line">        return logger.logError(err).then(sendMailToAdminIfCritical).then(saveInOpsQueueIfCritical).then(determineIfOperationalError);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-对API错误使用Swagger文档化"><a href="#2-5-对API错误使用Swagger文档化" class="headerlink" title="2.5 对API错误使用Swagger文档化"></a>2.5 对API错误使用Swagger文档化</h2><p>定义: 让你的API调用者知道哪种错误会返回，这样他们就能完全的处理这些错误，而不至于系统崩溃。Swagger，REST API的文档框架，通常处理这类问题。</p><p>否则: 任何API的客户端可能决定崩溃并重启，仅仅因为它收到一个不能处理的错误。注意：API的调用者可能是你（在微服务环境中非常典型）。</p><h2 id="2-6-当一个特殊的情况产生，停掉服务是得体的"><a href="#2-6-当一个特殊的情况产生，停掉服务是得体的" class="headerlink" title="2.6 当一个特殊的情况产生，停掉服务是得体的"></a>2.6 当一个特殊的情况产生，停掉服务是得体的</h2><p>定义: 当一个不确定错误产生（一个开发错误，最佳实践条款#3) - 这就意味着对应用运转健全的不确定。一个普通的实践将是建议仔细地重启进程，并使用一些‘启动器’工具，比如Forever和PM2。</p><p>否则: 当一个未知的异常被抛出，意味着某些对象包含错误的状态（例如某个全局事件发生器由于某些内在的错误，不在产生事件），未来的请求可能失败或者行为异常。</p><h3 id="代码实例-决定是否退出"><a href="#代码实例-决定是否退出" class="headerlink" title="代码实例: 决定是否退出"></a>代码实例: 决定是否退出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//收到未捕获的异常时，决定是否要崩溃</span><br><span class="line">//如果开发人员标记已知的操作型错误使用：error.isOperational=true</span><br><span class="line"></span><br><span class="line">process.on(&apos;uncaughtException&apos;, function(error) &#123;</span><br><span class="line"> errorManagement.handler.handleError(error);</span><br><span class="line"> if(!errorManagement.handler.isTrustedError(error))</span><br><span class="line"> process.exit(1)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//封装错误处理相关逻辑在集中的错误处理中</span><br><span class="line">function errorHandler()&#123;</span><br><span class="line"> this.handleError = function (error) &#123;</span><br><span class="line"> return logger.logError(err).then(sendMailToAdminIfCritical).then(saveInOpsQueueIfCritical).then(determineIfOperationalError);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> this.isTrustedError = function(error)</span><br><span class="line"> &#123;</span><br><span class="line"> return error.isOperational;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-使用一个成熟的日志工具提高错误的可见性"><a href="#2-7-使用一个成熟的日志工具提高错误的可见性" class="headerlink" title="2.7 使用一个成熟的日志工具提高错误的可见性"></a>2.7 使用一个成熟的日志工具提高错误的可见性</h2><p>定义: 一系列成熟的日志工具，比如Winston，Bunyan和Log4J，会加速错误的发现和理解。忘记console.log吧。</p><p>否则: 浏览console的log，和不通过查询工具或者一个好的日志查看器，手动浏览繁琐的文本文件，会使你忙于工作到很晚。</p><h3 id="代码示例-–-使用Winston-Logger"><a href="#代码示例-–-使用Winston-Logger" class="headerlink" title="代码示例 – 使用Winston Logger"></a>代码示例 – 使用Winston Logger</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//您的集中式logger对象</span><br><span class="line">var logger = new winston.Logger(&#123;</span><br><span class="line">  level: &apos;info&apos;,</span><br><span class="line">  transports: [</span><br><span class="line">    new (winston.transports.Console)(),</span><br><span class="line">    new (winston.transports.File)(&#123; filename: &apos;somefile.log&apos; &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//在某个地方使用logger的自定义代码</span><br><span class="line">logger.log(&apos;info&apos;, &apos;Test Log Message with some parameter %s&apos;, &apos;some parameter&apos;, &#123; anything: &apos;This is metadata&apos; &#125;);</span><br></pre></td></tr></table></figure><p>### </p><h3 id="代码示例-–-查询日志文件夹-搜索条目"><a href="#代码示例-–-查询日志文件夹-搜索条目" class="headerlink" title="代码示例 – 查询日志文件夹 (搜索条目)"></a>代码示例 – 查询日志文件夹 (搜索条目)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var options = &#123;</span><br><span class="line">    from: new Date - 24 * 60 * 60 * 1000,</span><br><span class="line">    until: new Date,</span><br><span class="line">    limit: 10,</span><br><span class="line">    start: 0,</span><br><span class="line">    order: &apos;desc&apos;,</span><br><span class="line">    fields: [&apos;message&apos;]</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 查找在今天和昨天之间记录的项目</span><br><span class="line">  winston.query(options, function (err, results) &#123;</span><br><span class="line">    //对于结果的回调处理</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="2-8-使用你最喜欢的测试框架测试错误流"><a href="#2-8-使用你最喜欢的测试框架测试错误流" class="headerlink" title="2.8 使用你最喜欢的测试框架测试错误流"></a>2.8 使用你最喜欢的测试框架测试错误流</h2><p>定义: 无论专业的自动化测试或者简单的手动开发测试 - 确保您的代码不仅满足正常的场景，而且处理并且返回正确的错误。测试框架，比如Mocha &amp; Chai可以非常容易的处理这些问题（在”Gist popup”中查看代码实例）。</p><p>否则: 没有测试，不管自动还是手动，您不可能依赖代码去返回正确的错误。而没有可以理解的错误，那将毫无错误处理可言。</p><h3 id="代码示例-使用-Mocha-amp-Chai-确保正确的异常被抛出"><a href="#代码示例-使用-Mocha-amp-Chai-确保正确的异常被抛出" class="headerlink" title="代码示例: 使用 Mocha &amp; Chai 确保正确的异常被抛出"></a>代码示例: 使用 Mocha &amp; Chai 确保正确的异常被抛出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;Facebook chat&quot;, () =&gt; &#123;</span><br><span class="line"> it(&quot;Notifies on new chat message&quot;, () =&gt; &#123;</span><br><span class="line"> var chatService = new chatService();</span><br><span class="line"> chatService.participants = getDisconnectedParticipants();</span><br><span class="line"> expect(chatService.sendMessage.bind(&#123;message: &quot;Hi&quot;&#125;)).to.throw(ConnectionError);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>### </p><h3 id="代码示例-确保-API-返回正确的-HTTP-错误码"><a href="#代码示例-确保-API-返回正确的-HTTP-错误码" class="headerlink" title="代码示例: 确保 API 返回正确的 HTTP 错误码"></a>代码示例: 确保 API 返回正确的 HTTP 错误码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it(&quot;Creates new Facebook group&quot;, function (done) &#123;</span><br><span class="line"> var invalidGroupInfo = &#123;&#125;;</span><br><span class="line"> httpRequest(&#123;method: &apos;POST&apos;, uri: &quot;facebook.com/api/groups&quot;, resolveWithFullResponse: true, body: invalidGroupInfo, json: true</span><br><span class="line"> &#125;).then((response) =&gt; &#123;</span><br><span class="line"> //oh no if we reached here than no exception was thrown</span><br><span class="line"> &#125;).catch(function (response) &#123;</span><br><span class="line"> expect(400).to.equal(response.statusCode);</span><br><span class="line"> done();</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h2 id="2-9-捕获未处理的promise-rejections"><a href="#2-9-捕获未处理的promise-rejections" class="headerlink" title="2.9 捕获未处理的promise rejections"></a>2.9 捕获未处理的promise rejections</h2><p>定义: 任何在promise中被抛出的异常将被收回和遗弃，除非开发者没有忘记去明确的处理。即使您的代码调用的是process.uncaughtException！解决这个问题可以注册到事件process.unhandledRejection。</p><p>否则: 您的错误将被回收，无踪迹可循。没有什么可以需要考虑。</p><h3 id="代码示例-这些错误将不会得到任何错误处理程序捕获（除unhandledrejection）"><a href="#代码示例-这些错误将不会得到任何错误处理程序捕获（除unhandledrejection）" class="headerlink" title="代码示例: 这些错误将不会得到任何错误处理程序捕获（除unhandledrejection）"></a>代码示例: 这些错误将不会得到任何错误处理程序捕获（除unhandledrejection）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DAL.getUserById(1).then((johnSnow) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  //this error will just vanish</span><br><span class="line">if(johnSnow.isAlive == false)</span><br><span class="line">    throw new Error(&apos;ahhhh&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="代码示例-捕获-unresolved-和-rejected-的-promise"><a href="#代码示例-捕获-unresolved-和-rejected-的-promise" class="headerlink" title="代码示例: 捕获 unresolved 和 rejected 的 promise"></a>代码示例: 捕获 unresolved 和 rejected 的 promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;unhandledRejection&apos;, (reason, p) =&gt; &#123;</span><br><span class="line">  //我刚刚捕获了一个未处理的promise rejection, 因为我们已经有了对于未处理错误的后备的处理机制（见下面）, 直接抛出，让它来处理</span><br><span class="line">  throw reason;</span><br><span class="line">&#125;);</span><br><span class="line">process.on(&apos;uncaughtException&apos;, (error) =&gt; &#123;</span><br><span class="line">  //我刚收到一个从未被处理的错误，现在处理它，并决定是否需要重启应用</span><br><span class="line">  errorManagement.handler.handleError(error);</span><br><span class="line">  if (!errorManagement.handler.isTrustedError(error))</span><br><span class="line">    process.exit(1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-10-快速查错，验证参数使用一个专门的库Fail-fast-validate-arguments-using-a-dedicated-library"><a href="#2-10-快速查错，验证参数使用一个专门的库Fail-fast-validate-arguments-using-a-dedicated-library" class="headerlink" title="2.10 快速查错，验证参数使用一个专门的库Fail fast, validate arguments using a dedicated library"></a>2.10 快速查错，验证参数使用一个专门的库Fail fast, validate arguments using a dedicated library</h2><p>定义: 这应该是您的Express最佳实践中的一部分 – assert API输入避免难以理解的漏洞，这类漏洞以后会非常难以追踪。而验证代码通常是一件乏味的事情，除非使用一些非常炫酷的帮助库比如Joi。</p><p>否则: 考虑这种情况 – 您的功能期望一个数字参数 “Discount” ，然而调用者忘记传值，之后在您的代码中检查是否 Discount!=0 （允许的折扣值大于零），这样它将允许用户使用一个折扣。OMG，多么不爽的一个漏洞。你能明白吗？</p><h3 id="代码示例-使用‘Joi’验证复杂的JSON输入"><a href="#代码示例-使用‘Joi’验证复杂的JSON输入" class="headerlink" title="代码示例: 使用‘Joi’验证复杂的JSON输入"></a>代码示例: 使用‘Joi’验证复杂的JSON输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var memberSchema = Joi.object().keys(&#123;</span><br><span class="line"> password: Joi.string().regex(/^[a-zA-Z0-9]&#123;3,30&#125;$/),</span><br><span class="line"> birthyear: Joi.number().integer().min(1900).max(2013),</span><br><span class="line"> email: Joi.string().email()</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">function addNewMember(newMember)</span><br><span class="line">&#123;</span><br><span class="line"> //assertions come first</span><br><span class="line"> Joi.assert(newMember, memberSchema); //throws if validation fails</span><br><span class="line"> //other logic here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>### </p><h3 id="反模式-没有验证会产生令人讨厌的错误"><a href="#反模式-没有验证会产生令人讨厌的错误" class="headerlink" title="反模式: 没有验证会产生令人讨厌的错误"></a>反模式: 没有验证会产生令人讨厌的错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//假如折扣为正，重定向用户去打印他的折扣优惠劵</span><br><span class="line">function redirectToPrintDiscount(httpResponse, member, discount)</span><br><span class="line">&#123;</span><br><span class="line">    if(discount != 0)</span><br><span class="line">        httpResponse.redirect(`/discountPrintView/$&#123;member.id&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">redirectToPrintDiscount(httpResponse, someMember);</span><br><span class="line">//忘记传递参数discount, 为什么用户被重定向到折扣页面？</span><br></pre></td></tr></table></figure><ol start="2"><li>编码规范实践<h2 id="3-1-使用一款风格管理工具"><a href="#3-1-使用一款风格管理工具" class="headerlink" title="3.1 使用一款风格管理工具"></a>3.1 使用一款风格管理工具</h2>定义: <a href="https://eslint.org/" target="_blank" rel="noopener">ESLint</a>，<a href="https://github.com/standard/standard" target="_blank" rel="noopener">Standard</a> 是检查可能的代码错误和修复代码样式的事实上的标准，不仅可以识别实际的间距问题, 而且还可以检测严重的反模式代码, 如开发人员在不分类的情况下抛出错误。尽管ESlint可以自动修复代码样式，但其他的工具比如 <a href="https://www.npmjs.com/package/prettier" target="_blank" rel="noopener">prettier</a> 和 <a href="https://www.npmjs.com/package/js-beautify" target="_blank" rel="noopener">beautify</a>在格式化修复上功能强大，可以和Eslint结合起来使用。</li></ol><p>否则: 开发人员将必须关注单调乏味的间距和线宽问题, 并且时间可能会浪费在过多考虑项目的代码样式。</p><h2 id="3-2-变量、常量、函数和类的命名约定"><a href="#3-2-变量、常量、函数和类的命名约定" class="headerlink" title="3.2 变量、常量、函数和类的命名约定"></a>3.2 变量、常量、函数和类的命名约定</h2><p>定义: 当命名变量和方法的时候，使用 <em>lowerCamelCase</em> ，当命名类的时候，使用 <em>UpperCamelCase</em> （首字母大写），对于常量，则 <em>UPPERCASE</em> 。这将帮助您轻松地区分普通变量/函数和需要实例化的类。使用描述性名称，但使它们尽量简短。</p><p>否则: JavaScript是世界上唯一一门不需要实例化，就可以直接调用构造函数（”Class”）的编码语言。因此，类和函数的构造函数由采用UpperCamelCase开始区分。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 使用UpperCamelCase命名类名</span><br><span class="line">class SomeClassExample () &#123; </span><br><span class="line">  </span><br><span class="line">  // 常量使用const关键字，并使用lowerCamelCase命名</span><br><span class="line">  const config = &#123;</span><br><span class="line">    key: &apos;value&apos;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  // 变量和方法使用lowerCamelCase命名</span><br><span class="line">  let someVariableExample = &apos;value&apos;;</span><br><span class="line">  function doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-先-require-而不是在方法内部"><a href="#3-3-先-require-而不是在方法内部" class="headerlink" title="3.3 先 require, 而不是在方法内部"></a>3.3 先 require, 而不是在方法内部</h2><p>定义: 在每个文件的起始位置，在任何函数的前面和外部require模块。这种简单的最佳实践，不仅能帮助您轻松快速地在文件顶部辨别出依赖关系，而且避免了一些潜在的问题。</p><p>否则: 在Node.js中，require 是同步运行的。如果从函数中调用它们，它可能会阻塞其他请求，在更关键的时间得到处理。另外，如果所require的模块或它自己的任何依赖项抛出错误并使服务器崩溃，最好尽快查明它，如果该模块在函数中require的，则可能不是这样的情况。</p><p><strong>错误代码示例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function myClassFunction () &#123;</span><br><span class="line">  const _ = require(&apos;lodash&apos;)</span><br><span class="line">  </span><br><span class="line">  return _.merge(&#123;name: &apos;class&apos;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正确代码示例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const _ = require(&apos;lodash&apos;)</span><br><span class="line">function myClassFunction () &#123;</span><br><span class="line"></span><br><span class="line">  return _.merge(&#123;name: &apos;class&apos;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>## </p><h2 id="3-4-在文件夹上-require-，而不是直接在文件上"><a href="#3-4-在文件夹上-require-，而不是直接在文件上" class="headerlink" title="3.4 在文件夹上 require ，而不是直接在文件上"></a>3.4 在文件夹上 require ，而不是直接在文件上</h2><p>定义: 当在一个文件夹中开发库/模块，放置一个文件index.js暴露模块的 内部，这样每个消费者都会通过它。这将作为您模块的一个接口，并使未来的变化简单而不违反规则。</p><p>否则: 更改文件内部结构或签名可能会破坏与客户端的接口。</p><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 建议</span><br><span class="line">module.exports.SMSProvider = require(&apos;./SMSProvider&apos;);</span><br><span class="line">module.exports.SMSNumberResolver = require(&apos;./SMSNumberResolver&apos;);</span><br><span class="line"></span><br><span class="line">// 避免</span><br><span class="line">module.exports.SMSProvider = require(&apos;./SMSProvider/SMSProvider.js&apos;);</span><br><span class="line">module.exports.SMSNumberResolver = require(&apos;./SMSNumberResolver/SMSNumberResolver.js&apos;);</span><br></pre></td></tr></table></figure><ol start="3"><li>测试和总体质量实践<h2 id="4-1-至少，编写API（组件）测试"><a href="#4-1-至少，编写API（组件）测试" class="headerlink" title="4.1 至少，编写API（组件）测试"></a>4.1 至少，编写API（组件）测试</h2>定义: 大多数项目只是因为时间表太短而没有进行任何自动化测试，或者测试项目失控而正被遗弃。因此，优先从API测试开始，这是最简单的编写和提供比单元测试更多覆盖率的事情（你甚至可能不需要编码而进行API测试，像<a href="https://www.getpostman.com/" target="_blank" rel="noopener">Postman</a>。之后，如果您有更多的资源和时间，继续使用高级测试类型，如单元测试、DB测试、性能测试等。</li></ol><p>否则: 您可能需要花很长时间编写单元测试，才发现只有20%的系统覆盖率。</p><h2 id="4-2-使用一个linter检测代码问题"><a href="#4-2-使用一个linter检测代码问题" class="headerlink" title="4.2 使用一个linter检测代码问题"></a>4.2 使用一个linter检测代码问题</h2><p>定义: 使用代码linter检查基本质量并及早检测反模式。在任何测试之前运行它, 并将其添加为预提交的git钩子, 以最小化审查和更正任何问题所需的时间。也可在<a href="https://github.com/i0natan/nodebestpractices#3-code-style-practices" target="_blank" rel="noopener">Section 3</a>中查阅编码样式实践</p><p>否则: 您可能让一些反模式和易受攻击的代码传递到您的生产环境中。</p><p><strong>代码示例（</strong><a href="https://github.com/typicode/husky" target="_blank" rel="noopener">husky</a><strong>）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;husky&quot;: &#123;</span><br><span class="line">   &quot;hooks&quot;: &#123;</span><br><span class="line">     &quot;pre-commit&quot;: &quot;standard &amp;&amp; yarn test&quot;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-经常检查易受攻击的依赖"><a href="#4-3-经常检查易受攻击的依赖" class="headerlink" title="4.3 经常检查易受攻击的依赖"></a>4.3 经常检查易受攻击的依赖</h2><p>定义: 即使是那些最有名的依赖模块，比如Express，也有已知的漏洞。使用社区和商业工具，比如 🔗 <a href="https://github.com/nodesecurity/nsp" target="_blank" rel="noopener">nsp</a> ，集成在您的CI平台上，在每一次构建的时候都会被调用，这样可以很容易地解决漏洞问题。</p><p>否则: 在没有专用工具的情况下，使代码清除漏洞，需要不断地跟踪有关新威胁的在线出版物，相当繁琐。</p><h2 id="4-4-检查过期的依赖包"><a href="#4-4-检查过期的依赖包" class="headerlink" title="4.4 检查过期的依赖包"></a>4.4 检查过期的依赖包</h2><p>定义: 使用您的首选工具 (例如 “npm outdated” or <a href="https://github.com/tjunnone/npm-check-updates" target="_blank" rel="noopener">npm-check-updates</a> 来检测已安装的过期依赖包, 将此检查注入您的 CI 管道, 甚至在严重的情况下使构建失败。例如, 当一个已安装的依赖包滞后5个补丁时 (例如:本地版本是1.3.1 的, 存储库版本是1.3.8 的), 或者它被其作者标记为已弃用, 可能会出现严重的情况 - 停掉这次构建并防止部署此版本。</p><p>否则: 您的生产环境将运行已被其作者明确标记为有风险的依赖包</p><ol start="4"><li>进入生产实践<h2 id="5-1-监控"><a href="#5-1-监控" class="headerlink" title="5.1. 监控!"></a>5.1. 监控!</h2>定义: 监控是一种在顾客之前发现问题的游戏 – 显然这应该被赋予前所未有的重要性。考虑从定义你必须遵循的基本度量标准开始（我的建议在里面），到检查附加的花哨特性并选择解决所有问题的解决方案。市场已经淹没其中。点击下面的 ‘The Gist’ ，了解解决方案的概述。</li></ol><p>否则: 错误 === 失望的客户. 非常简单.</p><h3 id="监控示例：StackDriver默认仪表板。很难提取应用内指标"><a href="#监控示例：StackDriver默认仪表板。很难提取应用内指标" class="headerlink" title="监控示例：StackDriver默认仪表板。很难提取应用内指标"></a>监控示例：StackDriver默认仪表板。很难提取应用内指标</h3><p><a href="https://github.com/i0natan/nodebestpractices/blob/master/assets/images/monitoring2.jpg" target="_blank" rel="noopener">null</a></p><p>### </p><h3 id="监控示例：Grafana作为可视化原始数据的UI层"><a href="#监控示例：Grafana作为可视化原始数据的UI层" class="headerlink" title="监控示例：Grafana作为可视化原始数据的UI层"></a>监控示例：Grafana作为可视化原始数据的UI层</h3><p><a href="https://github.com/i0natan/nodebestpractices/blob/master/assets/images/monitoring3.png" target="_blank" rel="noopener">null</a></p><h2 id="5-2-使用智能日志增加透明度"><a href="#5-2-使用智能日志增加透明度" class="headerlink" title="5.2. 使用智能日志增加透明度"></a>5.2. 使用智能日志增加透明度</h2><p>定义: 日志可以是调试语句的一个不能说话的仓库，或者表述应用运行过程的一个漂亮仪表板的驱动。从第1天计划您的日志平台：如何收集、存储和分析日志，以确保所需信息（例如，错误率、通过服务和服务器等完成整个事务）都能被提取出来。</p><p>否则: 您最终像是面对一个黑盒，不知道发生了什么事情，然后你开始重新写日志语句添加额外的信息。</p><h3 id="一段解释-4"><a href="#一段解释-4" class="headerlink" title="一段解释"></a>一段解释</h3><p>无论如何，您要打印日志，显然需要一些可以在其中跟踪错误和核心指标的接口来包装生产环境信息（例如，每小时发生了多少错误，最慢的API节点是哪一个）为什么不在健壮的日志框架中进行一些适度的尝试呢? 要实现这一目标，需要在三个步骤上做出深思熟虑的决定:</p><ol><li><p>智能日志 – 在最基本的情况下，您需要使用像<a href="https://github.com/winstonjs/winston" target="_blank" rel="noopener">Winston</a>, <a href="https://github.com/trentm/node-bunyan" target="_blank" rel="noopener">Bunyan</a>这样有信誉的日志库，在每个事务开始和结束时输出有意义的信息。还可以考虑将日志语句格式化为JSON，并提供所有上下文属性（如用户id、操作类型等）。这样运维团队就可以在这些字段上操作。在每个日志行中包含一个唯一的transaction ID，更多的信息查阅条款 “Write transaction-id to log”。最后要考虑的一点还包括一个代理，它记录系统资源，如内存和CPU，比如Elastic Beat。</p></li><li><p>智能聚合 – 一旦您在服务器文件系统中有了全面的信息，就应该定期将这些信息推送到一个可以聚合、处理和可视化数据的系统中。例如，Elastic stack是一种流行的、自由的选择，它提供所有组件去聚合和产生可视化数据。许多商业产品提供了类似的功能，只是它们大大减少了安装时间，不需要主机托管。</p></li><li><p>智能可视化 – 现在的信息是聚合和可搜索的, 一个可以满足仅仅方便地搜索日志的能力, 可以走得更远, 没有编码或花费太多的努力。我们现在可以显示一些重要的操作指标, 如错误率、平均一天CPU使用, 在过去一小时内有多少新用户选择, 以及任何其他有助于管理和改进我们应用程序的指标。</p><h3 id="可视化示例-Kibana-Elastic-stack的一部分-促进了对日志内容的高级搜索"><a href="#可视化示例-Kibana-Elastic-stack的一部分-促进了对日志内容的高级搜索" class="headerlink" title="可视化示例: Kibana(Elastic stack的一部分)促进了对日志内容的高级搜索"></a>可视化示例: Kibana(Elastic stack的一部分)促进了对日志内容的高级搜索</h3><p><a href="https://github.com/i0natan/nodebestpractices/blob/master/assets/images/smartlogging1.png" target="_blank" rel="noopener">null</a><br>### </p><h3 id="可视化示例-Kibana-Elastic-stack的一部分-基于日志来可视化数据"><a href="#可视化示例-Kibana-Elastic-stack的一部分-基于日志来可视化数据" class="headerlink" title="可视化示例: Kibana(Elastic stack的一部分)基于日志来可视化数据"></a>可视化示例: Kibana(Elastic stack的一部分)基于日志来可视化数据</h3><p><a href="https://github.com/i0natan/nodebestpractices/blob/master/assets/images/smartlogging2.jpg" target="_blank" rel="noopener">null</a></p></li></ol><h2 id="5-3-锁住依赖"><a href="#5-3-锁住依赖" class="headerlink" title="5.3 锁住依赖"></a>5.3 锁住依赖</h2><p>定义: 您的代码必须在所有的环境中是相同的，但是令人惊讶的是，NPM默认情况下会让依赖在不同环境下发生偏移 – 当在不同的环境中安装包的时候，它试图拿包的最新版本。克服这种问题可以利用NPM配置文件， .npmrc，告诉每个环境保存准确的（不是最新的）包的版本。另外，对于更精细的控制，使用NPM “shrinkwrap”。*更新：作为NPM5，依赖默认锁定。新的包管理工具，Yarn，也默认锁定。</p><p>否则: QA测试通过的代码和批准的版本，在生产中表现不一致。更糟糕的是，同一生产集群中的不同服务器可能运行不同的代码。</p><h3 id="一段解释-5"><a href="#一段解释-5" class="headerlink" title="一段解释"></a>一段解释</h3><p>您的代码依赖于许多外部包，假设它“需要”和使用momentjs-2.1.4，默认情况下，当布署到生产中时，npm可能会获得momentjs 2.1.5，但不幸的是，这将带来一些新的bug。使用npm配置文件和设置 –save-exact=true 指示npm去完成安装，以便下次运行 npm install（在生产或在Docker容器中，您计划将其用于测试）时，将获取相同的依赖版本。另一种可选择受欢迎的方法是使用一个shrinkwrap文件（很容易使用npm生成）指出应该安装哪些包和版本，这样就不需要环境来获取新版本了。</p><ul><li>更新: 在npm5中，使用.shrinkwrap依赖项会被自动锁定。Yarn，一个新兴的包管理器，默认情况下也会锁定依赖项。<h3 id="代码示例-npmrc文件指示npm使用精确的版本"><a href="#代码示例-npmrc文件指示npm使用精确的版本" class="headerlink" title="代码示例: .npmrc文件指示npm使用精确的版本"></a>代码示例: .npmrc文件指示npm使用精确的版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在项目目录上保存这个为.npmrc 文件</span><br><span class="line">save-exact:true</span><br></pre></td></tr></table></figure></li></ul><p>### </p><h3 id="代码示例-shirnkwrap-json文件获取准确的依赖关系树"><a href="#代码示例-shirnkwrap-json文件获取准确的依赖关系树" class="headerlink" title="代码示例: shirnkwrap.json文件获取准确的依赖关系树"></a>代码示例: shirnkwrap.json文件获取准确的依赖关系树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;A&quot;,</span><br><span class="line">    &quot;dependencies&quot;: &#123;</span><br><span class="line">        &quot;B&quot;: &#123;</span><br><span class="line">            &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">            &quot;dependencies&quot;: &#123;</span><br><span class="line">                &quot;C&quot;: &#123; </span><br><span class="line">                    &quot;version&quot;: &quot;0.1.0&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>### </p><h3 id="代码示例-npm5依赖锁文件-package-json"><a href="#代码示例-npm5依赖锁文件-package-json" class="headerlink" title="代码示例: npm5依赖锁文件 - package.json"></a>代码示例: npm5依赖锁文件 - package.json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;package-name&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">    &quot;lockfileVersion&quot;: 1,</span><br><span class="line">    &quot;dependencies&quot;: &#123;</span><br><span class="line">        &quot;cacache&quot;: &#123;</span><br><span class="line">            &quot;version&quot;: &quot;9.2.6&quot;,</span><br><span class="line">            &quot;resolved&quot;: &quot;https://registry.npmjs.org/cacache/-/cacache-9.2.6.tgz&quot;,</span><br><span class="line">            &quot;integrity&quot;: &quot;sha512-YK0Z5Np5t755edPL6gfdCeGxtU0rcW/DBhYhYVDckT+7AFkCCtedf2zru5NRbBLFk6e7Agi/RaqTOAfiaipUfg==&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;duplexify&quot;: &#123;</span><br><span class="line">            &quot;version&quot;: &quot;3.5.0&quot;,</span><br><span class="line">            &quot;resolved&quot;: &quot;https://registry.npmjs.org/duplexify/-/duplexify-3.5.0.tgz&quot;,</span><br><span class="line">            &quot;integrity&quot;: &quot;sha1-GqdzAC4VeEV+nZ1KULDMquvL1gQ=&quot;,</span><br><span class="line">            &quot;dependencies&quot;: &#123;</span><br><span class="line">                &quot;end-of-stream&quot;: &#123;</span><br><span class="line">                    &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">                    &quot;resolved&quot;: &quot;https://registry.npmjs.org/end-of-stream/-/end-of-stream-1.0.0.tgz&quot;,</span><br><span class="line">                    &quot;integrity&quot;: &quot;sha1-1FlucCc0qT5A6a+GQxnqvZn/Lw4=&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p># </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;基于 &lt;a href=&quot;https://github.com/expressjs/express&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Express&lt;/a&gt; 实践，Express 是一个简洁而灵活的 node.js We
      
    
    </summary>
    
      <category term="总结" scheme="https://sensitivemix.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Node.js" scheme="https://sensitivemix.github.io/tags/Node-js/"/>
    
      <category term="BestPractice" scheme="https://sensitivemix.github.io/tags/BestPractice/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB Aggregation 业务场景实战</title>
    <link href="https://sensitivemix.github.io/2018/08/13/MongoDB-Aggregation-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E5%AE%9E%E6%88%98/"/>
    <id>https://sensitivemix.github.io/2018/08/13/MongoDB-Aggregation-业务场景实战/</id>
    <published>2018-08-13T07:12:35.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images-cdn.shimo.im/PYv34sYTcsMSc6Nb/image.png!thumbnail" alt="图片"></p><p>对于技术人员来说，“管道” 相信大家都不会感到陌生，在很多技术领域都有管道的概念，例如Linux 管道，CI/CD 管道。同样的，MongoDB 2.2 版本也新增了聚合管道功能，虽然功能发布已久，但是社区的复杂场景的实践并不多，给大家造成了<strong>聚合管道</strong>“不好用”的错觉 。实际在业务场景中，适当的运用聚合往往会带来事半功倍的效果。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>要想了解聚合管道在业务场景中的使用，首先需要了解<strong>聚合管道</strong>的定义：</p><p>聚合管道用于数据处理，每个文档通过一个或者是多个阶段组成，可以对每个分组进行<strong>分组</strong>和<strong>过滤</strong>等功能，然后经过一系列处理，输出相应的结果。</p><p><img src="https://images-cdn.shimo.im/8BmyIAhe5HAeDqY5/image.png!thumbnail" alt="图片"></p><p>通过这张图，可以清晰的了解到<strong>聚合管道</strong>的处理过程，我们常用的管道操作符一般有以下这些：</p><ul><li>$match 主要用于对文档集合的筛选</li><li>$project 主要用于从子文档中提取字段，可以重命名字段，也可以移除字段</li><li>$group 主要用于根据文档的特定字段进行分组</li><li>$unwind 主要用于分割数组嵌入到自己的顶层文件</li><li>$lookup 主要用于两个集合之间的左连接操作</li><li>$skip 接受一个数字 n，丢弃结果集中的前 n 个文档</li><li>$limit 接受一个数字 n，返回结果集中的前 n 个文档</li><li>$sort 主要用于结果集的排序<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1>看完了各种各样的管道操作符，或许有的人在想怎么把它利用在实际业务场景中呢？下面我就通过客户管理系统介绍一下聚合管道的最佳实践，大家听到客户管理系统可能有些陌生，它还有一个“别名” CRM。CRM 系统中存在机会、客户、联系人这三个大的对象，对象之间都是存在关联关系的，机会可以关联多个联系人，可以关联一个客户，而联系人和客户是一一对应的。通过三个基本对象我们可以衍生出很多聚合业务场景，基础架构图如下所示：<br><img src="https://images-cdn.shimo.im/cRSY8YJpYh8vgzEs/crm架构图_1_.png!thumbnail" alt="图片"><br>图一：基础架构图</li></ul><p>如上图所示，我们业务场景中经常会出现筛选数据的需求，如条件筛选和自定义字段查询等需求，根据特定的条件筛选出我们想要的数据。针对不同的业务需求，我们一般会涉及到以下场景：</p><ul><li>基础对象查询</li><li>表 join 查询</li><li>分类统计</li><li>嵌套对象排序</li><li>…</li></ul><p>说到了常见的应用场景，下面也介绍一下我们的系统业务数据模型：</p><ul><li><p>机会数据模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.deals</span><br><span class="line">&#123;</span><br><span class="line">  &apos;_id&apos;: ObjectId,</span><br><span class="line">  &apos;title&apos;: String,               // 机会标题</span><br><span class="line">  &apos;status&apos;: String,              // 机会状态</span><br><span class="line">  &apos;peoples&apos;: Array,              // 关联联系人</span><br><span class="line">  &apos;_organizationId&apos;: ObjectId，  // 关联客户</span><br><span class="line">  &apos;createdTime&apos;: Date,           // 创建时间</span><br><span class="line">  &apos;updatedTime&apos;: Date,           // 创建时间</span><br><span class="line">  &apos;owner&apos;: Object                // 拥有者</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>联系人数据模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.peoples</span><br><span class="line">&#123;</span><br><span class="line">  &apos;_id&apos;: ObjectId,</span><br><span class="line">  &apos;name&apos;: String,                // 联系人名称</span><br><span class="line">  &apos;phone&apos;: Array,                // 电话</span><br><span class="line">  &apos;email&apos;: Array,                // 邮箱</span><br><span class="line">  &apos;isArchive&apos;: Boolean，         // 归档状态</span><br><span class="line">  &apos;createdTime&apos;: Date,           // 创建时间</span><br><span class="line">  &apos;updatedTime&apos;: Date,           // 创建时间</span><br><span class="line">  &apos;owner&apos;: Object                // 拥有者</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户数据模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.organizations</span><br><span class="line">&#123;</span><br><span class="line">  &apos;_id&apos;: ObjectId,</span><br><span class="line">  &apos;name&apos;: String,                // 客户名称</span><br><span class="line">  &apos;address&apos;: Array,              // 地址</span><br><span class="line">  &apos;isArchive&apos;: Boolean，         // 归档状态</span><br><span class="line">  &apos;createdTime&apos;: Date,           // 创建时间</span><br><span class="line">  &apos;updatedTime&apos;: Date,           // 创建时间</span><br><span class="line">  &apos;owner&apos;: Object                // 拥有者</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>有了数据模型，我们就可以用它来做数据聚合了，下面会列举出客户管理系统中常用的数据聚合实践。</p><ol><li>在 CRM 系统中，作为销售管理，他管辖的地区在指定时间生成的机会是他所关注的。如果他需要筛选出2018年5月1日之后创建的机会的跟进信息，可以通过创建时间的筛选实现他的目标，聚合管道语句如下：</li></ol><p>涉及到的组合：<strong>$match -&gt; $project</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.deals.aggregate([</span><br><span class="line">  &#123; $match: &#123; createdTime: &#123; &apos;$gte&apos;: ISODate(&apos;2018-05-01&apos;) &#125; &#125; &#125;,</span><br><span class="line">  &#123; $project: &#123; title: 1, owner: 1, status: 1, updatedTime: 1 &#125; &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><ol><li>在 CRM 系统中，作为销售管理，经常需要统计每个销售业绩情况，用于他们的业绩考核指标。所以他需要统计每个销售赢单的机会数目，为了达成这一目标他可以先通过匹配条件筛选出所有赢单的机会，并过滤所有拥有者为空，然后再通过人员分组，计算每个销售赢单的机会数，聚合管道语句如下所示：</li></ol><p>涉及到的组合：<strong>$match -&gt; $group</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.deals.aggregate([</span><br><span class="line">  &#123; $match: &#123; status: &apos;won&apos;, owner: &#123; &apos;$ne&apos;: null &#125; &#125; &#125;,</span><br><span class="line">  &#123; $group: &#123; _id: &apos;$owner._id&apos;，num_deals: &#123; $sum: 1 &#125; &#125; &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><ol><li>在 CRM 系统中，作为一名销售，经常需要拜访客户，拜访完成之后需要在机会中填写相应的跟进记录，所以对于他们来说需要完整的客户地址信息，用于日后的拜访使用。这时候他就可以根据拥有者是自己，并且关联的客户地址信息为空的筛选条件来找到那些机会信息缺失。一般情况下，便于记忆我们按照创建时间倒序要显示机会信息，聚合管道语句如下所示：</li></ol><p>涉及到的组合：<strong>$match -&gt; $lookup -&gt; $match -&gt; $sort</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.deals.aggregate([</span><br><span class="line">  &#123; $match: &#123; &apos;owner.name&apos;: &apos;张三&apos; &#125; &#125;,</span><br><span class="line">  &#123; $lookup: &#123;</span><br><span class="line">      from: &apos;organizations&apos;,</span><br><span class="line">      localField: &apos;_organizationId&apos;,</span><br><span class="line">      foreignField: &apos;_id&apos;,</span><br><span class="line">      as: &apos;organization&apos;</span><br><span class="line">  &#125; &#125;,</span><br><span class="line">  &#123; $match: &#123; &apos;organization.address&apos;: &#123;&apos;$ne&apos;: &apos;&apos;&#125; &#125; &#125;,</span><br><span class="line">  &#123; $sort: &#123; &apos;createdTime&apos;: -1 &#125; &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><ol><li>在 CRM 系统中，作为一名刚入职的销售，可以通过查看别人的赢单的跟单机会来学习如何跟单。这时候他就可以根据状态是赢单且拥有者是张三的筛选条件，找出别人最近赢单的50条销售机会来进行学习。聚合管道语句如下所示：</li></ol><p>涉及到的组合：<strong>$match -&gt; $project -&gt; $sort -&gt; $skip -&gt; $limit</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.deals.aggregate([</span><br><span class="line">  &#123; $match: &#123; &apos;status&apos;: &apos;won&apos;, &apos;owner.name&apos;: &apos;张三&apos; &#125; &#125;,</span><br><span class="line">  &#123; $project: &#123; &apos;name&apos;: 1, &apos;status&apos;: 1, &apos;wonTime&apos;: 1, &apos;note&apos;: 1 &#125;,</span><br><span class="line">  &#123; $sort: &#123; &apos;wonTime&apos;: -1 &#125;,</span><br><span class="line">  &#123; $skip: 0 &#125;,</span><br><span class="line">  &#123; $limit: 50 &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><ol><li>在 CRM 系统中，我们习惯把数据的完整性和成单概率挂钩，如果销售机会关联的联系人和客户信息缺失，往往代表这是一条成单率较低的机会。因为缺失联系人信息无法及时与客户联系会造成失单，所以我们可以通过聚合管道关联操作，寻找存在一个已归档或者拥有者为空的联系人和客户，找出对应的销售机会，评估该机会的信息缺失率，然后完善关联信息。聚合管道语句如下：</li></ol><p>涉及到的组合：<strong>$match -&gt; $lookup -&gt; $lookup -&gt; $match -&gt; $sort -&gt; $skip -&gt; $limit</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">db.deals.aggregate([</span><br><span class="line">  &#123; $match: &#123; </span><br><span class="line">      &apos;owner.name&apos;: &apos;张三&apos;,</span><br><span class="line">      &apos;$or&apos;: [</span><br><span class="line">        &#123; &apos;peoples&apos;: &#123; &apos;$ne&apos;: null &#125; &#125;, </span><br><span class="line">        &#123; &apos;_organizationId&apos;:&#123; &apos;$ne&apos;: null &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; $lookup: &#123;</span><br><span class="line">      from: &apos;peoples&apos;,</span><br><span class="line">      localField: &apos;peoples&apos;,</span><br><span class="line">      foreignField: &apos;_id&apos;,</span><br><span class="line">      as: &apos;peoples&apos;</span><br><span class="line">  &#125; &#125;,</span><br><span class="line">  &#123; $lookup: &#123;</span><br><span class="line">      from: &apos;organizations&apos;,</span><br><span class="line">      localField: &apos;_organizationId&apos;,</span><br><span class="line">      foreignField: &apos;_id&apos;,</span><br><span class="line">      as: &apos;organization&apos;</span><br><span class="line">  &#125; &#125;,</span><br><span class="line">  &#123; $match: &#123; </span><br><span class="line">      &apos;$or&apos;: [</span><br><span class="line">        &#123; &apos;peoples.isArchive&apos;: true &#125;,</span><br><span class="line">        &#123; &apos;peoples.owner&apos;: &#123; &apos;$ne&apos;: null &#125; &#125;,</span><br><span class="line">        &#123; &apos;organization.isArchive&apos;: true &#125;,</span><br><span class="line">        &#123; &apos;organization.owner&apos;: &#123; &apos;$ne&apos;: null &#125; &#125;</span><br><span class="line">      ]      </span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; $sort: &#123; &apos;createdTime&apos;: -1 &#125; &#125;,</span><br><span class="line">  &#123; $skip: 0 &#125;,</span><br><span class="line">  &#123; $limit: 50 &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>我们在使用聚合管道满足我们的业务场景的同时，发现有很多小的技巧能够帮助我们优化数据查询，下面给大家列举一下：</p><ul><li>管道操作符之<strong>$ifNull</strong></li></ul><p>定义：如果表达式计算为非空值，则计算表达式并返回表达式的值。如果表达式计算为空值，包括未定义的值或缺少字段的实例，则返回替换表达式的值。</p><p>如果需求是按照更新时间对未归档机会进行排序，普通的做法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.deals.aggregate([</span><br><span class="line">  &#123; $match: &#123; &apos;isArchive&apos;: false &#125; &#125;,</span><br><span class="line">  &#123; $sort: &#123; &apos;updatedTime&apos;: -1 &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><p>这样存在一个问题，由于存在更新时间字段不存在或者值为空的脏数据，导致排序结果不准确，为了解决这个问题，当然我们也可以这样去做，排序里面指定多个字段排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.deals.aggregate([</span><br><span class="line">  &#123; $match: &#123; &apos;isArchive&apos;: false &#125; &#125;,</span><br><span class="line">  &#123; $sort: &#123; &apos;updatedTime&apos;: -1，&apos;_id&apos;: -1 &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><p>如果我们运用管道操作符 $ifNull 去实现的话，可以更改更新时间结构，并填充默认值来达到我们期望的排序结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.deals.aggregate([</span><br><span class="line">  &#123; $match: &#123; &apos;isArchive&apos;: false &#125; &#125;,</span><br><span class="line">  &#123; $project: &#123;</span><br><span class="line">    title: 1,</span><br><span class="line">    updatedTime: &#123; $ifNull: [ &quot;$updatedTime&quot;, ISODate(&apos;9000-01-01&apos;)] &#125;</span><br><span class="line">  &#125; &#125;</span><br><span class="line">  &#123; $sort: &#123; &apos;updatedTime&apos;: -1&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><p>使用 $ifNull 数据填充来进行排序效率比空值比较排序效率要高，MongoDB 官方也给出了排序类型效率顺序图，如下所示：</p><p><img src="https://images-cdn.shimo.im/jYpiTSHI4u0QHuuY/image.png!thumbnail" alt="图片"><br>图二：不同类型排值图</p><ul><li>管道操作符之$cond</li></ul><p>定义：评估布尔表达式以返回两个指定的返回表达式之一。<br>如果我们要实现按照更新时间对未归档机会进行排序，更新时间为空的填充默认值，我们可以这样实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.deals.aggregate([</span><br><span class="line">  &#123; $match: &#123; &apos;isArchive&apos;: false &#125; &#125;,</span><br><span class="line">  &#123; $project: &#123;</span><br><span class="line">    title: 1,</span><br><span class="line">    updatedTime: &#123; $cond: &#123;</span><br><span class="line">      if：&#123;&apos;$eq&apos;: [&apos;$updatedTime&apos;, null]&#125; ,</span><br><span class="line">      then: ISODate(&apos;9000-01-01&apos;)</span><br><span class="line">      else &apos;$updatedTime&apos;</span><br><span class="line">    &#125; &#125;</span><br><span class="line">  &#125; &#125;</span><br><span class="line">  &#123; $sort: &#123; &apos;updatedTime&apos;: -1&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ul><li><strong>策略优化</strong><ul><li>将<strong> $match</strong> 和 <strong>$sort </strong>放到管道的前面，可以给集合建立索引，来提高处理数据的效率</li><li>可以用 <strong>$match、$limit、$skip</strong> 对文档进行提前过滤，以减少后续处理文档的数量</li></ul></li><li><strong>MongoDB 自身优化器</strong><ul><li><strong>$sort </strong>+ <strong>$match</strong> 顺序优化<ul><li>如果 $match 出现在 $sort 之后，优化器会自动把 $match 放到 $sort 前面</li></ul></li><li><strong>$skip</strong> + <strong>$limit</strong> 顺序优化<ul><li>如果 $skip 在 $limit 之后，优化器会把 $limit 移动到 $skip 的前面，移动后 $limit的值等于原来的值加上 $skip 的值<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1></li></ul></li></ul></li><li><strong>返回结果大小</strong><ul><li>聚合结果返回的是一个文档，不能超过 16M，从 MongoDB 2.6版本以后，返回的结果可以是一个游标或者存储到集合中，返回的结果不受 16M 的限制。</li></ul></li><li><strong>内存</strong><ul><li>在进行 Group 操作的时候，如果内容超过 100 M，将会抛错  “<strong>Exceeded memory limit for $group, but not allow enternal sort, put allowDiskUse true</strong>”，如果需要处理大数据，可以使用 allowDiskUse 选项，存储到磁盘上<strong>。</strong></li></ul></li><li><strong>聚合操作符使用</strong><ul><li>在进行 $project 操作的时候，我们时常会把不需要的值过滤掉，以此来减少聚合操作对内存的消耗，但是不可以删除默认的 _id, 如果删除会抛错 “<strong>exception: The top-level _id field is the only field currently supported for exclusion</strong>”，<strong>_id</strong> 作为官方字段不可以删除掉。</li></ul></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天我为你介绍了 MongoDB 聚合管道的应用实践、技巧、优化以及注意事项，解释了聚合管道操作符的基础概念，希望能够对你有所帮助。</p><p>这就是以上全部的内容，留几道思考题给你吧。你们公司使用 MongoDB 聚合管道吗？一般使用在什么业务上面？你觉得好用吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://images-cdn.shimo.im/PYv34sYTcsMSc6Nb/image.png!thumbnail&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于技术人员来说，“管道” 相信大家都不会感到陌生，在很多技术领域都有管道的概念，例如L
      
    
    </summary>
    
      <category term="数据库" scheme="https://sensitivemix.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Database" scheme="https://sensitivemix.github.io/tags/Database/"/>
    
      <category term="MongoDB" scheme="https://sensitivemix.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>区块链的运行原理</title>
    <link href="https://sensitivemix.github.io/2018/04/08/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>https://sensitivemix.github.io/2018/04/08/区块链的运行原理/</id>
    <published>2018-04-08T07:17:12.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>区块链到底是如何运行的？</p><p>这一篇文章我将以比特币区块链为例来进行讲解，理由有两个：</p><ol><li><p>由于区块链发展到目前阶段，各个技术方向都有长足的发展，那么为了方便你理解，我在这里介绍最简单、最容易理解的比特币区块链；</p></li><li><p>由于大部分区块链都是以比特币区块链为基础进行扩充的，所以首先了解比特币区块链有助于其他项目区块链的后续学习。</p></li></ol><h2 id="中心化记账的问题"><a href="#中心化记账的问题" class="headerlink" title="中心化记账的问题"></a>中心化记账的问题</h2><p>首先，我们借鉴了一个区块链描述中的经典情景来模拟中心化记账。</p><p>假设有一个有百户居民的村子，其中有一位德高望重的村长，村长有一个儿子。村民们都把钱存到村长家，村长负责记账。比如，张三用 1000 买了李四家的牛，村长就把张三名下的存款减去 1000，李四家加上 1000。听起来是不是很像银行的操作？</p><p>对，我们就是先从中心化的银行记账开始聊起。村民都相信村长，才愿意把钱存到村长家，他们相信村长不会作恶。</p><p>可惜好景不长，老村长由于操劳过度，驾鹤西去了。新上任的村长儿子铁蛋很是聪明，但也有个毛病，就是粗心大意。他不但经常算错账，一次还被人偷改了账单。</p><p>不过，幸好村民自己都有记账，但是由于铁蛋每次错账后都要和别人核对半天，导致村民对新村长的记账能力十分不满。</p><p>时间就这么过着，然而最可怕的事情还是发生了，铁蛋的老婆竟然私下篡改账本，给铁蛋七大姑八大姨的余额全部偷偷加了好多，终于有一天事情暴露，村民们气冲冲地跑到铁蛋家里讨说法，于是一片混乱。</p><p>这时候有个叫中本聪的人站了出来，他说他设计了一套系统，可以不依赖任何人记账，于是，众人开始将目光集中到他的身上。</p><h3 id="1-公开记账"><a href="#1-公开记账" class="headerlink" title="1. 公开记账"></a><strong>1. 公开记账</strong></h3><p>中本聪说他的系统稍微麻烦一点，需要干三件事儿。</p><ol><li><p>每家每户都派发一只信鸽。这就是 <a href="https://baike.baidu.com/item/%E5%AF%B9%E7%AD%89%E7%BD%91%E7%BB%9C/5482934?fr=aladdin" target="_blank" rel="noopener">P2P</a> 网络，是一个点对点的分布式网络，如果不好理解，你先不用理会，我会在后面讲到。</p></li><li><p>每家每户都发一个特殊的印章和一个扫描器。这个扫描器有两个功效，一是识别他人的交易是否真实有效，二是识别这个交易是不是自己账号的，同时识别并解锁未花费的余额。这就是<a href="https://baike.baidu.com/item/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/9874417?fr=aladdin" target="_blank" rel="noopener">非对称加密</a>。</p></li><li><p>每家每户可以参与记账，不过不再记余额，而是记交易本身的内容。这就是区块链中的交易，这个“交易”对应的英文单词是“Transaction”，这是个专有名词，专指一笔账，不同于金融交易的 Trade。</p></li></ol><p>这三条总体来说其实是干一件事情，就是：</p><p><strong>每家每户都记账，账簿上不再记载每户村民的余额，而只记载每一笔 Transaction，即记载每一笔交易的付款人、收款人和付款金额。</strong></p><p>那么问题就来了：如果每户都记账，肯定每户的账都不统一啊，你记你的，我记我的，最后不全乱了么？</p><p>这个时候需要大家统一账本，保证大家的账本都是一致的。因为记录的交易是全村所有人有序产生的，所以这就需要有一个广播机制。这个广播机制，我先卖个关子，后面再讲。</p><p>中本聪说，其实很简单，我们现在先把全村所有人的资产都加起来。还真巧了，刚好 100 万。</p><p>中本聪接着说：“只要账簿的初始状态确定，并且每一笔交易可靠并按照物理时间自然记录，并且只加不改不删，这样，当前每户持有多少资产是可以推算出来的。”</p><p>中本聪说我现在把我的印章给你们看，这个印章很特殊，盖的章有两块标记，第一块是一个可以识别的标记，比如我往纸上一敲，可识别的标记是 1MsTg2。</p><p>这就是你们的代号，由于我们账本是公开的，使用真实姓名会很危险，所以你们记账的交易单上收款人、付款人都填这个码，不用写姓名。你的扫描器和你的印章生成的代号是关联的，有且仅有持有对应扫描器的人才能花费金额，这一步即为“解开交易”。</p><p>刚刚说印章有两块，这第二块内容配合这个扫描器才能看，肉眼看则都是乱码，扫描器一扫就知道第二块内容是否有效，这一步也就是“交易验证”。</p><p>并且所有交易大家都能接收，都能看到，但却解不开印章乱码部分的内容，仅仅收款方才能解开，因为你的扫描器和你印章生成的代号是关联的，有且仅有持有对应扫描器的人才能解开交易。</p><p>以上就是区块链中“公开记账”的过程。“公开记账”就是全网所有人都可以随时查看一套账本，然后按照规则透明公开地进行记账。</p><h3 id="2-创建创世区块"><a href="#2-创建创世区块" class="headerlink" title="2. 创建创世区块"></a><strong>2. 创建创世区块</strong></h3><p>创世区块是我们生成全村公开账本的第一笔交易的第一个信封，好比一篇文章总得有个开头一样。</p><p>于是乎，中本聪说我先生成第一个 Transaction，这个交易单的付款人为空，收款人是村长，付款金额是 100 万，因为是创世区块，产出多少个是可以随意规定的，由于我们上面统计了全村的账目情况，所以我就写了 100 万，待会儿付款给村长以后，我们可以按照原来的账本给大家发送对应的金额过去。</p><p>好了，我们有了第一笔交易，第一个信封也已经做好了。现在让村长把信封传给张三，张三复印一份，然后传给李四，李四继续传下去，一传十，十传百，直到传给全村人，这个步骤也就是“同步区块”，也就是全网都拿到这个信封，以及信封里面的 Transaction。</p><h3 id="3-交易"><a href="#3-交易" class="headerlink" title="3. 交易"></a><strong>3. 交易</strong></h3><p>由于上一节我们的创世区块把 100 万交给了村长，那么我们假设张三在村长那里的存款余额是 10 万，这时候村长要根据原来的旧账本，把这 10 万发送给张三，然后把旧账本上的账划掉。下面我们讨论一下如何构造这笔交易。</p><p>中本聪开始教村长写交易单，把 100 万分成两部分，第一部分 10 万，收款人是张三；第二部分是 90 万，收款人是自己；这样一个 Transaction 就做成啦。</p><p>前面我们说了，不能直接写名字，要写代号，这个代号也就是你的钱包地址，我们需要把收款人写名字的地方，让收款人拿出自己印章，把代号读出来，然后告诉村长即可。</p><p>100 万 　10 万，张三<br>　　　　 90 万，自己</p><p>村长写好 Transaction 以后，还需要拿出自己的印章，在 Transaction 上盖章，这个盖章的过程也就相当于区块链中的签名。这个章，全村人都可以拿扫描器扫一下验证是否有效，即验证付款人的章是否有效。</p><p>100 万 　10 万，张三的印章（1s25vR）<br>　　　　 90 万，村长的印章（13gYip）</p><p>就这样，村长一共写了 10 份 Transaction，分别代表了发送给不同人的交易，张三一笔 10 万，李四一笔 1 万，等等。</p><h3 id="4-打包-Transaction-（挖矿）"><a href="#4-打包-Transaction-（挖矿）" class="headerlink" title="4. 打包 Transaction （挖矿）"></a><strong>4. 打包 Transaction （挖矿）</strong></h3><p>现在我们有了 Transaction，但是还需要东西把 Transaction 装起来，我们用一个特殊的信封把 Transaction 装起来，这个信封就是区块链中的“区块”，这个封装过程就是“打包交易”。</p><p>为什么要封装起来呢？是为了让打包交易的人能够在信封上署名，表示这次打包是由某某某打包的，其次全村的交易可能非常多，需要装配标号，方便大家查询。</p><p>我们看到上述的 Transaction 虽然已经生成，但是有个问题，就是没有规定谁有权利把 Transaction 封装到信封里。</p><p>我们在开篇的故事中看到了中心化操作肯定是不行的，假设在全村人中，这时候如何筛选出这些打包的人呢？</p><p>中本聪这时候说了，由于我们村的人口增长，100 万未来可能不够，我们暂定 150 万，那多余的 50 万，我们就当奖励给这些装信封的人了，当然不能一次性给，谁装一次信封就领 3 个币。</p><p>这时候大家伙儿来劲了呀，只要装信封就能够领钱了，我们在这里把符合条件的人称作“矿工”。</p><p>但是中本聪又说了，要获得这个装信封的权利，是有条件的。我给大家出一个难题，谁先解出这个难题的答案，谁就有权利把 Transaction 装到一个信封中，并且要在此信封上盖上自己的章。</p><p>这个难题是这样的，它有两大特性，第一是容易验证，第二是计算过程非常复杂。</p><p>例如，有种棋牌类游戏叫作“24 点”，玩法就是给出任意 4 个整数，通过整数运算得到 24，比如现在给出 2、9、1、5 四个数，答案是（5-2）*（9-1）= 24。当然，本处仅是举例，“24 点”游戏的答案空间非常小，是远远不够生成信封的。</p><p>答案非常好验证，但是计算过程是一个尝试的过程，需要耗费大量的精力。而在真实的比特币中，采用的是寻找符合条件的目标哈希，这也就是比特币矿工所做的事情。</p><p>好了，这时候大家开始计算给出的难题，刚好李四第一个计算出来，那么这次装信封的操作就由李四完成，李四把 10 份 Transaction 装到信封中，也就是打包 Transaction，并且要在信封背面写上一个信封的摘要信息。</p><p>比如上一个信封中的第一个交易是什么、信封封面长什么样，最后要在信封上盖上章，也就是“签名”，矿工签名的目的是为了领币，也就是 Coinbase 交易。</p><p>以上过程在区块链领域称作“打包 Transaction”，也就是大名鼎鼎的“挖矿”。</p><h3 id="5-广播交易"><a href="#5-广播交易" class="headerlink" title="5. 广播交易"></a><strong>5. 广播交易</strong></h3><p>来说说上文提到的广播交易，广播是为了让全村人知道当前时刻你产生了一笔 Transaction，或者是你装好了一个信封。</p><p>广播的内容分两种，一种是广播 Transaction，一种是广播信封。第一种广播是意味着还有未被打包的 Transaction，而第二种广播信封则意味着这个 Transaction 已经被某个矿工确认。</p><p>收到了广播的通知后，大家先验证信封上难题的答案是否正确，这样便可以验证出信封是否被伪造，接着验里面的每笔交易，最后还要验证信封背面的内容，即上一个信封的摘要是否正确。因为上一个信封大家都已经确认，所以这样可以极大地规避作弊的可能。如果觉得没问题，就可以存入本地数据库中了。</p><p>至此，全村人的记账问题就差不多解决啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;区块链到底是如何运行的？&lt;/p&gt;
&lt;p&gt;这一篇文章我将以比特币区块链为例来进行讲解，理由有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;由于区块链发展到目前阶段，各个技术方向都有长足的发展，那么为了方便你理解，我在这里介绍最简单、最容易理解的比特币区块链；&lt;/p&gt;
&lt;/li&gt;

      
    
    </summary>
    
      <category term="前沿技术" scheme="https://sensitivemix.github.io/categories/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Blockchain" scheme="https://sensitivemix.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>区块链简介</title>
    <link href="https://sensitivemix.github.io/2018/03/09/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E4%BB%8B/"/>
    <id>https://sensitivemix.github.io/2018/03/09/区块链简介/</id>
    <published>2018-03-09T07:15:57.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p><strong>任何事物的发展，从来不是一蹴而就的。</strong></p><p>商贸合作中签订的合同，怎么确保对方能遵守和执行？</p><p>餐厅宣称刚从海里打捞上来的三文鱼，怎么证明捕捞时间和运输中的卫生？</p><p>数字世界里，怎么证明你对资产的所有？</p><p>这些看似很难解决的问题，在区块链的世界里已经有了初步的答案。</p><hr><h2 id="从数字货币说起"><a href="#从数字货币说起" class="headerlink" title="从数字货币说起"></a>从数字货币说起</h2><p>货币是人类文明发展过程中的一大发明，最重要的职能包括价值尺度、流通手段、贮藏手段。很难想象离开了货币，现代社会庞大而复杂的经济和金融体系还能否持续运转。</p><p>历史上，货币的形态经历了多个阶段的演化，包括实物货币、金属货币、代用货币、信用货币、电子货币、数字货币等。货币自身的价值依托也从实物价值、发行方信用价值，到今天出现的对信息系统（包括算法、数学、密码学、软件等）的信任价值。</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>一般等价物都可以作为货币使用。然而平时最常见的还是纸币本位制，既方便携带、不易仿制、又相对容易辩伪。</p><p><em>注意，严格来讲，货币（money）不等于现金或通货（cash，currency），货币的范围更广。</em></p><p>或许有人认为信用卡相对纸币形式更方便。相对于信用卡这样的集中式支付体系来说，货币提供了更好的匿名性。另外，一旦碰到系统故障、断网、没有刷卡机器等情况，信用卡就不可用了。</p><p>无论是货币，还是信用卡模式，都需要额外的系统（例如银行）来完成生产、分发、管理等操作，带来很大的额外成本和使用风险。诸如伪造、信用卡诈骗、盗刷、转账等安全事件屡见不鲜。</p><p>很自然的，如果能实现一种数字货币，保持既有货币的这些特性，消除纸质货币的缺陷，无疑将带来巨大的社会变革，极大提高经济活动的运作效率。</p><h2 id="数字货币相比于传统货币"><a href="#数字货币相比于传统货币" class="headerlink" title="数字货币相比于传统货币"></a>数字货币相比于传统货币</h2><p>让我们来对比现在的数字货币和现实生活中的纸币：</p><table><thead><tr><th>属性</th><th>分析</th><th>胜出方</th></tr></thead><tbody><tr><td>便携</td><td>这点上应该没有争议，显然数字形式的货币胜出。</td><td>数字货币</td></tr><tr><td>防伪</td><td>这点上应该说两者各有千秋，但数字货币可能略胜一筹。纸币依靠的是各种设计（纸张、油墨、暗纹、夹层等）上的精巧，数字货币依靠的则是密码学上的保障。事实上，纸币的伪造时有发生，但数字货币的伪造明面上还没能实现。</td><td>数字货币</td></tr><tr><td>辩伪</td><td>纸币即使依托验钞机仍会有误判情况，数字货币依靠密码学基本不可能出错。数字货币胜出。</td><td>数字货币</td></tr><tr><td>匿名</td><td>通常情况下，两者都能提供很好的匿名性。但都无法防御有意的追踪。</td><td>平局</td></tr><tr><td>交易</td><td>对纸币来说，谁持有纸币谁就是合法拥有者，交易通过纸币自身的转移即可完成。对数字货币来说则复杂的多，因为任何数字物品都是可以被复制的，因此需要额外的机制。为此，比特币发明了区块链技术来确保可靠不可篡改的交易。</td><td>纸币</td></tr><tr><td>资源</td><td>100 美元钞票的生产成本是 0.1 美元左右。100 面额人民币的生产成本说法众多，但估计应该在几毛到几块范围内。数字货币消耗的资源则复杂的多，以最坏情况估计，算出来多少就要消耗多少电（往往要更多）。</td><td>纸币</td></tr><tr><td>发行</td><td>纸币的发行需要第三方机构的参与，数字货币则通过分布式算法来完成发行。在人类历史上，通胀和通缩往往是不合理地发行货币造成的；数字货币尚无机会被验证，在这方面的表现还有待观察。</td><td>平局</td></tr></tbody></table><p>可见，数字货币并非在所有领域都优于已有的货币形式。不带前提的在所有领域都鼓吹数字货币并不是一种严谨的态度，应该针对具体情况具体分析。实际上，仔细观察目前支持数字货币的交易机构就会发现端倪，当前还没有一种数字货币能完整起到货币的职能。</p><p>最后，虽然当前的数字货币“实验”已经取得了巨大成功，但可见的局限也很明显：其依赖的分布式账本技术还缺乏大规模场景下考验；性能和安全性还有待提升；资源的消耗还过高等等。这些问题还有待于相关技术的进一步发展。</p><hr><h3 id="实现挑战"><a href="#实现挑战" class="headerlink" title="实现挑战"></a>实现挑战</h3><p>设计和实现一个数字货币并非易事。</p><p>在现实生活中，因为纸币具备可转移性，相对容易地完成价值的交割。但是因为电子内容天然具备零复制成本，无法通过发送电子内容来完成价值的转移。持有人可以试图将同一份电子货币发给多个人，这种被称为“双重支付攻击（Double-Spent）”。</p><p>也许有人会讲，当前银行中的货币都是电子化的，因为通过账号里面的数字记录了资产。说的没错，这种电子货币模式有人称为“数字货币 1.0”，它实际上是假定存在一个安全可靠的第三方记账机构来实现，这个机构利用信用作为抵押，来完成交易。</p><p>这种中心化控制下的数字货币实现相对简单，但需要一个中心管控系统。但是，很多时候并不存在一个安全可靠的第三方记账机构来充当这个中心管控的角色。</p><p>例如，贸易两国可能缺乏足够的外汇储备；网络上的匿名双方进行直接买卖；交易的两个机构彼此互不信任，找不到双方都认可的第三方担保；汇率的变化；可能无法连接到第三方的系统；第三方的系统可能会出现故障……</p><p>总结一下，在去中心化的场景下，存在几个难题：</p><ul><li><p>货币的防伪：谁来负责验证货币；</p></li><li><p>货币交易：如何确定货币从一方转移到另外一方；</p></li><li><p>避免双重支付：如何避免出现双重支付。</p></li></ul><p>好吧，这事其实不太容易。</p><hr><h3 id="比特币出现"><a href="#比特币出现" class="headerlink" title="比特币出现"></a>比特币出现</h3><p>在不存在一个第三方记账机构的情况下，如何实现一个数字货币系统呢？</p><p>近三十年来，数字货币技术朝着这个方向努力，经历了几代演进，包括 <a href="http://www.hit.bme.hu/~buttyan/courses/BMEVIHIM219/2009/Chaum.BlindSigForPayment.1982.PDF" target="_blank" rel="noopener">e-Cash</a>、<a href="http://en.wikipedia.org/wiki/Hashcash" target="_blank" rel="noopener">HashCash</a>、<a href="http://www.weidai.com/bmoney.txt" target="_blank" rel="noopener">B-money</a>等。</p><p>1983 年，<a href="https://en.wikipedia.org/wiki/David_Chaum" target="_blank" rel="noopener">David Chaum</a> 最早提出<a href="http://www.hit.bme.hu/~buttyan/courses/BMEVIHIM219/2009/Chaum.BlindSigForPayment.1982.PDF" target="_blank" rel="noopener">ecash</a>，并于 1989 年创建了 <a href="https://en.wikipedia.org/wiki/Digicash" target="_blank" rel="noopener">Digicash</a> 公司。ecash 系统是首个匿名化的数字加密货币（anonymous cryptographic electronic money, or electronic cash system），基于 David Chaum 发明的盲签名技术，曾被应用于银行小额支付中。ecash 依赖于一个中心化的中介机构，导致它最终失败。</p><p>1997 年，<a href="https://en.wikipedia.org/wiki/Adam_Back" target="_blank" rel="noopener">Adam Back</a> 发明了 <a href="http://en.wikipedia.org/wiki/Hashcash" target="_blank" rel="noopener">Hashcash</a>，来解决邮件系统中 DoS 攻击问题。Hashcash 首次提出用工作量证明（Proof of Work，PoW）机制来获取额度，该机制后来被后续数字货币技术所采用。</p><p>1998 年，<a href="http://www.weidai.com/" target="_blank" rel="noopener">Wei Dai</a> 提出了 <a href="http://www.weidai.com/bmoney.txt" target="_blank" rel="noopener">B-money</a>，将 PoW 引入数字货币生成过程中。B-money 同时是首个面向去中心化设计的数字货币。从概念上看已经比较完善，但是很遗憾的是，其未能提出具体的设计实现。</p><p>上面这些数字货币都或多或少的依赖于一个第三方系统的信用担保。直到比特币的出现，将 PoW 与共识机制结合在一起，<strong>首次从实践意义上实现了一套去中心化的数字货币系统</strong>。</p><p>比特币网络无需任何管理机构，自身通过数学和密码学原理来确保了所有交易的成功进行，比特币自身的价值是通过背后的计算力为背书。这也促使人们开始思考在未来的数字世界中，该如何衡量价值，如何发行货币。</p><p>目前看来，数字货币比较有影响力的模式有两种，一种是类似 paypal 这样的选择跟已有的系统合作，成为代理；一种是以比特币这样的完全丢弃已有体系的分布式技术。</p><p>现在还很难讲哪种模式将成为未来的主流，甚至未来还可能出现更先进的技术。但对比特币这一类数字货币的设计进行探索，将是一件十分有趣的事情。</p><hr><h3 id="什么是区块链"><a href="#什么是区块链" class="headerlink" title="什么是区块链"></a>什么是区块链</h3><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>区块链（Blockchain）技术自身仍然在飞速发展中，目前还缺乏统一的规范和标准。</p><p><a href="https://en.wikipedia.org/wiki/Block_chain_(database" target="_blank" rel="noopener">wikipedia</a> 给出的定义为：</p><blockquote><p>A blockchain —originally, block chain —is a distributed database that maintains a continuously-growing list of data records hardened against tampering and revision. It consists of data structure blocks—which hold exclusively data in initial blockchain implementations, and both data and programs in some of the more recent implementations—with each block holding batches of individual transactions and the results of any blockchain executables. Each block contains a timestamp and information linking it to a previous block.</p></blockquote><p>最早区块链技术雏形出现在比特币项目中。作为比特币背后的分布式记账平台，在无集中式管理的情况下，比特币网络稳定运行了近八年时间，支持了海量的交易记录，并未出现严重的漏洞。</p><p><em>注：比特币历史上唯一已知的漏洞事件曾导致比特币的恶意增发，但问题很快被发现并修正，相关非法交易被撤销。</em></p><p>公认的最早关于区块链的描述性文献是中本聪所撰写的 <a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener">比特币：一种点对点的电子现金系统</a>，但该文献重点在于讨论比特币系统，实际上并没有明确提出区块链的定义和概念。在其中，区块链被描述为用于记录比特币交易的账目历史。</p><p><img src="https://yeasy.gitbooks.io/blockchain_guide/born/_images/ledger.jpg" alt="古老的账本"></p><p><em>图 1.4.3.1 - 古老的账本</em></p><p>记账技术历史悠久，<a href="https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%BC%8F%E7%B0%BF%E8%AE%B0" target="_blank" rel="noopener">现代复式记账系统</a>（Double Entry Bookkeeping）是由意大利数学家卢卡·帕西奥利，1494 年在《Summa de arithmetica, geometrica, proportioni et proportionalità》一书中最早制定。复式记账法对每一笔账目同时记录来源和去向，首次将对账验证功能引入记账过程，提升了记账的可靠性。从这个角度来看，<strong>区块链是首个自带对账功能的数字记账技术实现</strong>。</p><p>更广泛意义地看，区块链属于一种去中心化的记录技术。参与到系统上的节点，可能不属于同一组织、彼此无需信任；区块链数据由所有节点共同维护，每个参与维护节点都能复制获得一份完整记录的拷贝。</p><p>跟传统的记账技术相比，其特点应该包括：</p><ul><li><p>维护一条不断增长的链，只可能添加记录，而发生过的记录都不可篡改；</p></li><li><p>去中心化，或者说多中心化，无需集中的控制而能达成共识，实现上尽量分布式；</p></li><li><p>通过密码学的机制来确保交易无法抵赖和破坏，并尽量保护用户信息和记录的隐私性。</p></li></ul><p>更进一步的，还可以将智能合约跟区块链结合到一起，让其提供除了交易（比特币区块链已经支持简单的脚本计算）功能外更灵活的合约功能，执行更为复杂的操作。这样扩展之后的区块链，已经超越了单纯数据记录的功能了，实际上带有点“普适计算”的意味了。</p><hr><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>区块链的基本原理理解起来并不难。基本概念包括：</p><ul><li><p>交易（Transaction）：一次操作，导致账本状态的一次改变，如添加一条记录；</p></li><li><p>区块（Block）：记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识；</p></li><li><p>链（Chain）：由一个个区块按照发生顺序串联而成，是整个状态变化的日志记录。</p></li></ul><p>如果把区块链作为一个状态机，则每次交易就是试图改变一次状态，而每次共识生成的区块，就是参与者对于区块中所有交易内容导致状态改变的结果进行确认。</p><p><em>图 1.4.3.2 - 区块链示例</em></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>根据参与者的不同，可以分为公开（Public）链、联盟（Consortium）链和私有（Private）链。</p><p>公开链，顾名思义，任何人都可以参与使用和维护，典型的如比特币区块链，信息是完全公开的。</p><p>如果引入许可机制，包括私有链和联盟链两种。</p><p>私有链，则是集中管理者进行限制，只能得到内部少数人可以使用，信息不公开。</p><p>联盟链则介于两者之间，由若干组织一起合作维护一条区块链，该区块链的使用必须是有权限的管理，相关信息会得到保护，典型如银联组织。</p><p>目前来看，公开链将会更多的吸引社区和媒体的眼球，但更多的商业价值应该在联盟链和私有链上。</p><p>根据使用目的和场景的不同，又可以分为以数字货币为目的的货币链，以记录产权为目的的产权链，以众筹为目的的众筹链等。</p><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>区块链是第一个试图自带信任化和防止篡改的分布式记录系统。它的出现，让大家意识到，除了互联网这样的尽力而为的基础设施外，我们还能打造一个彼此信任的基础设施。</p><p>类似比特币这样的大规模长时间自治运行的系统，也为区块链技术的应用开启了更多遐想的空间。如果人与人之间的交易无法伪造，合同都能确保可靠执行，世界是不是更美好一些了呢？这是技术进步再次给人类发展带来福利。</p><p>不提这种去中心化的金融系统是否能在现实中普及，在跨国交易、跨组织合作日益频繁的今天，已经有了不少有意义的尝试和参考。</p><p>更进一步，比特币只是基于区块链技术的一种金融应用（而且是直接嵌入区块链中），区块链技术还能带来更通用的计算能力。<a href="https://hyperledger.org/" target="_blank" rel="noopener">Hyperledger</a> 和 <a href="https://www.ethereum.org/" target="_blank" rel="noopener">Ethereum</a> 就试图做类似的事情，基于区块链再做一层平台层，让别人基于平台开发应用变得更简单。</p><p>另外，区块链本身可以作为分布式存储，也自然可以作为分布式计算引擎。可以想象，整个加入集群的设备都是计算引擎，大家通过付费来使用计算力，是不是就有点普适计算的意味了？</p><p>有理由相信，随着更多商业应用场景的出现，区块链技术将在未来金融和信息技术领域占据一席之地。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概况&quot;&gt;&lt;a href=&quot;#概况&quot; class=&quot;headerlink&quot; title=&quot;概况&quot;&gt;&lt;/a&gt;概况&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;任何事物的发展，从来不是一蹴而就的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;商贸合作中签订的合同，怎么确保对方能遵守和执行？&lt;/p
      
    
    </summary>
    
      <category term="前沿技术" scheme="https://sensitivemix.github.io/categories/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Blockchain" scheme="https://sensitivemix.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 设计模式与开发实践总结</title>
    <link href="https://sensitivemix.github.io/2018/02/26/Javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>https://sensitivemix.github.io/2018/02/26/Javascript-设计模式与开发实践总结/</id>
    <published>2018-02-26T07:13:59.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018-02-04"><a href="#2018-02-04" class="headerlink" title="2018.02.04"></a>2018.02.04</h1><h2 id="第一章：基础部分"><a href="#第一章：基础部分" class="headerlink" title="第一章：基础部分"></a>第一章：基础部分</h2><h3 id="1-1-多态类型语言和鸭子语言"><a href="#1-1-多态类型语言和鸭子语言" class="headerlink" title="1.1 多态类型语言和鸭子语言"></a>1.1 多态类型语言和鸭子语言</h3><ul><li>鸭子类型：走起来像鸭子，叫起来也像鸭子，那么他就是一只鸭子。<h3 id="1-2-多态"><a href="#1-2-多态" class="headerlink" title="1.2 多态"></a>1.2 多态</h3>多态含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。 </li><li>基本多态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var makeSound = function (animal) &#123;</span><br><span class="line">  if (animal instanceOf Duck) &#123;</span><br><span class="line">    console.log(&apos;嘎嘎嘎&apos;)</span><br><span class="line">  &#125; else if (animal instanceOf Chicken) &#123;</span><br><span class="line">    console.log(&apos;咯咯咯&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Duck = function() &#123;&#125;</span><br><span class="line">var Chicken = function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">makeSound(new Duck())</span><br><span class="line">makeSound(new Chicken())</span><br></pre></td></tr></table></figure></li></ul><p>优化多态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var makeSound = function (animal) &#123;</span><br><span class="line">  animal.sound()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Duck = function() &#123;&#125;</span><br><span class="line">Duck.prototype.sound = function() &#123;</span><br><span class="line">  console.log(&apos;嘎嘎嘎&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Chicken = function() &#123;&#125;</span><br><span class="line">Chiecken.prototype.sound = function() &#123;</span><br><span class="line">  console.log(&apos;咯咯咯&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>ES6 多态类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class MakeSound &#123;</span><br><span class="line">  sound (animal) &#123;</span><br><span class="line">    animal.sound()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Duck &#123;</span><br><span class="line">  sound () &#123;</span><br><span class="line">    console.log(&apos;嘎嘎嘎&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Chicken &#123;</span><br><span class="line">  sound () &#123;</span><br><span class="line">    console.log(&apos;咯咯咯&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var makesound = new MakeSound()</span><br><span class="line">var duck = new Duck()</span><br><span class="line">var chicken = new Chicken()</span><br><span class="line">makesound.sound(duck)</span><br><span class="line">makesound.sound(chicken)</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-2-6-多态在面向对象中的设计"><a href="#1-2-6-多态在面向对象中的设计" class="headerlink" title="1.2.6 多态在面向对象中的设计"></a>1.2.6 多态在面向对象中的设计</h3><p>假设我们要编写一个地图应用，现在有两家可选的地图 API 提供商供我们接入自己的应用。 目前我们选择的是谷歌地图，谷歌地图的 API 中提供了 show 方法，负责在页面上展示整个地图。 示例代码如下 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var googleMap = &#123; show: function()&#123;</span><br><span class="line"></span><br><span class="line">console.log( &apos;开始渲染谷歌地图&apos; ); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var renderMap = function()&#123; googleMap.show();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">renderMap(); // 输出:开始渲染谷歌地图</span><br></pre></td></tr></table></figure><p>后来因为某些原因，要把谷歌地图换成百度地图，为了让 renderMap 函数保持一定的弹性， 我们用一些条件分支来让 renderMap 函数同时支持谷歌地图和百度地图: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var googleMap = &#123; show: function()&#123;</span><br><span class="line"></span><br><span class="line">console.log( &apos;开始渲染谷歌地图&apos; ); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var baiduMap = &#123; show: function()&#123;</span><br><span class="line"></span><br><span class="line">console.log( &apos;开始渲染百度地图&apos; ); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var renderMap = function( type )&#123; if ( type === &apos;google&apos; )&#123; googleMap.show();</span><br><span class="line"></span><br><span class="line">&#125;else if ( type === &apos;baidu&apos; )&#123; baiduMap.show();</span><br><span class="line"></span><br><span class="line">&#125; &#125;;</span><br><span class="line"></span><br><span class="line">renderMap( &apos;google&apos; ); // 输出:开始渲染谷歌地图 renderMap( &apos;baidu&apos; ); // 输出:开始渲染百度地图</span><br></pre></td></tr></table></figure><p>可以看到，虽然 renderMap 函数目前保持了一定的弹性，但这种弹性是很脆弱的，一旦需要 替换成搜搜地图，那无疑必须得改动 renderMap 函数，继续往里面堆砌条件分支语句。 </p><p>优化实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class RenderMap &#123;</span><br><span class="line">  start (Map) &#123;</span><br><span class="line">    new Map().show()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BaiduMap &#123;</span><br><span class="line">  show () &#123;</span><br><span class="line">    console.log(&apos;开始渲染百度地图&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GoogleMap &#123;</span><br><span class="line">  show () &#123;</span><br><span class="line">    console.log(&apos;开始渲染谷歌地图&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const rendermap = new RenderMap()</span><br><span class="line">rendermap.start(BaiduMap)</span><br><span class="line">rendermap.start(GoogleMap)</span><br></pre></td></tr></table></figure><p>### </p><h3 id="1-4-1-使用克隆的原型模式"><a href="#1-4-1-使用克隆的原型模式" class="headerlink" title="1.4.1 使用克隆的原型模式"></a>1.4.1 使用克隆的原型模式</h3><p>从设计模式的角度讲，原型模式是用于创建对象的一种模式，如果我们想要创建一个对象， 一种方法是先指定它的类型，然后通过类来创建这个对象。原型模式选择了另外一种方式，我们 不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。 </p><p>既然原型模式是通过克隆来创建对象的，那么很自然地会想到，如果需要一个跟某个对象一 模一样的对象，就可以使用原型模式。 </p><p>假设我们在编写一个飞机大战的网页游戏。某种飞机拥有分身技能，当它使用分身技能的时 候，要在页面中创建一些跟它一模一样的飞机。如果不使用原型模式，那么在创建分身之前，无 疑必须先保存该飞机的当前血量、炮弹等级、防御等级等信息，随后将这些信息设置到新创建的 飞机上面，这样才能得到一架一模一样的新飞机。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用原型模式，我们只需要调用负责克隆的方法，便能完成同样的功能。</span><br></pre></td></tr></table></figure><p>原型模式的实现关键，是语言本身是否提供了 clone 方法。ECMAScript 5 提供了 Object.create 方法，可以用来克隆对象。代码如下: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Object.create = Object.create || function( obj )&#123; </span><br><span class="line">   var F = function() &#123;&#125; </span><br><span class="line">   F.prototype = obj </span><br><span class="line">   return new F() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Flane &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.height = 100   </span><br><span class="line">    this.width = 200</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var flane = new Flane()</span><br><span class="line">flane.height = 101</span><br><span class="line">flane.width = 201</span><br><span class="line"></span><br><span class="line">console.log(flane)</span><br><span class="line"></span><br><span class="line">const cloneFlane = Object.create(new Flane())</span><br><span class="line">console.log(cloneFlane)</span><br></pre></td></tr></table></figure><h1 id="2018-02-05"><a href="#2018-02-05" class="headerlink" title="2018.02.05"></a>2018.02.05</h1><h3 id="1-4-4-原型编程规范"><a href="#1-4-4-原型编程规范" class="headerlink" title="1.4.4 原型编程规范"></a>1.4.4 原型编程规范</h3><ul><li>所有数据都是对象</li><li>要得到一个对象，不是实例化一个类，而是找到一个对象作为原型并克隆它</li><li>对象会记住他的原型</li><li>如果对象无法响应某个请求，它会把这个请求委托给它的原型<h2 id="第二章：this、apply-和-call"><a href="#第二章：this、apply-和-call" class="headerlink" title="第二章：this、apply 和 call"></a>第二章：this、apply 和 call</h2><h3 id="2-1-1-关于-this-的指向"><a href="#2-1-1-关于-this-的指向" class="headerlink" title="2.1.1 关于 this 的指向"></a>2.1.1 关于 this 的指向</h3></li><li><p>作为对象的方法调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; </span><br><span class="line">  a: 1,</span><br><span class="line">  getA: function()&#123;</span><br><span class="line">      alert ( this === obj ); // 输出:true </span><br><span class="line">      alert ( this.a ); // 输出: 1</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure></li><li><p>作为普通函数调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.globalName = &apos;jack&apos;</span><br><span class="line"></span><br><span class="line">var map = function () &#123;</span><br><span class="line">  return this.globalName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(map())</span><br></pre></td></tr></table></figure></li><li><p>构造器调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var MyClass = function () &#123;</span><br><span class="line">  this.name = &apos;jack&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myclass = new MyClass()</span><br><span class="line">console.log(myclass.name)</span><br></pre></td></tr></table></figure></li><li><p>Function.prototype.apply 和 Function.prototype.call</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var object = &#123;</span><br><span class="line">  name: &apos;jack&apos;,</span><br><span class="line">  getName: function () &#123;</span><br><span class="line">    return this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var objectClone = &#123;</span><br><span class="line">  name: &apos;rose&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(object.getName())</span><br><span class="line">console.log(object.getName.call(objectClone))</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-call-和-apply"><a href="#2-2-call-和-apply" class="headerlink" title="2.2 call 和 apply"></a>2.2 call 和 apply</h3><p><strong>关键在于传入参数的形式不同</strong></p><p>apply 接受两个参数，第一个参数指向 this 的指向，第二个参数作为一个带下标的集合，这个集合可以是个数组，也可以是一个类数组，apply 方法将这个参数传递给被调用的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func = function (a, b, c) &#123;</span><br><span class="line">  console.log([a, b, c])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.apply(null, [1, 2, 3])</span><br></pre></td></tr></table></figure><p>call 接受多个参数，第一个参数指向 this 的指向，后面的参数依次传递给被调用的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var func = function (a, b, c) &#123;</span><br><span class="line">  console.log([a, b, c])</span><br><span class="line">&#125;</span><br><span class="line">func.call(null, 1, 2, 3)</span><br></pre></td></tr></table></figure><p><strong>用途</strong></p><ul><li><strong>改变 this 指向</strong></li><li><p><strong>Function.prototype.bind</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function()&#123; </span><br><span class="line">  var self = this, // 保存原函数</span><br><span class="line">  var context = [].shift.call( arguments ),</span><br><span class="line">  var args = [].slice.call( arguments ); </span><br><span class="line">  return function()&#123; // 返回一个新的函数</span><br><span class="line">  // 需要绑定的 this 上下文 // 剩余的参数转成数组</span><br><span class="line">    return self.apply( context, [].concat.call( args, [].slice.call(   arguments ) ) ); // 执行新的函数的时候，会把之前传入的 context 当作新函数体内的 this</span><br><span class="line">// 并且组合两次分别传入的参数，作为新函数的参数</span><br><span class="line">&#125; &#125;;</span><br><span class="line"></span><br><span class="line">var obj = &#123; </span><br><span class="line">  name: &apos;sven&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var func = function( a, b, c, d )&#123;</span><br><span class="line">alert ( this.name ); // 输出:sven</span><br><span class="line">alert ( [ a, b, c, d ] ) // 输出:[ 1, 2, 3, 4 ]</span><br><span class="line"></span><br><span class="line">&#125;.bind( obj, 1, 2 ); func( 3, 4 );</span><br></pre></td></tr></table></figure></li><li><p><strong>借用其他对象的方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = function (name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var B = function () &#123;</span><br><span class="line">  a.apply(this, arguments)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.prototype.getName = function () &#123;</span><br><span class="line">  return this.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = new B(&apos;hello&apos;)</span><br><span class="line">console.log(b.getName())</span><br></pre></td></tr></table></figure></li></ul><h1 id="2018-02-07"><a href="#2018-02-07" class="headerlink" title="2018.02.07"></a>2018.02.07</h1><h2 id="第二部分：设计模式"><a href="#第二部分：设计模式" class="headerlink" title="第二部分：设计模式"></a>第二部分：设计模式</h2><ul><li>单例模式</li></ul><p>单例模式的定义：保证一个类仅有一个实例，并提供唯一访问它的全局访问点。</p><h1 id="2018-02-10"><a href="#2018-02-10" class="headerlink" title="2018.02.10"></a>2018.02.10</h1><ul><li>单例模式实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var createLoginLayer = function()&#123;</span><br><span class="line">  var div = document.createElement( &apos;div&apos; )</span><br><span class="line">  div.innerHTML = &apos;我是登录浮窗&apos;</span><br><span class="line">  div.style.display = &apos;none&apos;</span><br><span class="line">  document.body.appendChild( div )</span><br><span class="line">  return div</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var createSingleLoginLayer = getSingle( createLoginLayer )</span><br><span class="line"></span><br><span class="line">document.getElementById( &apos;loginBtn&apos; ).onclick = function()&#123; </span><br><span class="line">  var loginLayer = createSingleLoginLayer()</span><br><span class="line">  loginLayer.style.display = &apos;block&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">下面我们再试试创建唯一的 iframe 用于动态加载第三方页面:</span><br><span class="line"></span><br><span class="line">var createSingleIframe = getSingle( function() &#123;</span><br><span class="line">  var iframe = document.createElement ( &apos;iframe&apos; )</span><br><span class="line">  document.body.appendChild( iframe )</span><br><span class="line">  return iframe</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">document.getElementById( &apos;loginBtn&apos; ).onclick = function()&#123; </span><br><span class="line">  var loginLayer = createSingleIframe()</span><br><span class="line">  loginLayer.src = &apos;http://baidu.com&apos;</span><br></pre></td></tr></table></figure></li></ul><h1 id=""><a href="#" class="headerlink" title="})"></a>})</h1><p>2018.02.12</p><h2 id="第五章：-策略模式"><a href="#第五章：-策略模式" class="headerlink" title="第五章： 策略模式"></a>第五章： 策略模式</h2><p>定义一系列算法，把他们封装起来，并且使他们可以相互替换。</p><h3 id="5-1-3-实例代码"><a href="#5-1-3-实例代码" class="headerlink" title="5.1.3 实例代码"></a>5.1.3 实例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var financeA = function () &#123;&#125;</span><br><span class="line"></span><br><span class="line">financeA.prototype.calculate = function (salary) &#123;</span><br><span class="line">  return salary * 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var financeB = function () &#123;&#125; </span><br><span class="line">financeB.prototype.calculate = function (salary) &#123;</span><br><span class="line">  return salary * 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var financeC = function () &#123;&#125;</span><br><span class="line">financeC.prototype.calculate = function (salary) &#123;</span><br><span class="line">  return salary * 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Bonus = function () &#123;</span><br><span class="line">  this.stragety = null</span><br><span class="line">  this.salary = null </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bonus.protoType.setStragety = function (stragety) &#123;</span><br><span class="line">  return this.stragety = stragety</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bouns.protoType.getBonus = function (stragety) &#123;    // 取得奖金数额</span><br><span class="line">  this.setStragety(stragety).calculate(this.salary) // 将计算奖金操作委托给对应的策略对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-7-策略模式的优缺点"><a href="#5-7-策略模式的优缺点" class="headerlink" title="5.7 策略模式的优缺点"></a>5.7 策略模式的优缺点</h3><ul><li>策略模式利用组合和委托和多态技术的思想，可以有效的避免多重条件选择条件。</li><li>策略模式提供了对开放-封闭原则的完美支持，将算法封装到 strategy 中，使得他们易于切换，易于理解，易于扩展。</li><li>策略模式的算法也可以复用在系统其它地方，从而避免许多重复的复制粘贴工作。</li><li>在策略模式中，利用组合和委托实现了 context 执行算法的能力，这也是继承一种更轻便的实现方案。<br>### <h2 id="第六章：代理模式"><a href="#第六章：代理模式" class="headerlink" title="第六章：代理模式"></a>第六章：代理模式</h2><h3 id="6-2-虚拟代理"><a href="#6-2-虚拟代理" class="headerlink" title="6.2 虚拟代理"></a>6.2 虚拟代理</h3>虚拟代码就是把开销很大的对象，留存到需要它的地方再去创建。<h3 id="6-8-缓存代理"><a href="#6-8-缓存代理" class="headerlink" title="6.8 缓存代理"></a>6.8 缓存代理</h3>缓存代理可以为一些开销大的运算结果提供暂时的存储，可用于 AJAX 请求对象<h3 id="6-10-其他代理模式"><a href="#6-10-其他代理模式" class="headerlink" title="6.10 其他代理模式"></a>6.10 其他代理模式</h3><ul><li>保护代理</li></ul></li></ul><p>保护代理用于控制不同权限的对象对目标对象访问</p><ul><li>防火墙代理</li></ul><p>控制网络资源的访问</p><ul><li>远程代理</li></ul><p>为一个对象在不同地址空间提供局部代表</p><ul><li>智能引用代理</li></ul><p>取代简单的指针，在对象访问的时候提供一些特殊的操作，比如计算一个对象被引用的次数</p><ul><li>写时复制代理</li></ul><p>通常用于复制一个庞大的对象，写时复制延迟了复制的过程。当对象真正被修改的时候，才去进行复制操作。写时复制是虚拟代理的一种变体，DLL （操作系统的动态链接库）是典型的运用场景</p><h1 id="2018-02-26"><a href="#2018-02-26" class="headerlink" title="2018.02.26"></a>2018.02.26</h1><h2 id="享元模式：解决性能问题而生"><a href="#享元模式：解决性能问题而生" class="headerlink" title="享元模式：解决性能问题而生"></a>享元模式：解决性能问题而生</h2><p>适用场景：</p><ul><li>一个程序中使用了大量重复对象</li><li>由于使用大量对象，造成内存开销</li><li>对象的大对数状态多可以变成外部状态</li><li>剥离出对象的外部状态之外，可以用较少的共享对象取代大量对象</li></ul><p>对象池：数据库连接对象，HTTP连接池适用场景</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2018-02-04&quot;&gt;&lt;a href=&quot;#2018-02-04&quot; class=&quot;headerlink&quot; title=&quot;2018.02.04&quot;&gt;&lt;/a&gt;2018.02.04&lt;/h1&gt;&lt;h2 id=&quot;第一章：基础部分&quot;&gt;&lt;a href=&quot;#第一章：基础部分&quot; cla
      
    
    </summary>
    
      <category term="设计模式" scheme="https://sensitivemix.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Javascript" scheme="https://sensitivemix.github.io/tags/Javascript/"/>
    
      <category term="DesignPattern" scheme="https://sensitivemix.github.io/tags/DesignPattern/"/>
    
  </entry>
  
  <entry>
    <title>单点登录基本概念</title>
    <link href="https://sensitivemix.github.io/2017/06/19/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://sensitivemix.github.io/2017/06/19/单点登录基本概念/</id>
    <published>2017-06-19T13:40:28.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  目前大部分网站都支持单点登录，何谓单点登录，就是一个账号可以登录多个网站，不用在每个网站都注册一个账号。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul><li>访问网站</li><li>跳转到授权服务器请求code授权码</li><li>授权服务器接受到请求根据回调地址，响应授权码</li><li>客户端收到授权码，转换成授权token认证</li><li>存入session或者持久化存储</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;  目前大部分网站都支持单点登录，何谓单点登录，就是一个账号可以登录多个网站，不用在每个网站都注册一个账号。&lt;/p&gt;
&lt;h2 id=&quot;流程&quot;
      
    
    </summary>
    
      <category term="开发" scheme="https://sensitivemix.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Login" scheme="https://sensitivemix.github.io/tags/Login/"/>
    
  </entry>
  
  <entry>
    <title>前端入门学习资料</title>
    <link href="https://sensitivemix.github.io/2017/06/17/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    <id>https://sensitivemix.github.io/2017/06/17/前端入门学习资料/</id>
    <published>2017-06-17T01:58:59.000Z</published>
    <updated>2019-04-14T02:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一阶段： 基础，包含 HTML CSS JavaScript<br>可学习的网站：<br>w3c：<a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">http://www.w3school.com.cn/</a>   （只看HTML/CSS JavaScript模块即可）<br>慕课网：<a href="http://www.imooc.com/course/programdetail/pid/32" target="_blank" rel="noopener">http://www.imooc.com/course/programdetail/pid/32</a><br>html/css基础课程： <a href="https://www.codecademy.com/learn/web" target="_blank" rel="noopener">https://www.codecademy.com/learn/web</a><br>less： <a href="http://www.bootcss.com/p/lesscss/" target="_blank" rel="noopener">http://www.bootcss.com/p/lesscss/</a><br>sass： <a href="http://www.sasschina.com/guide/" target="_blank" rel="noopener">http://www.sasschina.com/guide/</a><br>flex 布局：语法篇和实例篇 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a>   <a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a><br>注：less和sass都是让编写css变得更简单，你可以先熟悉其中一种，推荐less，简单些<br>flex是一种布局，可以避免各种相对绝对定位引起的浮动。</p><p>仿写的页面 <a href="http://www.thatsitmag.com/" target="_blank" rel="noopener">http://www.thatsitmag.com/</a>    用HTML和CSS实现这个页面，CSS用less写，页面布局用flex，如果能够完成，你的HTML和CSS就差不多了。要有耐心。</p><p>一些不错的技术论坛，有问题可以去那找答案或者发帖求助：<br>segmentfault：<a href="https://segmentfault.com/" target="_blank" rel="noopener">https://segmentfault.com/</a><br>dio.io：<a href="http://div.io/#/welcome" target="_blank" rel="noopener">http://div.io/#/welcome</a><br>v2ex：<a href="https://www.v2ex.com/" target="_blank" rel="noopener">https://www.v2ex.com/</a><br>一些不错的app：<br>segmentfault<br>开发者头条<br>推酷<br>36氪<br>前端工程师<br>一些不错的微信公众号：<br>前端大全<br>前端圈<br>前端早读课<br>程序员那些事<br>互联网实习by拉勾网<br>乔布简历<br>注：<br>在一些论坛和微信公众号上能看到招聘信息，你可以看看目前的招聘要求，自己要学的技术有哪些，增加动力。等你基础差不多了，我再给你整理深一点的东西。<br>在学习过程中学到的新的知识点，遇到问题是如何解决的，都可以记录下来，推荐你用石墨文档记录。</p><p>js: <a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></p><p>react中文:<a href="http://www.css88.com/react/docs/getting-started.html" target="_blank" rel="noopener">http://www.css88.com/react/docs/getting-started.html</a><br>react英文： <a href="http://reactjs.cn/react/docs/reusable-components.html#prop-" target="_blank" rel="noopener">http://reactjs.cn/react/docs/reusable-components.html#prop-</a></p><p>redux中文: <a href="http://cn.redux.js.org/" target="_blank" rel="noopener">http://cn.redux.js.org/</a><br>redux英文:<a href="http://redux.js.org/" target="_blank" rel="noopener">http://redux.js.org/</a></p><p>github基本操作命令演示 <a href="http://learngitbranching.js.org/?locale=zh_CN" target="_blank" rel="noopener">http://learngitbranching.js.org/?locale=zh_CN</a><br>sourcetree: <a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">https://www.sourcetreeapp.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一阶段： 基础，包含 HTML CSS JavaScript&lt;br&gt;可学习的网站：&lt;br&gt;w3c：&lt;a href=&quot;http://www.w3school.com.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.w3schoo
      
    
    </summary>
    
      <category term="学习资料" scheme="https://sensitivemix.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
      <category term="Tutorial" scheme="https://sensitivemix.github.io/tags/Tutorial/"/>
    
      <category term="Frontend" scheme="https://sensitivemix.github.io/tags/Frontend/"/>
    
  </entry>
  
</feed>
